for day 2 of studying create-expo-app, tasks listed between
"""
Read React Native documentation on basic components.<br>
Create a new function-based component in `App.js`.<br>
Replace default `App` component with the custom component.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 1: Read React Native documentation on basic components

- **Explanation 1**: React Native provides essential building blocks called components, which are analogous to HTML elements but designed for mobile applications. These components, such as `View`, `Text`, and `Image`, are designed to create the UI and are optimized for mobile devices. They come with specific attributes, behaviors, and properties that allow developers to build complex UIs using simple constructs.
- **Explanation 2**: Understanding these basic components is fundamental when developing apps with React Native because they allow you to create the structure and layout of your mobile app. Each component has different properties, and their behavior can be customized to fit the app's design. By referring to the official documentation, you’ll understand how these components work, how to style them, and how they are rendered on both iOS and Android platforms.

#### Online Resources
1. [React Native Components Overview](https://reactnative.dev/docs/components-and-apis)
2. [React Native Documentation](https://reactnative.dev/docs/getting-started)

#### Examples to Practice
1. **Example 1**: Create a simple `View` component containing a `Text` component.
    - **Explanation**: This is a basic setup where the `View` component acts as a container for the `Text` component. The `View` is the parent component that holds and organizes child components, while the `Text` component displays textual content.
    - **Explanation**: This exercise helps you understand how React Native renders basic components and how they can be nested. It introduces you to fundamental concepts such as component hierarchy and layout.

    ```javascript
    import React from 'react';
    import { View, Text } from 'react-native';

    const App = () => {
      return (
        <View>
          <Text>Hello World!</Text>
        </View>
      );
    };

    export default App;
    ```

    - **Expected Output**: The app should display the text "Hello World!" centered within a basic `View` layout.

2. **Example 2**: Create a `View` component with multiple `Text` components, each styled differently.
    - **Explanation**: This example introduces the concept of multiple `Text` components within the same `View`. Each `Text` component can have its unique style to show how styling works in React Native.
    - **Explanation**: This helps in understanding how styling is applied to components using `StyleSheet`. You will see how different styles can be applied to different components within the same `View`.

    ```javascript
    import React from 'react';
    import { View, Text, StyleSheet } from 'react-native';

    const App = () => {
      return (
        <View style={styles.container}>
          <Text style={styles.text1}>Hello, World!</Text>
          <Text style={styles.text2}>Welcome to React Native</Text>
        </View>
      );
    };

    const styles = StyleSheet.create({
      container: {
        padding: 10,
      },
      text1: {
        fontSize: 24,
        color: 'blue',
      },
      text2: {
        fontSize: 18,
        color: 'green',
      },
    });

    export default App;
    ```

    - **Expected Output**: The app will display two lines of text: "Hello, World!" in blue and "Welcome to React Native" in green.

#### Additional Resources for Examples
1. [React Native View Component](https://reactnative.dev/docs/view)
2. [React Native Text Component](https://reactnative.dev/docs/text)

---

### Task 2: Create a new function-based component in `App.js`

- **Explanation 1**: Function-based components in React Native are simpler and easier to use compared to class-based components. With the introduction of React Hooks like `useState` and `useEffect`, function components can manage state and lifecycle without needing to extend the `Component` class.
- **Explanation 2**: By creating a function-based component in `App.js`, you’ll learn the modern way of writing React Native components. This approach enhances code readability, simplifies the structure, and reduces the amount of code required for basic functionalities like rendering UI and handling state.

#### Online Resources
1. [React Function Components](https://reactnative.dev/docs/components-and-apis#functional-components)
2. [Hooks in React](https://reactjs.org/docs/hooks-intro.html)

#### Examples to Practice
1. **Example 1**: Create a simple function-based component that renders a greeting message.
    - **Explanation**: This example introduces how to create and render a function-based component. The function component returns a `View` and `Text` component to display a message on the screen.
    - **Explanation**: This task is fundamental in learning how React Native works with function components, and it’s a great introduction to how components are structured in modern React development.

    ```javascript
    import React from 'react';
    import { View, Text } from 'react-native';

    const Greeting = () => {
      return (
        <View>
          <Text>Hello from a Function Component!</Text>
        </View>
      );
    };

    export default Greeting;
    ```

    - **Expected Output**: The screen will display the message: "Hello from a Function Component!"

2. **Example 2**: Create a function component that takes a prop and displays a personalized message.
    - **Explanation**: This example demonstrates how to pass data (props) to a function component. The `Greeting` component will accept a `name` prop and display a custom greeting.
    - **Explanation**: This is useful when building reusable components, as it shows how you can pass data dynamically to components to modify their behavior or display.

    ```javascript
    import React from 'react';
    import { View, Text } from 'react-native';

    const Greeting = ({ name }) => {
      return (
        <View>
          <Text>Hello, {name}!</Text>
        </View>
      );
    };

    const App = () => {
      return <Greeting name="John Doe" />;
    };

    export default App;
    ```

    - **Expected Output**: The app will display the message "Hello, John Doe!" centered in the view.

#### Additional Resources for Examples
1. [Using Props in React Native](https://reactnative.dev/docs/props)
2. [React Native Function Components](https://www.reactnative.express/components/function_components)

---

### Task 3: Replace the default `App` component with the custom component

- **Explanation 1**: The default `App` component created by `create-expo-app` contains a basic structure. By replacing it with your custom component, you’ll learn how to structure an application in a modular fashion. Breaking components into smaller units makes the code more maintainable and easier to test.
- **Explanation 2**: This process teaches you how to import components, manage component hierarchy, and keep your `App.js` file clean. Each component can be isolated into its own file, making the application more scalable as you add more features.

#### Online Resources
1. [React Component Structure](https://reactnative.dev/docs/intro-react-native-components)
2. [How to Organize Components in React Native](https://blog.logrocket.com/a-quick-guide-to-structuring-your-react-native-app/)

#### Examples to Practice
1. **Example 1**: Replace the default `App` component with a `Greeting` component.
    - **Explanation**: This simple task will introduce you to the practice of organizing components into separate files and importing them into the main `App.js` file. The `Greeting` component will replace the default one, and the app will render the custom message.
    - **Explanation**: This is essential in a real-world scenario, as large applications often require multiple components that are organized across different files.

    ```javascript
    // Greeting.js
    import React from 'react';
    import { View, Text } from 'react-native';

    const Greeting = () => {
      return (
        <View>
          <Text>Custom Greeting Component</Text>
        </View>
      );
    };

    export default Greeting;
    ```

    ```javascript
    // App.js
    import React from 'react';
    import Greeting from './Greeting';

    const App = () => {
      return <Greeting />;
    };

    export default App;
    ```

    - **Expected Output**: The screen will display the message "Custom Greeting Component!"

2. **Example 2**: Replace the default `App` component with a `Greeting` component that accepts props.
    - **Explanation**: This example extends the previous one by passing a `name` prop to the `Greeting` component. This demonstrates how props are passed and how components can be customized dynamically.
    - **Explanation**: It further enhances your understanding of props and how they are used in React Native to pass data from parent to child components.

    ```javascript
    // Greeting.js
    import React from 'react';
    import { View, Text } from 'react-native';

    const Greeting = ({ name }) => {
      return (
        <View>
          <Text>Hello, {name}!</Text>
        </View>
      );
    };

    export default Greeting;
    ```

    ```javascript
    // App.js
    import React from 'react';
    import Greeting from './Greeting';

    const App = () => {
      return <Greeting name="React Developer" />;
    };

    export default App;
    ```

    - **Expected Output**: The screen will display "Hello, React Developer!"

#### Additional Resources for Examples
1. [React Component Imports and Exports](https://reactjs.org/docs/components-and-props.html)
2. [Props in React](https://reactjs.org/docs/components-and-props.html)

for day 2 of studying create-expo-app, tasks listed between
"""
Explore `View` and `Text` components.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 4: Explore `View` and `Text` Components

#### Explanation 1: Understanding the `View` Component
The `View` component is the most fundamental building block for creating layouts in React Native. It acts as a container that holds other components like `Text`, `Image`, and `Button`. `View` is similar to a `div` in HTML and can be used to style, arrange, and organize elements on the screen. You can apply styles, use Flexbox for layout, and even handle touch gestures within a `View` component. It serves as a wrapper that can encapsulate different UI elements and is essential for creating a cohesive app layout.

The flexibility of the `View` component allows developers to build complex UIs by nesting other components within it. You can structure your app's layout by defining parent-child relationships with nested `View` components. Moreover, `View` components are highly customizable through `StyleSheet` and support various properties like `padding`, `margin`, `backgroundColor`, and many others.

#### Explanation 2: Understanding the `Text` Component
The `Text` component is used to display textual content in a React Native app. It is a simple, yet powerful component that allows developers to render text, style it, and manage its behavior. You can wrap text inside a `Text` component, apply different styles like font size, font weight, color, and alignment. React Native’s `Text` component also supports nesting, so you can include multiple `Text` components inside each other for advanced formatting.

In React Native, all text should be wrapped in `Text` components for proper rendering and formatting. This approach ensures that your app's text content is optimized for mobile screens, providing a consistent experience across different platforms (iOS and Android). Text styling can be customized to match the theme of your app, making it crucial to understand how to manipulate the `Text` component effectively.

#### Online Resources
1. [React Native View Documentation](https://reactnative.dev/docs/view)
2. [React Native Text Documentation](https://reactnative.dev/docs/text)

---

### Example 1: Basic `View` and `Text` Layout

#### Explanation 1: Simple Usage of `View` and `Text`
In this example, we will create a basic `View` component that contains a single `Text` component. This layout will help you understand how to structure your app using a `View` as a container and how to display text using `Text`. The `View` serves as a wrapper for the `Text`, allowing you to apply styles to the container and control the overall layout.

#### Explanation 2: Benefits of Using `View` and `Text`
This basic example is a foundation for more complex layouts in React Native. By practicing this, you’ll understand how the `View` component handles child elements and how the `Text` component can be used to present information. This is essential in almost every React Native application, as both components are used frequently in creating user interfaces.

```javascript
import React from 'react';
import { View, Text } from 'react-native';

const App = () => {
  return (
    <View style={{ padding: 20 }}>
      <Text>Hello from View and Text Components!</Text>
    </View>
  );
};

export default App;
```

- **Expected Output**: The app will display "Hello from View and Text Components!" with some padding around the text.

#### Additional Resources for Examples
1. [React Native View Component Overview](https://reactnative.dev/docs/view)
2. [React Native Text Component Overview](https://reactnative.dev/docs/text)

---

### Example 2: Applying Styles to `View` and `Text`

#### Explanation 1: Using `StyleSheet` for Custom Styles
In this example, we will demonstrate how to apply custom styles to both the `View` and `Text` components using the `StyleSheet` API. The `View` component will have background color, padding, and margin, while the `Text` component will have custom font size, color, and text alignment. Styling is a critical part of UI development, and `StyleSheet` provides a way to keep your styles organized and reusable.

#### Explanation 2: Understanding the Flexibility of Styling
This example helps you see how you can customize the look and feel of your app's layout. By separating styles from your component's logic, you keep your code cleaner and more modular. The ability to control how elements look using `StyleSheet` is key to building user-friendly and visually appealing mobile applications.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Styled View and Text Components</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    margin: 10,
    backgroundColor: '#f0f0f0',
  },
  text: {
    fontSize: 18,
    color: 'blue',
    textAlign: 'center',
  },
});

export default App;
```

- **Expected Output**: The app will display "Styled View and Text Components" in blue text, centered inside a light gray `View` container with padding and margin.

#### Additional Resources for Examples
1. [React Native StyleSheet](https://reactnative.dev/docs/stylesheet)
2. [React Native Styling Tips](https://www.reactnative.express/core_components/text_and_views)

---

### Code Summary and Expected Outputs
- **Code for Example 1**:
```javascript
import React from 'react';
import { View, Text } from 'react-native';

const App = () => {
  return (
    <View style={{ padding: 20 }}>
      <Text>Hello from View and Text Components!</Text>
    </View>
  );
};

export default App;
```
- **Expected Output for Example 1**: The app will display the message "Hello from View and Text Components!" with some padding around it.

- **Code for Example 2**:
```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Styled View and Text Components</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    margin: 10,
    backgroundColor: '#f0f0f0',
  },
  text: {
    fontSize: 18,
    color: 'blue',
    textAlign: 'center',
  },
});

export default App;
```
- **Expected Output for Example 2**: The app will display "Styled View and Text Components" in blue text, centered in a padded, light gray container.

for day 2 of studying create-expo-app, tasks listed between
"""
Add a `Button` component and log a message on press.<br>
Test the button functionality on the mobile device.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 5: Add a `Button` Component and Log a Message on Press

#### Explanation 1: The React Native `Button` Component
The `Button` component in React Native provides a simple, clickable UI element. When pressed, it triggers a specific action, such as navigating to a different screen, submitting a form, or logging a message to the console. Unlike custom buttons where you have to define styles and behavior manually, the `Button` component comes with pre-defined behavior and styling, making it an easy-to-use component for many scenarios. Buttons are interactive and provide a clear call-to-action for users, which makes them an essential part of any mobile app.

React Native’s `Button` component allows you to pass an `onPress` prop that defines what action should be taken when the button is pressed. For basic interactions like logging a message, the `onPress` function can contain simple logic such as printing a message to the console. This is a great starting point for understanding how user interactions are handled in React Native.

#### Explanation 2: Handling User Interactions with `onPress`
The `onPress` prop in React Native buttons is used to define what happens when a user presses the button. It can execute any JavaScript function or command. In this task, you'll log a message to the console when the button is clicked. This basic functionality helps you understand how events are handled in React Native and how to respond to user input. In more advanced scenarios, the `onPress` event could trigger navigation, data fetching, or state updates.

This task is fundamental because handling user interaction is one of the core aspects of building interactive mobile applications. Buttons are a direct way to receive input from users, so understanding how to manage button presses is critical for creating a functional and responsive UI.

#### Online Resources
1. [React Native Button Component Documentation](https://reactnative.dev/docs/button)
2. [Handling Touch Events in React Native](https://reactnative.dev/docs/handling-touches)

---

### Example 1: Add a Button and Log a Message

#### Explanation 1: Basic Button with `onPress` Event
In this example, you'll create a simple button that logs a message to the console when pressed. This is a basic implementation of user interaction. The `Button` component takes two props: `title` to define the text shown on the button and `onPress`, which is triggered when the button is clicked.

#### Explanation 2: Logging the Button Click
This task demonstrates how easy it is to add basic interactivity to your app. When the button is pressed, the message “Button Pressed!” will be logged to the console, giving you a basic sense of how buttons work in React Native. This example is essential because logging can help you track how often certain actions are triggered and serve as a debugging tool in more complex interactions.

```javascript
import React from 'react';
import { View, Button } from 'react-native';

const App = () => {
  const handlePress = () => {
    console.log('Button Pressed!');
  };

  return (
    <View style={{ marginTop: 50 }}>
      <Button title="Press Me" onPress={handlePress} />
    </View>
  );
};

export default App;
```

- **Expected Output**: When the button is pressed, the message "Button Pressed!" will be logged to the console. You won’t see this in the app UI, but if you open the developer tools or emulator logs, you’ll see the message.

#### Additional Resources for Examples
1. [Button Component with onPress Prop](https://reactnative.dev/docs/button#onpress)
2. [Console Logging in React Native](https://reactnative.dev/docs/debugging)

---

### Example 2: Custom Button with a Different Action

#### Explanation 1: More Advanced Button Functionality
In this example, we add a button that not only logs a message to the console but also updates the state to track how many times the button has been pressed. This demonstrates a more practical use of `onPress`, where user interaction triggers state changes in the app. We will use `useState` to manage the state and update it every time the button is clicked.

#### Explanation 2: Tracking Button Press Count
This example highlights how to combine user interactions (`onPress`) with React Native state management (`useState`). By counting button presses, you can see how interactivity can affect the UI. This is a common pattern in mobile apps, where user actions modify the app’s state, triggering UI updates. The button now does more than just log a message—it also modifies and displays dynamic data.

```javascript
import React, { useState } from 'react';
import { View, Button, Text } from 'react-native';

const App = () => {
  const [count, setCount] = useState(0);

  const handlePress = () => {
    setCount(count + 1);
    console.log(`Button pressed ${count + 1} times!`);
  };

  return (
    <View style={{ marginTop: 50, alignItems: 'center' }}>
      <Button title="Press Me" onPress={handlePress} />
      <Text>You pressed the button {count} times</Text>
    </View>
  );
};

export default App;
```

- **Expected Output**: When the button is pressed, the text below it will update to show how many times the button has been clicked. The console will also log a message each time, such as "Button pressed 3 times!"

#### Additional Resources for Examples
1. [React Native useState Hook](https://reactjs.org/docs/hooks-state.html)
2. [Using Buttons with State in React Native](https://blog.logrocket.com/how-to-build-buttons-in-react-native/)

---

### Task 6: Test the Button Functionality on a Mobile Device

#### Explanation 1: Using Expo Go to Test on Device
After adding a button and logging messages, the next step is to test the functionality on a real device using Expo Go. Testing on a physical device is crucial because it allows you to see how your app behaves in a real-world environment. While simulators are useful, they don’t always perfectly emulate device performance, gestures, and behavior. Expo makes it easy to test React Native apps directly on your device without needing to go through the full build process.

Expo Go acts as a bridge between your development environment and your mobile device. Once your app is running, you can scan the QR code provided by Expo with your phone and see the app’s output in real-time. This is especially useful when testing UI components like buttons, where performance and responsiveness are important factors.

#### Explanation 2: Ensuring Button Responsiveness
By testing the button on a mobile device, you can verify its functionality, responsiveness, and user experience. Mobile devices vary in screen size, resolution, and processing power, so testing ensures that your app works as intended across different platforms. When testing the button, pay attention to how quickly it responds to presses, whether the state updates correctly, and if the logs appear as expected in the developer tools. Testing on real devices also helps in identifying platform-specific issues, such as differences between Android and iOS.

#### Online Resources
1. [Expo Documentation for Testing on Devices](https://docs.expo.dev/get-started/installation/)
2. [Testing Expo Apps on Physical Devices](https://docs.expo.dev/workflow/run-on-device/)

---

### Example 1: Testing the Button in Expo Go

#### Explanation 1: Running the App on an Android/iOS Device
Once you've developed your app with a button component, open the Expo development server by running `npm start` or `expo start`. You will see a QR code appear in your terminal or browser. Open the Expo Go app on your phone, scan the QR code, and your app will launch on your mobile device.

#### Explanation 2: Observing Button Behavior on the Device
When testing, press the button to ensure that the expected console logs appear. Also, pay attention to the UI changes and how responsive the button feels on a real device. This step is essential to ensure that user interactions are being handled correctly, and that the button’s layout and size are suitable for the device's screen.

---

### Example 2: Debugging Button Press Issues

#### Explanation 1: Verifying State Changes on Button Press
If you’re using a button that updates the state, such as the one from Example 2, you can test this functionality on a physical device by pressing the button multiple times. Check the console log in the Expo developer tools to verify that the button press count is logged correctly. Watch the on-screen text to ensure that the state updates and reflects the number of times the button was pressed.

#### Explanation 2: Checking Device-Specific Issues
Sometimes, buttons may behave differently on iOS and Android due to platform-specific differences. For example, you might find that the button is more responsive on one platform or that the layout behaves differently. By testing on a device, you can catch these issues early and make any necessary adjustments before final deployment.

#### Additional Resources for Examples
1. [How to Debug with Expo](https://docs.expo.dev/workflow/debugging/)
2. [Expo: Testing React Native Apps on Devices](https://reactnative.dev/docs/running-on-device)

for day 2 of studying create-expo-app, tasks listed between
"""
Study `StyleSheet` for creating styles in React Native.<br>
Create a custom style and apply it to components.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 7: Study `StyleSheet` for Creating Styles in React Native

#### Explanation 1: Understanding `StyleSheet` in React Native
`StyleSheet` in React Native is a powerful API for defining and managing styles. It allows developers to separate concerns by keeping the layout and styling logic distinct from the component logic. Styles in React Native closely resemble CSS used in web development, though there are some differences, particularly in property names and supported values. For example, instead of `background-color`, React Native uses `backgroundColor`. Using `StyleSheet.create()`, you can bundle your styles in an organized and reusable way, promoting cleaner code and better performance by optimizing style calculations.

Another key advantage of using `StyleSheet` is the performance boost it offers. When you use `StyleSheet.create()`, the styles are processed ahead of time, reducing the computational cost when rendering components. This is crucial for mobile applications, where performance and smooth user experiences are a top priority. Moreover, `StyleSheet` allows you to use Flexbox for layout, ensuring responsive designs that work well across various screen sizes.

#### Explanation 2: Structuring and Organizing Styles
A good practice when using `StyleSheet` is to define styles separately and apply them to your components via the `style` prop. This keeps your code more modular and readable, as all styling logic is in one place. You can also define conditional styles by using JavaScript logic to apply styles dynamically based on certain conditions (e.g., dark mode or user interaction).

The `StyleSheet` can handle complex layouts, animations, and media queries, offering flexibility similar to what you might expect from CSS, but tailored for mobile development. By mastering `StyleSheet`, you gain control over the presentation layer of your React Native applications, making it easy to create visually appealing, responsive, and user-friendly mobile interfaces.

#### Online Resources
1. [React Native StyleSheet Documentation](https://reactnative.dev/docs/stylesheet)
2. [Introduction to Styling in React Native](https://www.freecodecamp.org/news/react-native-styling-guide/)

---

### Example 1: Create a Simple Custom Style

#### Explanation 1: Basic Usage of `StyleSheet`
In this example, we will create a simple `StyleSheet` that defines the layout and look of a `View` and `Text` component. The `StyleSheet.create()` function is used to define the style object, which will be applied to the components via the `style` prop. This method keeps the styling logic centralized and reusable across different components.

#### Explanation 2: Applying the Custom Styles
By practicing this, you will understand how to define and apply styles to different components. This includes customizing properties like `fontSize`, `color`, `padding`, and `backgroundColor`. Applying custom styles allows you to build apps with specific branding or user interface themes that cater to your target audience's design preferences.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.title}>Welcome to My App</Text>
      <Text style={styles.subtitle}>This is a custom styled component</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    backgroundColor: '#f8f8f8',
    alignItems: 'center',
  },
  title: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  subtitle: {
    fontSize: 16,
    color: '#666',
  },
});

export default App;
```

- **Expected Output**: The app displays a centered title with the text "Welcome to My App" in bold, large font, and a smaller subtitle that says "This is a custom styled component." The background color of the `View` is light gray, and the text colors are dark.

#### Additional Resources for Examples
1. [Styling Text Components](https://reactnative.dev/docs/text#styling)
2. [React Native View Component Styling](https://reactnative.dev/docs/view-style-props)

---

### Example 2: Flexbox Layout with Custom Styles

#### Explanation 1: Using Flexbox in `StyleSheet`
In this example, we will use the Flexbox system in React Native to create a responsive layout. The `StyleSheet` will include properties like `flexDirection`, `justifyContent`, and `alignItems` to arrange the `View` components. Flexbox is the primary layout mechanism in React Native, and learning it will give you great control over how elements are positioned and displayed across different screen sizes.

#### Explanation 2: Benefits of Flexbox with `StyleSheet`
Flexbox allows you to create layouts that adapt to various screen sizes without hardcoding pixel values. By defining the styles using Flexbox properties, you ensure that the app looks consistent on both iOS and Android devices. This example will demonstrate how you can use `flexDirection` to arrange items in a row or column and how `justifyContent` and `alignItems` affect their alignment.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <View style={styles.box}>
        <Text style={styles.text}>Box 1</Text>
      </View>
      <View style={styles.box}>
        <Text style={styles.text}>Box 2</Text>
      </View>
      <View style={styles.box}>
        <Text style={styles.text}>Box 3</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-between',
    alignItems: 'center',
    padding: 20,
    backgroundColor: '#f0f0f0',
  },
  box: {
    width: 100,
    height: 100,
    backgroundColor: '#3498db',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: '#fff',
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: The app will display three blue boxes evenly spaced in a horizontal row. Each box contains centered white text saying "Box 1", "Box 2", and "Box 3". The background color of the screen is light gray.

#### Additional Resources for Examples
1. [React Native Flexbox Guide](https://reactnative.dev/docs/flexbox)
2. [Mastering Layout with Flexbox in React Native](https://blog.logrocket.com/mastering-react-native-layout-flexbox/)

---

### Task 8: Create a Custom Style and Apply it to Components

#### Explanation 1: Customizing Styles for a Unique UI
After studying the `StyleSheet`, the next step is to create your custom styles and apply them to different components in your app. By defining styles for components like `View`, `Text`, `Button`, or any other UI elements, you control the look and feel of your app. You can create themes, apply consistent styles across screens, and enhance the overall user experience. Customizing styles is essential to making your app stand out and aligning it with your design guidelines or branding.

Custom styles often include typography (font sizes, weights, colors), layout (margins, paddings, flex properties), and interaction feedback (hover, pressed, or active states). Using `StyleSheet` allows you to organize these styles into reusable blocks, making your codebase more maintainable. It’s important to test these styles on both iOS and Android devices, as there might be subtle differences in how styles are rendered.

#### Explanation 2: Testing and Iterating on Custom Styles
Once you apply the custom styles, it’s important to test how they appear on the actual device using Expo Go. Sometimes the styles might need adjustment based on the screen size, resolution, or platform (iOS vs. Android). Testing and iterating your custom styles will ensure that your UI is responsive, accessible, and visually appealing.

By practicing with different styling configurations and layouts, you’ll develop a better understanding of how to create a cohesive design system that provides a consistent look and feel throughout your application.

for day 2 of studying create-expo-app, tasks listed between
"""
Modify `View` component to experiment with different layouts.<br>
Learn about Flexbox layout.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 9: Modify `View` Component to Experiment with Different Layouts

#### Explanation 1: Understanding the `View` Component
The `View` component in React Native is a fundamental building block for UI layouts. It acts as a container for other components like `Text`, `Image`, `Button`, etc., and is equivalent to a `<div>` in web development. By default, `View` components are rendered as block elements and can be styled using the `style` prop, where you can define properties such as dimensions, background color, margins, padding, and more. One of the key features of the `View` component is its flexibility to handle both simple and complex layouts when combined with the Flexbox layout system.

In React Native, experimenting with the `View` component allows you to test different design structures for your app. For example, by changing its layout properties, you can create different grid systems, column-based designs, or even more complex nested layouts. Practicing with `View` gives you the foundation to organize your app’s content and create user-friendly designs that adapt to various screen sizes and orientations.

#### Explanation 2: Experimenting with Layout Variations
One of the key aspects of working with `View` is exploring how different layout properties (like `flex`, `padding`, and `margin`) affect the appearance of your components. You can experiment by nesting multiple `View` components inside one another and applying various styles, such as `flexDirection`, `justifyContent`, and `alignItems`, to create unique layouts. This experimentation helps you understand how different layout mechanisms impact user interfaces and ensures your app can handle dynamic content and user interactions gracefully.

By modifying the `View` component in various ways, you gain better control over how elements are presented. For example, you can create layouts with fixed headers and footers, sidebars, or responsive designs that adjust based on the available screen size. This practice is crucial when building apps for multiple devices with different screen resolutions.

#### Online Resources
1. [React Native View Documentation](https://reactnative.dev/docs/view)
2. [Mastering Layout in React Native](https://reactnative.dev/docs/flexbox)

---

### Example 1: Nested `View` Components with Different Layouts

#### Explanation 1: Creating Nested Layouts with `View`
In this example, we will create a layout where multiple `View` components are nested within each other. By applying different styles like `padding`, `margin`, and background colors, we can visualize how these components are organized. Nested layouts are commonly used in UI design to group related content or define hierarchical structures for headers, content areas, and footers.

#### Explanation 2: Testing the Layout
Practicing with nested `View` components allows you to understand how parent-child relationships between components affect layout positioning. This is particularly useful for creating complex UIs, such as card-based designs or multi-column layouts. You’ll see how inner components inherit or override the styles of their parent components and how padding and margin influence spacing.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.outerContainer}>
      <View style={styles.innerContainer}>
        <Text style={styles.text}>Inside Nested View</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  outerContainer: {
    padding: 20,
    backgroundColor: '#f0f0f0',
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  innerContainer: {
    backgroundColor: '#4CAF50',
    padding: 30,
    borderRadius: 10,
  },
  text: {
    color: '#fff',
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: The app displays a centered green box inside a light gray background. The green box contains white text that says, "Inside Nested View," and it’s padded and styled with rounded corners.

#### Additional Resources for Examples
1. [React Native Layout Basics](https://reactnative.dev/docs/layout-props)
2. [Using Flexbox with Views](https://reactnative.dev/docs/flexbox)

---

### Example 2: Creating a Multi-Column Layout with `View`

#### Explanation 1: Experimenting with Multiple `View` Components
In this example, you will create a multi-column layout using the `View` component combined with Flexbox. The layout will consist of two `View` components aligned side by side. Using Flexbox properties such as `flexDirection: 'row'` and `justifyContent`, you can position the child components horizontally and space them evenly.

#### Explanation 2: Understanding the Flexbox Impact on Layout
This example demonstrates how Flexbox can be used with `View` to create complex layouts that are responsive and fluid. Practicing with Flexbox helps you understand how to handle various layout needs, including content that needs to be dynamically arranged across multiple devices. It also reinforces how to use alignment and spacing techniques to control the arrangement of components.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <View style={styles.column}>
        <Text style={styles.text}>Column 1</Text>
      </View>
      <View style={styles.column}>
        <Text style={styles.text}>Column 2</Text>
      </View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flexDirection: 'row',
    justifyContent: 'space-between',
    padding: 20,
  },
  column: {
    backgroundColor: '#FFC107',
    padding: 30,
    width: '45%',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: '#fff',
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: Two yellow columns with white text aligned side by side, each taking up 45% of the screen width. The content is spaced evenly using Flexbox properties.

#### Additional Resources for Examples
1. [Creating Responsive Layouts with Flexbox](https://reactnative.dev/docs/flexbox)
2. [Flexbox in React Native: A Beginner's Guide](https://blog.logrocket.com/flexbox-in-react-native/)

---

### Task 10: Learn About Flexbox Layout

#### Explanation 1: Introduction to Flexbox in React Native
Flexbox is the primary layout mechanism used in React Native. It allows you to design complex layouts that can adjust dynamically based on screen size and orientation. The Flexbox model arranges components inside a container in one of two directions—`row` (horizontal) or `column` (vertical). This is controlled using the `flexDirection` property. Other key Flexbox properties include `justifyContent`, which controls how children are aligned along the main axis, and `alignItems`, which manages alignment along the cross-axis.

Flexbox is extremely powerful because it lets you create responsive designs without relying on fixed dimensions. By mastering Flexbox, you can design apps that work seamlessly across devices, from phones to tablets. Flexbox's adaptive nature makes it an ideal choice for modern mobile app development, ensuring that your UI remains flexible and easy to manage.

#### Explanation 2: Practical Application of Flexbox
Using Flexbox, you can control spacing, alignment, and positioning of elements in a predictable way. For example, if you want to distribute components evenly along the screen or center them both vertically and horizontally, Flexbox offers clear, concise ways to achieve this. Flexbox's properties like `flexGrow`, `flexShrink`, and `flexBasis` further allow you to define how components should stretch or contract to fit the available space.

Understanding Flexbox is essential when designing mobile applications, especially if you’re targeting different screen sizes and want a consistent layout. It helps avoid layout issues that can arise from using absolute positioning and gives you a more fluid approach to arranging UI elements.

#### Online Resources
1. [React Native Flexbox Documentation](https://reactnative.dev/docs/flexbox)
2. [Flexbox Layout in React Native](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

---

### Example 1: Vertical Centering with Flexbox

#### Explanation 1: Flexbox Vertical and Horizontal Centering
In this example, we use Flexbox to center a `Text` component both vertically and horizontally. Flexbox properties like `justifyContent: 'center'` and `alignItems: 'center'` ensure that the child component is centered inside the parent `View`.

#### Explanation 2: Understanding Flexbox's Alignment Properties
Practicing with this layout helps you grasp how Flexbox controls the distribution and alignment of items along both axes. This is a common layout pattern in mobile apps, such as splash screens or loader animations.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Centered Text</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#4CAF50',
  },
  text: {
    color: '#fff',
    fontSize: 20,
  },
});

export default App;
```

- **Expected Output**: A screen with a green background and white text "Centered Text" displayed in the middle of the screen.

#### Additional Resources for Examples
1. [How to Center Elements in Flexbox](https://css-tricks.com/centering-css-complete-guide/)
2. [Vertical and Horizontal Flexbox Layout](https://reactnative.dev/docs/flexbox)

---

### Example 2: Space Between Layout with Flexbox

#### Explanation 1: Distributing Components Evenly
In this example, we will use Flexbox to distribute three `View` components evenly across the screen. This is achieved using the `justifyContent: 'space-between'` property, which ensures that there’s equal space between the components, with the first and last items aligned to the edges of the container.

#### Explanation 2: Understanding the Flexbox Space Distribution
This example demonstrates how to create layouts where components need to be spaced consistently without manually setting margins. Flexbox’s space distribution properties are ideal for ensuring that elements are distributed evenly regardless of screen size or content amount.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <View style={styles.box}><Text style={styles.text}>Box 1</Text></View>
      <View style={styles.box}><Text style={styles.text}>Box 2</Text></View>
      <View style={styles.box}><Text style={styles.text}>Box 3</Text></View>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'space-between',
    padding: 20,
  },
  box: {
    height: 100,
    backgroundColor: '#2196F3',
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    color: '#fff',
    fontSize: 16,
  },
});

export default App;
```

- **Expected Output**: Three blue boxes with white text arranged vertically, with equal space between them. The first box is aligned at the top, and the last box is aligned at the bottom of the screen.

#### Additional Resources for Examples
1. [Space Between in Flexbox](https://css-tricks.com/almanac/properties/j/justify-content/)
2. [React Native Layout with Flexbox](https://reactnative.dev/docs/flexbox)

for day 2 of studying create-expo-app, tasks listed between
"""
Implement a Flexbox layout using justifyContent and alignItems.<br>
Add multiple Text components with different styles.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 11: Implement a Flexbox Layout using `justifyContent` and `alignItems`

#### Explanation 1: Understanding `justifyContent` in Flexbox
The `justifyContent` property in React Native's Flexbox layout is used to define how components are aligned along the main axis (horizontal in a `row`, vertical in a `column`). This property allows you to distribute space between children within the parent container. Common values for `justifyContent` include `flex-start`, `center`, `flex-end`, `space-between`, and `space-around`. For example, `justifyContent: 'center'` will center all the child components along the main axis, whereas `justifyContent: 'space-between'` will distribute them evenly with space between each child.

This property is especially useful when you want to create layouts that dynamically adjust based on the screen size. For instance, you can align buttons in a toolbar at the start or end of the screen or create a vertical list of components that are evenly spaced.

#### Explanation 2: Understanding `alignItems` in Flexbox
The `alignItems` property controls how children are aligned along the cross-axis (perpendicular to the main axis). In a `row`, this will affect the vertical alignment of components, and in a `column`, it will affect the horizontal alignment. Common values for `alignItems` include `flex-start`, `center`, and `flex-end`. For example, using `alignItems: 'center'` will center all child components along the cross-axis.

Using `alignItems` together with `justifyContent` gives you full control over the placement of components within a layout. You can center components both horizontally and vertically or distribute them across the screen in complex ways that adapt to different screen sizes and orientations.

#### Online Resources
1. [React Native Flexbox Guide](https://reactnative.dev/docs/flexbox)
2. [CSS Tricks Flexbox Guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

---

### Example 1: Centering Elements Using `justifyContent` and `alignItems`

#### Explanation 1: Creating a Centered Layout
In this example, we use `justifyContent: 'center'` and `alignItems: 'center'` to center all child components both vertically and horizontally within the parent container. This is a common pattern used for loading screens, welcome screens, or when you need to place content in the center of the screen.

#### Explanation 2: Testing Flexbox Centering
This example will help you practice how to align content dynamically using Flexbox. It demonstrates the simplicity of controlling complex layouts with just a few properties. As you test different screen sizes, you will see how the layout adjusts without the need for fixed dimensions.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Centered Text</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f0f0f0',
  },
  text: {
    fontSize: 20,
    color: '#333',
  },
});

export default App;
```

- **Expected Output**: A screen with a gray background and the text "Centered Text" displayed at the exact center of the screen.

#### Additional Resources for Example
1. [Mastering Flexbox Centering](https://css-tricks.com/centering-css-complete-guide/)
2. [Vertical and Horizontal Centering in Flexbox](https://reactnative.dev/docs/flexbox)

---

### Example 2: Distributing Components Using `space-between`

#### Explanation 1: Even Distribution with `space-between`
In this example, we will use `justifyContent: 'space-between'` to distribute three `Text` components evenly along the vertical axis. Each component will be positioned with equal space between them, ensuring a visually balanced layout.

#### Explanation 2: Practicing Space Distribution in Layouts
This example is ideal for creating layouts where you need to space elements evenly, such as buttons in a footer or items in a navigation menu. It shows how Flexbox simplifies the layout process by automating the spacing between elements, eliminating the need for manual margins.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Item 1</Text>
      <Text style={styles.text}>Item 2</Text>
      <Text style={styles.text}>Item 3</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'space-between',
    padding: 20,
  },
  text: {
    fontSize: 18,
    color: '#333',
  },
});

export default App;
```

- **Expected Output**: Three `Text` components ("Item 1", "Item 2", and "Item 3") displayed vertically with equal space between them, filling the entire height of the screen.

#### Additional Resources for Example
1. [Flexbox Space Distribution Guide](https://css-tricks.com/almanac/properties/j/justify-content/)
2. [React Native Layout with Flexbox](https://reactnative.dev/docs/flexbox)

---

### Task 12: Add Multiple `Text` Components with Different Styles

#### Explanation 1: The `Text` Component in React Native
The `Text` component is essential for displaying text in React Native applications. It supports styling, similar to CSS for web development, which allows you to apply different font sizes, colors, alignments, and more. The `Text` component also supports nesting, meaning you can style individual parts of the text differently within the same component. This is useful for highlighting certain words, changing colors, or applying different fonts.

You can customize the appearance of the `Text` component through the `style` prop, where you can define properties such as `fontSize`, `color`, `fontWeight`, `lineHeight`, and more. Multiple `Text` components can be combined to create headers, paragraphs, and other textual elements within your app.

#### Explanation 2: Styling Multiple `Text` Components
Adding multiple `Text` components with different styles allows you to create distinct sections of text in your UI. For example, you can use one `Text` component for a header with larger, bold text, and another for a subheading or paragraph with smaller, lighter text. Each `Text` component can have its own unique style, which makes it easy to design structured text content, such as article layouts or forms with labels.

By practicing with multiple `Text` components, you gain an understanding of how to apply styles effectively and how to organize textual content in your app's UI. This is especially important for building readable and accessible interfaces.

#### Online Resources
1. [React Native Text Component](https://reactnative.dev/docs/text)
2. [Styling Text in React Native](https://www.digitalocean.com/community/tutorials/react-native-text-styling)

---

### Example 1: Applying Different Font Sizes and Colors

#### Explanation 1: Creating Multiple `Text` Components
In this example, we will create three `Text` components, each with a different font size and color. This practice allows you to apply varying styles to different text elements, such as creating headings, subheadings, and body text.

#### Explanation 2: Experimenting with Text Styles
This example demonstrates how to style multiple `Text` components with different properties, such as `fontSize`, `color`, and `fontWeight`. Testing this will help you visualize how different font styles affect the overall design and readability of your app.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.header}>Header Text</Text>
      <Text style={styles.subHeader}>Subheader Text</Text>
      <Text style={styles.body}>This is body text with a different style.</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  header: {
    fontSize: 24,
    fontWeight: 'bold',
    color: '#333',
  },
  subHeader: {
    fontSize: 18,
    color: '#666',
  },
  body: {
    fontSize: 14,
    color: '#999',
  },
});

export default App;
```

- **Expected Output**: The screen displays three `Text` components: a large bold "Header Text", a medium "Subheader Text", and a smaller gray "body text".

#### Additional Resources for Example
1. [Text Styling in React Native](https://reactnative.dev/docs/text)
2. [Using Fonts and Typography in React Native](https://blog.logrocket.com/styling-text-react-native/)

---

### Example 2: Nested `Text` Components with Different Styles

#### Explanation 1: Styling Nested Text
In this example, we will nest two `Text` components within a parent `Text` component. Each child `Text` component will have its own style, allowing for mixed styling within the same block of text. This is useful for creating rich text layouts, such as articles or descriptions with bold or highlighted sections.

#### Explanation 2: Testing Nested Text Styles
This example is perfect for practicing how to apply multiple styles within a single `Text` component. By nesting `Text` components, you can create complex text layouts, similar to how HTML allows for styled spans within a paragraph.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>
        This is an
        <Text style={styles.bold}>important</Text>
        message with nested styles.
      </Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
  },
  text: {
    fontSize: 16,
    color: '#333',
  },
  bold: {
    fontWeight: 'bold',
    color: '#e74c3c',
  },
});

export default App;
```

- **Expected Output**: A block of text saying "This is an important message with nested styles", where the word "important" is bold and red.

#### Additional Resources for Example
1. [React Native Nested Text](https://reactnative.dev/docs/text)
2. [Advanced Text Styling](https://blog.logrocket.com/advanced-styling-react-native-text/)

for day 2 of studying create-expo-app, tasks listed between
"""
Review documentation for handling state with `useState`.<br>
Implement a simple state in your component (e.g., toggle button).<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 13: Review Documentation for Handling State with `useState`

#### Explanation 1: Understanding `useState` in React Native
`useState` is a fundamental React Hook that allows you to add state to your functional components. In React Native, state is used to keep track of dynamic data that can change during the lifecycle of a component. When a state variable is updated, the component re-renders to reflect the new state. The `useState` Hook returns an array with two values: the current state and a function to update the state. This makes managing dynamic content, such as user input or button toggles, straightforward.

Using state is crucial in mobile app development because it lets your app respond to user actions in real-time. For instance, when a user interacts with a button, text input, or other UI elements, you can update the state to show different content, change styles, or navigate to another screen based on those interactions.

#### Explanation 2: How `useState` Works in Practice
The first argument passed to `useState` is the initial state, which can be of any data type (e.g., string, number, object). You can modify this state using the state setter function, often by passing a new value to it. When the state updates, React Native re-renders the component with the new state value. For example, if you're implementing a toggle button, you can use `useState` to store a boolean value that switches between `true` and `false` when the button is pressed.

By learning how to handle state using `useState`, you will gain the ability to create dynamic, interactive user interfaces that change based on user input or other events.

#### Online Resources
1. [React Native State Management with `useState`](https://reactnative.dev/docs/state)
2. [Using React Hooks in React Native](https://reactjs.org/docs/hooks-state.html)

---

### Example 1: Implementing a Simple Counter with `useState`

#### Explanation 1: Simple Counter App
In this example, we will create a simple counter that increments and decrements when buttons are pressed. The `useState` Hook will store the counter value and update it when the buttons are clicked. The current value of the counter will be displayed in the app.

#### Explanation 2: Practice Incrementing and Decrementing State
This example demonstrates a practical way to handle state in your app. Each button press changes the state of the counter, and the component re-renders to display the new value. This practice will help you understand how state works with user interactions and component re-renders.

```javascript
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [count, setCount] = useState(0);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
      <Button title="Decrement" onPress={() => setCount(count - 1)} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 24,
    marginBottom: 20,
  },
});

export default App;
```

- **Expected Output**: A screen displaying the current counter value and two buttons. Pressing "Increment" increases the counter, and pressing "Decrement" decreases it.

#### Additional Resources for Example
1. [React Native Button Documentation](https://reactnative.dev/docs/button)
2. [React Native State Example](https://blog.logrocket.com/how-to-manage-state-in-react-native/)

---

### Example 2: Toggling Button Text with `useState`

#### Explanation 1: Toggle Button Example
In this example, we will implement a button that toggles between "On" and "Off" each time it is pressed. We use `useState` to track whether the button is in the "On" or "Off" state. The text displayed on the button changes based on the state value.

#### Explanation 2: Handling Button Toggles with State
This example helps you practice managing boolean state and conditional rendering in React Native. Each time the button is pressed, the state updates, and the text on the button switches between two values. This is a common pattern in apps that involve toggling settings or visibility.

```javascript
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [isOn, setIsOn] = useState(false);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>The switch is {isOn ? 'On' : 'Off'}</Text>
      <Button title={isOn ? 'Turn Off' : 'Turn On'} onPress={() => setIsOn(!isOn)} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 24,
    marginBottom: 20,
  },
});

export default App;
```

- **Expected Output**: A screen with a text saying "The switch is Off" and a button labeled "Turn On". Pressing the button changes the text to "The switch is On" and the button label to "Turn Off".

#### Additional Resources for Example
1. [React Native Conditional Rendering](https://reactjs.org/docs/conditional-rendering.html)
2. [React Native Hooks](https://reactnative.dev/docs/hooks-intro)

---

### Task 14: Implement a Simple State in Your Component (e.g., Toggle Button)

#### Explanation 1: Managing State with a Toggle Button
Managing state in React Native often involves user interactions, such as toggling a setting or updating UI elements based on a condition. In this task, you'll practice using `useState` to create a toggle button, where the state alternates between two values (`true` or `false`). This is a practical example of using state in a component that responds to user input.

The toggle button is a perfect example of a component that can store its state internally. When the user taps the button, the state changes, and the UI reflects this change by updating the label or appearance of the button. This basic pattern forms the foundation for more complex interactions in your app.

#### Explanation 2: Importance of Component Re-renders
When working with `useState`, each time the state is updated, the component re-renders to reflect the new state. This automatic re-rendering is key to creating dynamic UIs that change in response to user interactions. In the case of a toggle button, the state change triggers a re-render that updates the button's label and other associated UI elements. Understanding this concept will help you build more interactive, real-time apps with responsive feedback to user actions.

#### Online Resources
1. [React Hooks: State and Effects](https://reactjs.org/docs/hooks-state.html)
2. [React Native Button and Interaction Handling](https://reactnative.dev/docs/handling-touches)

---

### Example 1: Toggle Dark Mode with `useState`

#### Explanation 1: Implementing Dark Mode Toggle
In this example, you will implement a button that toggles between light and dark mode. The state will control the background and text colors, switching them based on whether dark mode is enabled or not. This is a common feature in many modern apps, giving users the ability to toggle between themes.

#### Explanation 2: State-Driven UI Changes
This example helps you practice making state-driven changes to your app's layout and appearance. Every time the user toggles dark mode, the state updates, and the component re-renders with a new color scheme. This is useful for understanding how UI changes based on dynamic data.

```javascript
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [darkMode, setDarkMode] = useState(false);

  return (
    <View style={[styles.container, darkMode && styles.dark]}>
      <Text style={[styles.text, darkMode && styles.darkText]}>Dark Mode is {darkMode ? 'On' : 'Off'}</Text>
      <Button title="Toggle Dark Mode" onPress={() => setDarkMode(!darkMode)} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#fff',
  },
  dark: {
    backgroundColor: '#333',
  },
  text: {
    fontSize: 18,
    color: '#000',
  },
  darkText: {
    color: '#fff',
  },
});

export default App;
```

- **Expected Output**: A screen with text "Dark Mode is Off" and a button labeled "Toggle Dark Mode". Pressing the button switches the text to "Dark Mode is On", and the background and text colors change accordingly.

#### Additional Resources for Example
1. [Managing Themes in React Native](https://reactnative.dev/docs/color-schemes)
2. [Building a Dark Mode Toggle](https://blog.expo.dev/adding-dark-mode-to-your-expo-react-native-app-bcff1c19fa5d)

---

### Example 2: Toggling Visibility of Components

#### Explanation 1: Showing and Hiding Elements with State
In this example, we will

 create a button that toggles the visibility of a text element on the screen. The button press will update the state, and the text will appear or disappear accordingly. This is useful for learning how to manage conditional rendering with `useState`.

#### Explanation 2: Practical Use of Conditional Rendering
Toggling visibility is a common task in user interfaces, especially for elements like modals, menus, or additional details. This example demonstrates how to use state to control when a component is visible, giving you more control over the UI based on user actions.

```javascript
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [isVisible, setIsVisible] = useState(false);

  return (
    <View style={styles.container}>
      {isVisible && <Text style={styles.text}>Now you see me!</Text>}
      <Button title={isVisible ? 'Hide' : 'Show'} onPress={() => setIsVisible(!isVisible)} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 24,
    marginBottom: 20,
  },
});

export default App;
```

- **Expected Output**: A screen with a button labeled "Show". Pressing the button displays a text saying "Now you see me!" and changes the button label to "Hide". Pressing the button again hides the text.

#### Additional Resources for Example
1. [React Native Conditional Rendering](https://reactnative.dev/docs/conditional-rendering)
2. [React Native Managing Component Visibility](https://blog.expo.dev/react-native-visibility-using-hooks-803e5b64d1a3)

for day 2 of studying create-expo-app, tasks listed between
"""
Add a basic `TextInput` component.<br>
Handle text input and display input dynamically on the screen.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 15: Add a Basic `TextInput` Component

#### Explanation 1: What is `TextInput` in React Native?
In React Native, the `TextInput` component allows users to input text, much like a text field in HTML. It is an essential UI element for building forms, search bars, or any other input-based functionality in mobile apps. The `TextInput` component can be styled and customized to suit your application's needs, making it flexible for various use cases. It also provides several event handlers, like `onChangeText`, that allow you to capture and manipulate the user input in real-time.

Using `TextInput` is crucial for collecting information from users, whether it be a name, email address, or any other text-based data. This makes it a fundamental tool in mobile app development when creating interactive and user-friendly applications.

#### Explanation 2: How to Use `TextInput`
The `TextInput` component is controlled by state in functional components. This means that you can bind the input value to a state variable using the `useState` Hook. As the user types, the text can be dynamically updated and displayed. To ensure the best user experience, you can also add props like `placeholder`, `keyboardType`, and `secureTextEntry` for customizing the input field based on the data you expect from the user (e.g., password, email, or numeric input).

By mastering the use of `TextInput`, you'll be able to create dynamic forms, chat interfaces, search bars, and other input-dependent features that respond to user actions.

#### Online Resources
1. [React Native `TextInput` Documentation](https://reactnative.dev/docs/textinput)
2. [React Native Text Input Guide](https://www.digitalocean.com/community/tutorials/react-native-textinput)

---

### Example 1: Simple `TextInput` with Placeholder

#### Explanation 1: Implementing a Basic `TextInput`
In this example, we will add a basic `TextInput` component that displays a placeholder when no text is entered. The text entered by the user will be stored in state, and we will display the value in real-time below the input field. This example is a great way to get familiar with handling user input in React Native.

#### Explanation 2: Real-time Input Handling
As the user types into the `TextInput`, the `onChangeText` event captures the input and updates the state. This state is then displayed dynamically on the screen, demonstrating how to work with real-time text input and rendering. This is a fundamental skill in developing forms and handling dynamic data in mobile applications.

```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, StyleSheet } from 'react-native';

const App = () => {
  const [input, setInput] = useState('');

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Type something..."
        onChangeText={(text) => setInput(text)}
        value={input}
      />
      <Text style={styles.output}>You typed: {input}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  input: {
    height: 40,
    borderColor: 'gray',
    borderWidth: 1,
    paddingHorizontal: 10,
    width: '100%',
    marginBottom: 20,
  },
  output: {
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: A text input field with the placeholder "Type something...". When text is entered, the typed text is displayed dynamically below the input field as "You typed: [text]".

#### Additional Resources for Example
1. [React Native Handling Text Input](https://reactnative.dev/docs/handling-text-input)
2. [TextInput and State in React Native](https://www.smashingmagazine.com/2020/06/complete-guide-building-layouts-react-native/)

---

### Example 2: `TextInput` with Validation

#### Explanation 1: Validating User Input
In this example, we will create a `TextInput` component that checks whether the input is a valid email address. The user will type into the field, and if the input is not a valid email format, an error message will be displayed. This example demonstrates how to validate user input using regular expressions and conditionally render error messages.

#### Explanation 2: Managing Input Validations
This example allows you to practice capturing and validating user input in real-time, which is crucial for forms and data entry. Handling validation in the input process ensures that only correct information is processed in your app, improving the user experience by preventing invalid data submission.

```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, StyleSheet } from 'react-native';

const App = () => {
  const [email, setEmail] = useState('');
  const [errorMessage, setErrorMessage] = useState('');

  const validateEmail = (input) => {
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    if (emailRegex.test(input)) {
      setErrorMessage('');
    } else {
      setErrorMessage('Invalid email format');
    }
    setEmail(input);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter your email"
        onChangeText={(text) => validateEmail(text)}
        value={email}
      />
      {errorMessage ? <Text style={styles.error}>{errorMessage}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  input: {
    height: 40,
    borderColor: 'gray',
    borderWidth: 1,
    paddingHorizontal: 10,
    width: '100%',
    marginBottom: 10,
  },
  error: {
    color: 'red',
  },
});

export default App;
```

- **Expected Output**: A text input field with the placeholder "Enter your email". If the input is not in a valid email format, an error message "Invalid email format" will appear below the input field.

#### Additional Resources for Example
1. [React Native Input Validation](https://medium.com/react-native-training/validating-forms-in-react-native-7a6de9c6f0f3)
2. [React Native TextInput and Form Validation](https://aboutreact.com/react-native-textinput/)

---

### Task 16: Handle Text Input and Display Input Dynamically on the Screen

#### Explanation 1: Real-time Text Display
Handling text input dynamically allows users to see their input reflected in the app immediately. This interaction improves user experience and is often seen in chat applications, search bars, and forms. With React Native's `TextInput` and `useState`, you can capture text as the user types and display it on the screen without reloading or refreshing the app.

In React Native, real-time handling of input is achieved through the `onChangeText` prop of the `TextInput` component. As the text changes, you store the value in state and then render it using the `Text` component. This creates a live feedback loop between the user's input and the display.

#### Explanation 2: Handling Input for Dynamic Interfaces
Real-time handling of text input is an essential concept in many mobile applications. Whether you're building a form, a search bar, or even a messaging app, capturing and rendering user input instantly ensures smooth interactions. You can apply this knowledge to features like live search results, dynamic form validation, and message composition in a chat app.

By mastering this task, you'll gain practical skills in managing dynamic input, which is critical for developing responsive and interactive mobile apps.

#### Online Resources
1. [Handling Input in React Native](https://reactnative.dev/docs/handling-text-input)
2. [React Native Forms and Text Input](https://www.smashingmagazine.com/2020/06/complete-guide-building-layouts-react-native/)

---

### Example 1: Real-time Search Bar

#### Explanation 1: Implementing a Dynamic Search Bar
This example demonstrates how to implement a search bar that dynamically updates as the user types. The input is stored in state and displayed below the input field in real-time. This functionality is commonly used in search features that provide instant feedback as users type their queries.

#### Explanation 2: Practicing Input-Driven UIs
This example helps you practice capturing text input and rendering it immediately. Real-time search bars are essential for providing a smooth user experience when filtering data, making this an important feature in many modern apps.

```javascript
import React, { useState } from 'react';
import { View, TextInput, Text, StyleSheet } from 'react-native';

const App = () => {
  const [searchText, setSearchText] = useState('');

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Search here..."
        onChangeText={(text) => setSearchText(text)}
        value={searchText}
      />
      <Text style={styles.output}>Search Term: {searchText}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  input: {
    height

: 40,
    borderColor: 'gray',
    borderWidth: 1,
    paddingHorizontal: 10,
    width: '100%',
    marginBottom: 20,
  },
  output: {
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: A text input field with the placeholder "Search here...". As the user types, the entered text is displayed below the input field.

#### Additional Resources for Example
1. [Real-time Text Input Handling](https://reactnative.dev/docs/textinput)
2. [Dynamic Search Bars in React Native](https://medium.com/@pallavi.trivedi/creating-a-simple-search-bar-in-react-native-1ef77d6713e8)

---

### Example 2: Simple Form Input

#### Explanation 1: Implementing a Dynamic Form Input
In this example, we will create a form field where users can enter their name, and the app will dynamically display the name as they type. The input will be stored in state, and the value will be updated in real-time, providing instant feedback on the screen.

#### Explanation 2: Practicing Dynamic Forms
Handling user input dynamically in forms is a key skill in mobile app development. This example demonstrates the basic functionality of form fields, giving you the ability to handle user input efficiently and display it in real-time. This is especially useful for creating interactive forms or input-driven UI elements.

```javascript
import React, { useState } from 'react';
import { View, TextInput, Text, StyleSheet } from 'react-native';

const App = () => {
  const [name, setName] = useState('');

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter your name"
        onChangeText={(text) => setName(text)}
        value={name}
      />
      <Text style={styles.output}>Hello, {name}!</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  input: {
    height: 40,
    borderColor: 'gray',
    borderWidth: 1,
    paddingHorizontal: 10,
    width: '100%',
    marginBottom: 20,
  },
  output: {
    fontSize: 18,
  },
});

export default App;
```

- **Expected Output**: A text input field with the placeholder "Enter your name". As the user types, the entered name is displayed dynamically as "Hello, [name]!" below the input field.

#### Additional Resources for Example
1. [Dynamic Form Handling in React Native](https://reactnative.dev/docs/forms)
2. [Building Forms in React Native](https://blog.logrocket.com/complete-guide-to-forms-in-react-native/)

for day 2 of studying create-expo-app, tasks listed between
"""
Experiment with fonts and typography in Expo.<br>
Save all changes and test in Expo Go.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 17: Experiment with Fonts and Typography in Expo

#### Explanation 1: Fonts and Typography in React Native
Typography is an essential part of creating aesthetically pleasing and readable applications. In React Native (and Expo), you can customize fonts, font sizes, font weights, and other text-related properties to improve the user experience. Expo makes it easy to use custom fonts by providing utilities like `useFonts` from the `expo-font` package. This allows developers to load and apply custom fonts seamlessly in the application.

Font customization enhances the branding and design of the app. Using different font families, weights, and sizes can significantly affect how the text is perceived, making it either professional or casual. Learning how to apply and load custom fonts is key to building visually appealing interfaces.

#### Explanation 2: Loading and Applying Custom Fonts in Expo
In Expo, you can load custom fonts via the `useFonts` hook. Once the fonts are loaded, they can be applied to `Text` components by using the `style` prop. Expo supports several popular font formats such as `.ttf` and `.otf`. When building apps, especially those requiring specific branding or style guidelines, loading and applying custom fonts is crucial for ensuring consistency in the app's look and feel.

By experimenting with different fonts and typography settings, you'll learn how to control the text's appearance in your app and create a unique style for your application.

#### Online Resources
1. [Expo Font Documentation](https://docs.expo.dev/guides/using-custom-fonts/)
2. [React Native Typography and Font Styling](https://reactnative.dev/docs/text-style-props)

---

### Example 1: Loading and Applying Custom Fonts

#### Explanation 1: Loading a Custom Font
This example demonstrates how to load a custom font in Expo using the `useFonts` hook. In this case, we will load the "Roboto" font from Google Fonts. After loading the font, we will apply it to a `Text` component. This is a great way to practice integrating custom fonts into your project.

#### Explanation 2: Practicing Custom Font Integration
Using custom fonts adds personality and branding to your app, making it stand out. This example shows how to manage font loading and ensure that the app waits for the font to load before rendering the UI. If the font is not loaded, a fallback can be displayed.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useFonts } from 'expo-font';
import AppLoading from 'expo-app-loading';

const App = () => {
  const [fontsLoaded] = useFonts({
    'Roboto-Regular': require('./assets/fonts/Roboto-Regular.ttf'),
  });

  if (!fontsLoaded) {
    return <AppLoading />;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.customFont}>Hello, this is Roboto!</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  customFont: {
    fontSize: 24,
    fontFamily: 'Roboto-Regular',
  },
});

export default App;
```

- **Expected Output**: A screen that displays "Hello, this is Roboto!" in the Roboto font. If the font takes time to load, a loading indicator will be shown temporarily.

#### Additional Resources for Example
1. [Expo Font Hook: useFonts](https://docs.expo.dev/versions/latest/sdk/font/)
2. [Custom Fonts in Expo](https://docs.expo.dev/guides/using-custom-fonts/)

---

### Example 2: Applying Multiple Fonts and Font Weights

#### Explanation 1: Using Different Font Styles and Weights
In this example, we will load multiple font weights of the "Roboto" font (Regular and Bold) and apply them to different `Text` components. This practice helps demonstrate how you can use font weights to emphasize certain sections of text (e.g., making headings bold while keeping body text regular).

#### Explanation 2: Experimenting with Typography Variations
Typography variations, such as different weights and styles, are useful when you need to differentiate between headings, subheadings, and body text. This example lets you practice applying multiple font families or weights, giving your text hierarchy and improving readability.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useFonts } from 'expo-font';
import AppLoading from 'expo-app-loading';

const App = () => {
  const [fontsLoaded] = useFonts({
    'Roboto-Regular': require('./assets/fonts/Roboto-Regular.ttf'),
    'Roboto-Bold': require('./assets/fonts/Roboto-Bold.ttf'),
  });

  if (!fontsLoaded) {
    return <AppLoading />;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.header}>This is Roboto Bold</Text>
      <Text style={styles.body}>This is Roboto Regular</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  header: {
    fontSize: 24,
    fontFamily: 'Roboto-Bold',
    marginBottom: 20,
  },
  body: {
    fontSize: 18,
    fontFamily: 'Roboto-Regular',
  },
});

export default App;
```

- **Expected Output**: A screen displaying two texts, one with "Roboto Bold" and the other with "Roboto Regular", clearly showing the difference in font weights.

#### Additional Resources for Example
1. [Applying Different Font Weights in Expo](https://docs.expo.dev/guides/using-custom-fonts/)
2. [Typography and Text in React Native](https://reactnative.dev/docs/text)

---

### Task 18: Save All Changes and Test in Expo Go

#### Explanation 1: Testing Apps in Expo Go
Expo Go is a free mobile app that allows you to run your React Native projects on a real device without building a native package. This is especially useful during development because it allows you to see how your app functions on actual hardware. Once your changes are saved in the development environment, you can open Expo Go on your mobile device, scan the QR code (or use a development server link), and see your app live.

Testing with Expo Go is an important step in cross-platform development, as it allows you to identify platform-specific issues, such as layout adjustments or performance concerns, that may not be evident in an emulator or web preview.

#### Explanation 2: Iterative Testing and Debugging in Expo Go
Testing your app regularly ensures that changes are working as expected. Expo Go facilitates real-time updates, allowing developers to see changes immediately after saving their code. This workflow accelerates development and allows you to catch bugs early. It’s essential to test frequently on both Android and iOS devices to ensure the app functions well on all platforms.

#### Online Resources
1. [Expo Go Documentation](https://docs.expo.dev/get-started/installation/#expo-go-app)
2. [Testing in Expo](https://docs.expo.dev/workflow/development-mode/)

---

### Example 1: Testing Basic Layout Changes

#### Explanation 1: Save and Test Layout Modifications
In this example, you’ll make minor layout changes (such as adding padding or margin) and test them in Expo Go. By saving your changes and testing on a real device, you can see how small design changes affect the overall layout.

#### Explanation 2: Observing Changes on Real Devices
Testing on actual devices gives you a more accurate perspective of how your app will behave in the real world. Certain layout adjustments may appear differently on smaller or larger screens, so using Expo Go ensures that you’re designing responsively.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

const App = () => {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Hello from Expo Go!</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  text: {
    fontSize: 24,
    marginBottom: 20,
  },
});

export default App;
```

- **Expected Output**: Open the Expo Go app, scan the QR code, and you’ll see "Hello from Expo Go!" on the screen with padding applied around the content.

#### Additional Resources for Example
1. [Testing Expo Projects in Expo Go](https://docs.expo.dev/workflow/run-on-device/)
2. [Live Testing in Expo Go](https://www.freecodecamp.org/news/test-react-native-app-on-real-device-in-expo-go/)

---

### Example 2: Real-time Font Testing in Expo Go

#### Explanation 1: Testing Font Loading in Real-time
Here, you’ll modify your custom font and text styling and test it in real-time using Expo Go. This practice lets you observe how different fonts and sizes render on a real device, ensuring that typography looks good across various screen sizes.

#### Explanation 2: Debugging Font Rendering
Expo Go allows you to quickly identify any issues with font loading or styling. This is particularly useful when working with custom fonts, as you can ensure that fonts load correctly and appear as expected on both iOS and Android devices.

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { useFonts } from 'expo-font';
import AppLoading from 'expo-app-loading';

const App = () =>

 {
  const [fontsLoaded] = useFonts({
    'OpenSans-Bold': require('./assets/fonts/OpenSans-Bold.ttf'),
  });

  if (!fontsLoaded) {
    return <AppLoading />;
  }

  return (
    <View style={styles.container}>
      <Text style={styles.text}>OpenSans Bold in Expo Go!</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 24,
    fontFamily: 'OpenSans-Bold',
  },
});

export default App;
```

- **Expected Output**: Text using the "OpenSans-Bold" font will be displayed when running the app in Expo Go, allowing you to verify the font’s appearance on a real device.

#### Additional Resources for Example
1. [Handling Fonts in Expo](https://docs.expo.dev/guides/using-custom-fonts/)
2. [Expo Go for Testing Fonts](https://docs.expo.dev/workflow/development-mode/)