for day 43, tasks listed between
"""
Study GraphQL subscriptions for real-time data.
Implement GraphQL subscriptions with Apollo Client.
Study advanced database integration.
Implement SQLite for complex data storage.
Study advanced data synchronization strategies.
Implement data sync with Redux Offline.
Study backend-as-a-service (BaaS) solutions.
Integrate Supabase for backend services.
Study advanced state management patterns.
Implement Redux Toolkit for state management.
Study advanced routing patterns.
Implement nested and conditional navigation.
Study context API patterns.
Implement context API for global state.
Study advanced form handling techniques.
Implement multi-step forms with Formik.
Study advanced UI/UX design principles.
Implement responsive and adaptive UI.
Study internationalization best practices.
Implement localization with react-i18next.
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Task 1: Study GraphQL subscriptions for real-time data

**Explanation:**
GraphQL subscriptions allow clients to receive real-time updates from the server. Unlike traditional HTTP requests, which require the client to repeatedly poll the server for updates, subscriptions enable the server to push updates to the client whenever new data is available. This is particularly useful for applications that need to reflect live changes, such as chat applications, live sports scores, or collaborative editing tools.

Subscriptions are built on top of WebSockets, a protocol that allows for persistent, two-way communication between the client and the server. In a GraphQL setup, the client subscribes to specific events, and the server sends updates to the client whenever those events occur. This real-time capability makes GraphQL subscriptions a powerful tool for building highly interactive and responsive applications.

**Resources:**
- [GraphQL Subscriptions Documentation](https://graphql.org/blog/subscriptions-in-graphql-and-relay/)
- [Apollo Client Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)

### Example 1: Basic GraphQL Subscription Setup

**Explanation:**
This example demonstrates how to set up a basic GraphQL subscription using Apollo Server and Apollo Client. The server sends updates to the client whenever a new message is added.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub } = require('apollo-server');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';

const typeDefs = gql`
  type Message {
    id: ID!
    content: String!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!): Message!
  }

  type Subscription {
    messageAdded: Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content }) => {
      const message = { id: Date.now().toString(), content };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: () => pubSub.asyncIterator([MESSAGE_ADDED]),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription {
    messageAdded {
      id
      content
    }
  }
`;

const Messages = () => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <Messages />
  </ApolloProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time as they are added to the server.
```

**Resources:**
- [Apollo Server Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)
- [Apollo Client Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)

### Example 2: GraphQL Subscription with Authentication

**Explanation:**
This example demonstrates how to set up a GraphQL subscription with authentication. It uses JWT (JSON Web Token) to authenticate clients before they can subscribe to updates.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub } = require('apollo-server');
const jwt = require('jsonwebtoken');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';
const SECRET_KEY = 'your-secret-key';

const typeDefs = gql`
  type Message {
    id: ID!
    content: String!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!): Message!
  }

  type Subscription {
    messageAdded: Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content }) => {
      const message = { id: Date.now().toString(), content };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: (_, __, { token }) => {
        if (!token) {
          throw new Error('Authentication required');
        }
        const decoded = jwt.verify(token, SECRET_KEY);
        if (!decoded) {
          throw new Error('Invalid token');
        }
        return pubSub.asyncIterator([MESSAGE_ADDED]);
      },
    },
  },
};

const context = ({ req, connection }) => {
  if (connection) {
    return { token: connection.context.token };
  }
  const token = req.headers.authorization || '';
  return { token };
};

const server = new ApolloServer({ typeDefs, resolvers, context });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';
import { setContext } from '@apollo/client/link/context';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
    connectionParams: {
      token: 'your-jwt-token',
    },
  },
});

const authLink = setContext((_, { headers }) => {
  return {
    headers: {
      ...headers,
      authorization: 'your-jwt-token',
    },
  };
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  authLink.concat(httpLink)
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription {
    messageAdded {
      id
      content
    }
  }
`;

const Messages = () => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <Messages />
  </ApolloProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time as they are added to the server, with clients authenticated using JWT.
```

**Resources:**
- [Apollo Server Authentication](https://www.apollographql.com/docs/apollo-server/security/authentication/)
- [JWT Authentication](https://jwt.io/introduction/)

### Example 3: GraphQL Subscription with Filtered Data

**Explanation:**
This example demonstrates how to set up a GraphQL subscription that filters data before sending it to the client. The server only sends updates to the client if the new data meets specific criteria.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub, withFilter } = require('apollo-server');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';

const typeDefs = gql`
  type Message {
    id: ID!
   

 content: String!
    userId: ID!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!, userId: ID!): Message!
  }

  type Subscription {
    messageAdded(userId: ID!): Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content, userId }) => {
      const message = { id: Date.now().toString(), content, userId };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: withFilter(
        () => pubSub.asyncIterator([MESSAGE_ADDED]),
        (payload, variables) => {
          return payload.messageAdded.userId === variables.userId;
        }
      ),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription($userId: ID!) {
    messageAdded(userId: $userId) {
      id
      content
    }
  }
`;

const Messages = ({ userId }) => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION, {
    variables: { userId },
  });
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => {
  const userId = 'user-123'; // Example user ID
  return (
    <ApolloProvider client={client}>
      <Messages userId={userId} />
    </ApolloProvider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time that are specific to a given user ID.
```

**Resources:**
- [GraphQL Subscriptions with Filters](https://www.apollographql.com/docs/graphql-tools/resolvers/#customizing-subscription-behavior)
- [Using withFilter in Apollo Server](https://www.apollographql.com/docs/apollo-server/data/subscriptions/#subscription-filters)

---

### Task 2: Implement GraphQL subscriptions with Apollo Client

**Explanation:**
GraphQL subscriptions enable real-time updates to be pushed from the server to the client, offering a way to keep the client data in sync without needing to repeatedly poll the server. Apollo Client makes it straightforward to implement these subscriptions, leveraging WebSockets for a persistent connection that allows data to flow in both directions. This is particularly beneficial for applications that require real-time features such as live notifications, chat applications, or collaborative tools.

By setting up GraphQL subscriptions with Apollo Client, developers can create highly interactive and responsive user interfaces. Subscriptions ensure that any changes on the server are immediately reflected on the client, improving the user experience by keeping the data current. The Apollo Client provides convenient hooks like `useSubscription` to simplify the implementation of subscriptions in React components.

**Resources:**
- [Apollo Client Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)
- [GraphQL Subscriptions with Apollo](https://www.apollographql.com/blog/graphql/subscriptions-in-graphql-and-apollo-41c0059b334/)

### Example 1: Basic Subscription Setup with Apollo Client

**Explanation:**
This example demonstrates a basic setup for GraphQL subscriptions using Apollo Client. It includes setting up Apollo Server to publish updates and Apollo Client to subscribe to these updates. The example focuses on real-time messaging where new messages are sent to all subscribed clients.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub } = require('apollo-server');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';

const typeDefs = gql`
  type Message {
    id: ID!
    content: String!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!): Message!
  }

  type Subscription {
    messageAdded: Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content }) => {
      const message = { id: Date.now().toString(), content };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: () => pubSub.asyncIterator([MESSAGE_ADDED]),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription {
    messageAdded {
      id
      content
    }
  }
`;

const Messages = () => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <Messages />
  </ApolloProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time as they are added to the server.
```

**Resources:**
- [Apollo Server Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)
- [Apollo Client Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)

### Example 2: Subscription with Error Handling and Retry Logic

**Explanation:**
This example extends the basic subscription setup by adding error handling and retry logic. It demonstrates how to manage errors during the subscription process and automatically retry the subscription if it fails.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub } = require('apollo-server');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';

const typeDefs = gql`
  type Message {
    id: ID!
    content: String!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!): Message!
  }

  type Subscription {
    messageAdded: Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content }) => {
      const message = { id: Date.now().toString(), content };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: () => pubSub.asyncIterator([MESSAGE_ADDED]),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';
import { onError } from '@apollo/client/link/error';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
    connectionCallback: (error) => {
      if (error) {
        console.error('WebSocket connection error:', error);
      }
    },
  },
});

const errorLink = onError(({ networkError, graphQLErrors }) => {
  if (graphQLErrors) {
    graphQLErrors.forEach(({ message, locations, path }) =>
      console.log(`[GraphQL error]: Message: ${message}, Location: ${locations}, Path: ${path}`)
    );
  }
  if (networkError) {
    console.log(`[Network error]: ${networkError}`);
  }
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  errorLink.concat(httpLink)
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription {
    messageAdded {
      id
      content
    }
  }
`;

const Messages = () => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <Messages />
  </ApolloProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time with error handling and retry logic for the WebSocket connection.
```

**Resources:**
- [Handling Errors in Apollo Client](https://www.apollographql.com/docs/react/data/error-handling/)
- [GraphQL Subscriptions with Error Handling](https://www.apollographql.com/docs/react/data/subscriptions/)

### Example 3: Subscription with User-Specific Data

**Explanation:**
This example demonstrates how to set up a subscription that only sends updates to the client if the new data is relevant to the specific user. This is useful for applications where users should only receive updates pertinent to their context.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub, withFilter } = require('apollo-server');

const pubSub = new PubSub();
const MESSAGE_ADDED = 'MESSAGE_ADDED';

const typeDefs = gql`
 

 type Message {
    id: ID!
    content: String!
    userId: ID!
  }

  type Query {
    messages: [Message!]!
  }

  type Mutation {
    addMessage(content: String!, userId: ID!): Message!
  }

  type Subscription {
    messageAdded(userId: ID!): Message!
  }
`;

const resolvers = {
  Query: {
    messages: () => [],
  },
  Mutation: {
    addMessage: (_, { content, userId }) => {
      const message = { id: Date.now().toString(), content, userId };
      pubSub.publish(MESSAGE_ADDED, { messageAdded: message });
      return message;
    },
  },
  Subscription: {
    messageAdded: {
      subscribe: withFilter(
        () => pubSub.asyncIterator([MESSAGE_ADDED]),
        (payload, variables) => {
          return payload.messageAdded.userId === variables.userId;
        }
      ),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const MESSAGE_SUBSCRIPTION = gql`
  subscription($userId: ID!) {
    messageAdded(userId: $userId) {
      id
      content
    }
  }
`;

const Messages = ({ userId }) => {
  const { data, error } = useSubscription(MESSAGE_SUBSCRIPTION, {
    variables: { userId },
  });
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    if (data) {
      setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
    }
  }, [data]);

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {messages.map((msg) => (
        <p key={msg.id}>{msg.content}</p>
      ))}
    </div>
  );
};

const App = () => {
  const userId = 'user-123'; // Example user ID
  return (
    <ApolloProvider client={client}>
      <Messages userId={userId} />
    </ApolloProvider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app displays new messages in real-time that are specific to a given user ID.
```

**Resources:**
- [GraphQL Subscriptions with Filters](https://www.apollographql.com/docs/graphql-tools/resolvers/#customizing-subscription-behavior)
- [Using withFilter in Apollo Server](https://www.apollographql.com/docs/apollo-server/data/subscriptions/#subscription-filters)

---

### Task 3: Study advanced database integration

**Explanation:**
Advanced database integration involves the techniques and strategies used to connect, manage, and optimize interactions between applications and databases. This includes using Object-Relational Mapping (ORM) tools, optimizing query performance, handling complex relationships, and ensuring data consistency and integrity. ORM tools like Sequelize for Node.js and TypeORM provide a way to interact with databases using object-oriented programming, which abstracts SQL queries into more manageable code structures. These tools simplify database operations, making code more maintainable and scalable.

In addition to ORM tools, advanced database integration also includes understanding and implementing caching strategies to improve performance, using database migrations to manage schema changes, and ensuring efficient transaction management. It is also important to handle database scaling to accommodate growing data and user demands. By mastering these techniques, developers can create robust, scalable, and efficient database interactions that enhance the overall performance and reliability of their applications.

**Resources:**
- [Advanced Database Integration Techniques](https://medium.com/@thgaskell/advanced-database-techniques-database-partitioning-sharding-and-orm-b8b68c35b0b4)
- [Database Optimization Strategies](https://www.datadoghq.com/blog/database-optimization/)

### Example 1: Using Sequelize for Advanced Database Operations

**Explanation:**
This example demonstrates how to use Sequelize, an ORM for Node.js, to perform advanced database operations such as defining models, associations, and querying complex relationships. Sequelize simplifies database interactions by abstracting SQL queries into object-oriented code.

**Example Code:**
```js
// models/user.js
const { Model, DataTypes } = require('sequelize');
const sequelize = require('../config/database');

class User extends Model {}
User.init({
  username: DataTypes.STRING,
  email: DataTypes.STRING,
}, { sequelize, modelName: 'user' });

module.exports = User;

// models/post.js
const { Model, DataTypes } = require('sequelize');
const sequelize = require('../config/database');
const User = require('./user');

class Post extends Model {}
Post.init({
  title: DataTypes.STRING,
  content: DataTypes.TEXT,
}, { sequelize, modelName: 'post' });

Post.belongsTo(User);
User.hasMany(Post);

module.exports = Post;

// index.js
const express = require('express');
const sequelize = require('./config/database');
const User = require('./models/user');
const Post = require('./models/post');

const app = express();
app.use(express.json());

app.post('/users', async (req, res) => {
  const user = await User.create(req.body);
  res.json(user);
});

app.post('/posts', async (req, res) => {
  const post = await Post.create(req.body);
  res.json(post);
});

app.get('/users/:id/posts', async (req, res) => {
  const posts = await Post.findAll({ where: { userId: req.params.id } });
  res.json(posts);
});

sequelize.sync().then(() => {
  app.listen(3000, () => {
    console.log('Server is running on http://localhost:3000');
  });
});
```
**Expected Output:**
```sh
# The server allows creating users and posts, and fetching posts by user ID, demonstrating advanced Sequelize usage.
```

**Resources:**
- [Sequelize Documentation](https://sequelize.org/master/)
- [Getting Started with Sequelize](https://sequelize.org/master/manual/getting-started.html)

### Example 2: Database Migrations with TypeORM

**Explanation:**
This example demonstrates how to use TypeORM, an ORM for TypeScript and JavaScript, to manage database migrations. Migrations are essential for versioning database schemas and applying changes consistently across different environments.

**Example Code:**
```ts
// data-source.ts
import { DataSource } from 'typeorm';
import { User } from './entity/User';
import { Post } from './entity/Post';

export const AppDataSource = new DataSource({
  type: 'sqlite',
  database: 'database.sqlite',
  synchronize: true,
  logging: false,
  entities: [User, Post],
  migrations: ['src/migration/**/*.ts'],
  subscribers: [],
});

// migration/1634343998654-CreateUser.ts
import { MigrationInterface, QueryRunner, Table } from 'typeorm';

export class CreateUser1634343998654 implements MigrationInterface {
  public async up(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.createTable(new Table({
      name: 'user',
      columns: [
        {
          name: 'id',
          type: 'int',
          isPrimary: true,
          isGenerated: true,
          generationStrategy: 'increment',
        },
        {
          name: 'username',
          type: 'varchar',
        },
        {
          name: 'email',
          type: 'varchar',
        },
      ],
    }), true);
  }

  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.dropTable('user');
  }
}

// entity/User.ts
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  username: string;

  @Column()
  email: string;
}

// entity/Post.ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from 'typeorm';
import { User } from './User';

@Entity()
export class Post {
  @PrimaryGeneratedColumn()
  id: number;

  @Column()
  title: string;

  @Column()
  content: string;

  @ManyToOne(() => User, user => user.posts)
  user: User;
}

// index.ts
import 'reflect-metadata';
import { AppDataSource } from './data-source';
import express from 'express';
import { User } from './entity/User';
import { Post } from './entity/Post';

const app = express();
app.use(express.json());

app.post('/users', async (req, res) => {
  const user = AppDataSource.manager.create(User, req.body);
  await AppDataSource.manager.save(user);
  res.json(user);
});

app.post('/posts', async (req, res) => {
  const post = AppDataSource.manager.create(Post, req.body);
  await AppDataSource.manager.save(post);
  res.json(post);
});

app.get('/users/:id/posts', async (req, res) => {
  const posts = await AppDataSource.manager.find(Post, {
    where: { user: { id: req.params.id } },
  });
  res.json(posts);
});

AppDataSource.initialize().then(async () => {
  app.listen(3000, () => {
    console.log('Server is running on http://localhost:3000');
  });
});
```
**Expected Output:**
```sh
# The server allows creating users and posts, managing schema changes with TypeORM migrations.
```

**Resources:**
- [TypeORM Documentation](https://typeorm.io/)
- [TypeORM Migrations](https://typeorm.io/#/migrations)

### Example 3: Optimizing Database Queries with Prisma

**Explanation:**
This example demonstrates how to use Prisma, a modern ORM, to optimize database queries. Prisma provides a powerful query engine and a data model that allows developers to write efficient and performant queries.

**Example Code:**
```js
// schema.prisma
datasource db {
  provider = "sqlite"
  url      = "file:./dev.db"
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id       Int      @id @default(autoincrement())
  username String
  email    String
  posts    Post[]
}

model Post {
  id      Int    @id @default(autoincrement())
  title   String
  content String
  userId  Int
  user    User   @relation(fields: [userId], references: [id])
}

// index.js
const { PrismaClient } = require('@prisma/client');
const express = require('express');
const prisma = new PrismaClient();

const app = express();
app.use(express.json());

app.post('/users', async (req, res) => {
  const user = await prisma.user.create({
    data: req.body,
  });
  res.json(user);
});

app.post('/posts', async (req, res) => {
  const post = await prisma.post.create({
    data: req.body,
  });
  res.json(post);
});

app.get('/users/:id/posts', async (req, res) => {
  const posts = await prisma.post.findMany({
    where: { userId: parseInt(req.params.id) },
  });
  res.json(posts);
});

app.listen(3000, () => {
  console.log('Server is running on http://localhost:3000');
});
```
**Expected Output:**
```sh
# The server allows creating users and posts, demonstrating efficient query handling with Prisma.
```

**Resources:**
- [Prisma Documentation](https://www.prisma.io/docs/)
- [Getting Started with Prisma](https://www.prisma.io/docs/getting-started)

---

### Task 4: Implement SQLite for complex data storage

**Explanation:**
SQLite is a lightweight, disk-based database that doesn't require a separate server process, making it an ideal choice for embedded databases on mobile and desktop applications. It supports most of the SQL standards and can handle complex data storage requirements, including handling multiple tables, relationships, transactions, and indexing. SQLite is highly reliable, self-contained, and supports a full-featured SQL database engine.

For complex data storage, SQLite allows developers to define schemas that represent intricate data relationships. You can perform joins, create indices for performance optimization, and use transactions to ensure data integrity. Understanding how to effectively use SQLite in an application can significantly improve data management and retrieval efficiency.

**Resources:**
- [SQLite Documentation](https://www.sqlite.org/docs.html)
- [SQLite Tutorial](https://www.sqlitetutorial.net/)

### Example 1: Creating a Complex Schema with SQLite

**Explanation:**
This example demonstrates how to create a complex schema in SQLite involving multiple tables with relationships. It shows how to define tables, set up foreign keys, and ensure referential integrity.

**Example Code:**
```sql
-- Create tables with relationships
CREATE TABLE users (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  username TEXT NOT NULL,
  email TEXT NOT NULL UNIQUE
);

CREATE TABLE posts (
  id INTEGER PRIMARY KEY AUTOINCREMENT,
  title TEXT NOT NULL,
  content TEXT NOT NULL,
  user_id INTEGER,
  FOREIGN KEY (user_id) REFERENCES users (id)
);
```
**Expected Output:**
```sh
# Two tables 'users' and 'posts' are created with a foreign key relationship.
```

**Resources:**
- [SQLite Foreign Key Support](https://www.sqlite.org/foreignkeys.html)
- [Creating Tables in SQLite](https://www.sqlitetutorial.net/sqlite-create-table/)

### Example 2: Performing Complex Queries in SQLite

**Explanation:**
This example demonstrates how to perform complex queries in SQLite, including joins and subqueries. It illustrates how to retrieve related data from multiple tables efficiently.

**Example Code:**
```sql
-- Insert sample data
INSERT INTO users (username, email) VALUES ('john_doe', 'john@example.com');
INSERT INTO posts (title, content, user_id) VALUES ('Post 1', 'Content 1', 1), ('Post 2', 'Content 2', 1);

-- Query to fetch user data along with their posts
SELECT users.username, users.email, posts.title, posts.content
FROM users
JOIN posts ON users.id = posts.user_id;
```
**Expected Output:**
```sh
# The query returns the username, email, title, and content of posts for each user.
```

**Resources:**
- [SQLite Joins](https://www.sqlitetutorial.net/sqlite-inner-join/)
- [Advanced SQLite Queries](https://www.sqlite.org/lang_select.html)

### Example 3: Transactions and Indexing in SQLite

**Explanation:**
This example demonstrates how to use transactions and indexing in SQLite. Transactions ensure data integrity by grouping multiple operations into a single unit of work. Indexing improves query performance by allowing the database to quickly locate rows.

**Example Code:**
```sql
-- Create index for the posts table
CREATE INDEX idx_posts_user_id ON posts (user_id);

-- Using transactions
BEGIN TRANSACTION;

INSERT INTO users (username, email) VALUES ('jane_doe', 'jane@example.com');
INSERT INTO posts (title, content, user_id) VALUES ('Post 3', 'Content 3', 2);

COMMIT;
```
**Expected Output:**
```sh
# The index on 'posts.user_id' is created, and data is inserted using a transaction.
```

**Resources:**
- [SQLite Transactions](https://www.sqlite.org/lang_transaction.html)
- [SQLite Indexes](https://www.sqlitetutorial.net/sqlite-index/)

### Code Example in a React Native Application

**Explanation:**
This example demonstrates how to use SQLite in a React Native application using the `react-native-sqlite-storage` library to handle complex data storage and retrieval.

**Example Code:**
```js
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, FlatList, TextInput } from 'react-native';
import SQLite from 'react-native-sqlite-storage';

SQLite.enablePromise(true);

const db = SQLite.openDatabase({ name: 'example.db', location: 'default' });

const App = () => {
  const [users, setUsers] = useState([]);
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');

  useEffect(() => {
    db.transaction(tx => {
      tx.executeSql(
        'CREATE TABLE IF NOT EXISTS users (id INTEGER PRIMARY KEY AUTOINCREMENT, username TEXT NOT NULL, email TEXT NOT NULL UNIQUE)',
        [],
        () => { console.log('Users table created'); },
        error => { console.log('Error creating users table: ', error); }
      );
    });
  }, []);

  const addUser = () => {
    db.transaction(tx => {
      tx.executeSql(
        'INSERT INTO users (username, email) VALUES (?, ?)',
        [username, email],
        (tx, results) => {
          if (results.rowsAffected > 0) {
            alert('User added successfully');
            setUsername('');
            setEmail('');
            fetchUsers();
          }
        },
        error => { console.log('Error adding user: ', error); }
      );
    });
  };

  const fetchUsers = () => {
    db.transaction(tx => {
      tx.executeSql(
        'SELECT * FROM users',
        [],
        (tx, results) => {
          let usersArray = [];
          for (let i = 0; i < results.rows.length; i++) {
            usersArray.push(results.rows.item(i));
          }
          setUsers(usersArray);
        },
        error => { console.log('Error fetching users: ', error); }
      );
    });
  };

  useEffect(() => {
    fetchUsers();
  }, []);

  return (
    <View>
      <TextInput
        value={username}
        onChangeText={setUsername}
        placeholder="Username"
      />
      <TextInput
        value={email}
        onChangeText={setEmail}
        placeholder="Email"
      />
      <Button title="Add User" onPress={addUser} />
      <FlatList
        data={users}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View>
            <Text>{item.username} - {item.email}</Text>
          </View>
        )}
      />
    </View>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows adding users and displaying the list of users stored in SQLite.
```

**Resources:**
- [react-native-sqlite-storage Documentation](https://github.com/andpor/react-native-sqlite-storage)
- [Using SQLite in React Native](https://medium.com/@balramchavan/using-sqlite-in-react-native-2cbf3b7f2435)

---

### Task 5: Study advanced data synchronization strategies

**Explanation:**
Advanced data synchronization strategies are essential for ensuring that data is consistent across different devices and platforms. This is particularly important for applications that need to work offline and then synchronize with a central server when a connection is available. Data synchronization can involve complex scenarios, including conflict resolution, partial synchronization, and real-time updates. Common strategies include using delta sync (synchronizing only the changes), conflict-free replicated data types (CRDTs), and utilizing synchronization libraries like Firebase or Apollo Client with GraphQL.

Effective data synchronization ensures that users have a seamless experience regardless of network conditions. This involves handling synchronization conflicts gracefully, ensuring data integrity, and optimizing for performance to reduce the load on both the client and server. By understanding and implementing advanced synchronization strategies, developers can build robust applications that provide a consistent user experience across different environments.

**Resources:**
- [Data Synchronization Patterns and Practices](https://docs.microsoft.com/en-us/azure/architecture/patterns/data-synchronization)
- [Offline Data Sync in Mobile Apps](https://www.mongodb.com/blog/post/offline-data-sync-mobile-apps-using-realm)

### Example 1: Delta Sync with Firebase

**Explanation:**
This example demonstrates how to implement delta sync using Firebase. Delta sync involves synchronizing only the changes (deltas) rather than the entire dataset, which improves performance and reduces bandwidth usage.

**Example Code:**
```js
// Initialize Firebase
import firebase from 'firebase/app';
import 'firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

const db = firebase.firestore();

// Add data to Firestore
const addData = async (data) => {
  await db.collection('items').add(data);
};

// Listen for changes (delta sync)
const listenForChanges = () => {
  db.collection('items').onSnapshot((snapshot) => {
    snapshot.docChanges().forEach((change) => {
      if (change.type === 'added') {
        console.log('New item: ', change.doc.data());
      }
      if (change.type === 'modified') {
        console.log('Modified item: ', change.doc.data());
      }
      if (change.type === 'removed') {
        console.log('Removed item: ', change.doc.data());
      }
    });
  });
};

// Usage
addData({ name: 'Item 1', value: 100 });
listenForChanges();
```
**Expected Output:**
```sh
# The app listens for changes in the Firestore collection and logs new, modified, and removed items.
```

**Resources:**
- [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)
- [Firebase Firestore Realtime Updates](https://firebase.google.com/docs/firestore/query-data/listen)

### Example 2: Conflict Resolution with Apollo Client

**Explanation:**
This example demonstrates how to handle conflict resolution in a GraphQL application using Apollo Client. Conflict resolution ensures that data conflicts are managed gracefully, typically by merging changes or prompting the user to resolve conflicts.

**Example Code:**
```js
// server.js (Apollo Server)
const { ApolloServer, gql, PubSub } = require('apollo-server');

const pubSub = new PubSub();
const ITEM_UPDATED = 'ITEM_UPDATED';

const typeDefs = gql`
  type Item {
    id: ID!
    name: String!
    value: Int!
  }

  type Query {
    items: [Item!]!
  }

  type Mutation {
    updateItem(id: ID!, name: String, value: Int): Item!
  }

  type Subscription {
    itemUpdated: Item!
  }
`;

const items = [
  { id: '1', name: 'Item 1', value: 100 },
];

const resolvers = {
  Query: {
    items: () => items,
  },
  Mutation: {
    updateItem: (_, { id, name, value }) => {
      const item = items.find(item => item.id === id);
      if (item) {
        item.name = name !== undefined ? name : item.name;
        item.value = value !== undefined ? value : item.value;
        pubSub.publish(ITEM_UPDATED, { itemUpdated: item });
        return item;
      }
      throw new Error('Item not found');
    },
  },
  Subscription: {
    itemUpdated: {
      subscribe: () => pubSub.asyncIterator([ITEM_UPDATED]),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`Server ready at ${url}`);
});
```
```js
// client.js (Apollo Client)
import React, { useEffect, useState } from 'react';
import { ApolloProvider, useMutation, useSubscription, gql } from '@apollo/client';
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: 'ws://localhost:4000/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const ITEM_UPDATED_SUBSCRIPTION = gql`
  subscription {
    itemUpdated {
      id
      name
      value
    }
  }
`;

const UPDATE_ITEM_MUTATION = gql`
  mutation UpdateItem($id: ID!, $name: String, $value: Int) {
    updateItem(id: $id, name: $name, value: $value) {
      id
      name
      value
    }
  }
`;

const Items = () => {
  const { data, error } = useSubscription(ITEM_UPDATED_SUBSCRIPTION);
  const [updateItem] = useMutation(UPDATE_ITEM_MUTATION);
  const [items, setItems] = useState([]);

  useEffect(() => {
    if (data) {
      setItems(prevItems =>
        prevItems.map(item =>
          item.id === data.itemUpdated.id ? data.itemUpdated : item
        )
      );
    }
  }, [data]);

  const handleUpdate = (id, name, value) => {
    updateItem({ variables: { id, name, value } });
  };

  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      {items.map(item => (
        <div key={item.id}>
          <p>{item.name} - {item.value}</p>
          <button onClick={() => handleUpdate(item.id, 'Updated Name', item.value + 10)}>Update</button>
        </div>
      ))}
    </div>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <Items />
  </ApolloProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app displays items and allows updating them, handling real-time updates and conflict resolution.
```

**Resources:**
- [Apollo Client Documentation](https://www.apollographql.com/docs/react/)
- [GraphQL Conflict Resolution](https://www.apollographql.com/docs/react/caching/cache-interaction/)

### Example 3: Real-Time Data Sync with PouchDB and CouchDB

**Explanation:**
This example demonstrates how to use PouchDB for local data storage and CouchDB for remote synchronization. PouchDB is an open-source JavaScript database that syncs with CouchDB, providing offline-first capabilities and real-time data synchronization.

**Example Code:**
```js
// client.js (PouchDB)
import PouchDB from 'pouchdb-browser';

const localDB = new PouchDB('localdb');
const remoteDB = new PouchDB('http://localhost:5984/remotedb');

// Add data to local PouchDB
const addData = async (doc) => {
  await localDB.put(doc);
};

// Sync local PouchDB with remote CouchDB
const syncDB = () => {
  localDB.sync(remoteDB, {
    live: true,
    retry: true,
  }).on('change', (info) => {
    console.log('Sync change:', info);
  }).on('paused', (err) => {
    console.log('Sync paused:', err);
  }).on('active', () => {
    console.log('Sync resumed');
  }).on('error', (err) => {
    console.error('Sync error:', err);
  });
};

// Fetch all data from local PouchDB
const fetchData = async () => {
  const allDocs = await localDB.allDocs({ include_docs: true });
  return allDocs.rows.map(row => row.doc);
};

// Usage
addData({ _id: '1', name: 'Item 1', value: 100 });
syncDB();
fetchData().then(data => console.log(data));
```
**Expected Output:**
```sh
# The local PouchDB syncs with remote CouchDB, ensuring data consistency and real-time updates.
```

**Resources:**
- [PouchDB Documentation](https://p

ouchdb.com/)
- [CouchDB Documentation](https://docs.couchdb.org/en/stable/)

---

### Task 6: Implement data sync with Redux Offline

**Explanation:**
Redux Offline is a middleware library that integrates seamlessly with Redux to provide offline-first capabilities and data synchronization for web and mobile applications. It allows applications to function correctly even when there is no network connection by queueing actions that require network access and replaying them once the connection is restored. This ensures a smooth user experience and data consistency across different states of connectivity.

The library handles various aspects of offline support, including action queueing, network detection, optimistic updates, and conflict resolution. By using Redux Offline, developers can build resilient applications that provide a seamless user experience irrespective of network conditions. Understanding how to implement and configure Redux Offline is crucial for creating robust applications with offline-first capabilities.

**Resources:**
- [Redux Offline Documentation](https://redux-offline.github.io/redux-offline/)
- [Offline-First Apps with Redux Offline](https://medium.com/@eloy.eps/using-redux-offline-to-handle-your-offline-first-application-state-c2154f0a148b)

### Example 1: Basic Setup of Redux Offline

**Explanation:**
This example demonstrates how to set up Redux Offline in a React application. It includes configuring the store with the Redux Offline middleware and handling basic offline capabilities.

**Example Code:**
```js
// store.js
import { createStore, applyMiddleware } from 'redux';
import { offline } from 'redux-offline';
import offlineConfig from 'redux-offline/lib/defaults';
import rootReducer from './reducers';

const store = createStore(
  rootReducer,
  applyMiddleware(offline(offlineConfig))
);

export default store;

// rootReducer.js
import { combineReducers } from 'redux';
import exampleReducer from './exampleReducer';

const rootReducer = combineReducers({
  example: exampleReducer,
});

export default rootReducer;

// exampleReducer.js
const initialState = {
  data: [],
};

const exampleReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        data: [...state.data, action.payload],
      };
    default:
      return state;
  }
};

export default exampleReducer;

// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';

const App = () => {
  const [input, setInput] = useState('');
  const dispatch = useDispatch();
  const data = useSelector((state) => state.example.data);

  const addItem = () => {
    dispatch({ type: 'ADD_ITEM', payload: input });
    setInput('');
  };

  return (
    <Provider store={store}>
      <div>
        <input value={input} onChange={(e) => setInput(e.target.value)} />
        <button onClick={addItem}>Add Item</button>
        <ul>
          {data.map((item, index) => (
            <li key={index}>{item}</li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows adding items to the state, which are managed by Redux Offline for offline capabilities.
```

**Resources:**
- [Redux Offline Setup](https://redux-offline.github.io/redux-offline/docs/getting-started)
- [React Redux Integration](https://react-redux.js.org/introduction/quick-start)

### Example 2: Handling Offline Actions with Redux Offline

**Explanation:**
This example demonstrates how to handle offline actions using Redux Offline. It shows how to configure actions to be queued and replayed once the network connection is restored, ensuring data synchronization.

**Example Code:**
```js
// actions.js
export const addItem = (item) => ({
  type: 'ADD_ITEM',
  payload: item,
  meta: {
    offline: {
      effect: { url: '/addItem', method: 'POST', body: JSON.stringify({ item }) },
      commit: { type: 'ADD_ITEM_COMMIT', meta: { item } },
      rollback: { type: 'ADD_ITEM_ROLLBACK', meta: { item } },
    },
  },
});

// store.js
import { createStore, applyMiddleware } from 'redux';
import { offline } from 'redux-offline';
import offlineConfig from 'redux-offline/lib/defaults';
import rootReducer from './reducers';

const store = createStore(
  rootReducer,
  applyMiddleware(offline(offlineConfig))
);

export default store;

// exampleReducer.js
const initialState = {
  data: [],
};

const exampleReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        data: [...state.data, action.payload],
      };
    case 'ADD_ITEM_COMMIT':
      return {
        ...state,
        data: state.data.map((item) =>
          item === action.meta.item ? { ...item, committed: true } : item
        ),
      };
    case 'ADD_ITEM_ROLLBACK':
      return {
        ...state,
        data: state.data.filter((item) => item !== action.meta.item),
      };
    default:
      return state;
  }
};

export default exampleReducer;

// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';
import { addItem } from './actions';

const App = () => {
  const [input, setInput] = useState('');
  const dispatch = useDispatch();
  const data = useSelector((state) => state.example.data);

  const handleAddItem = () => {
    dispatch(addItem(input));
    setInput('');
  };

  return (
    <Provider store={store}>
      <div>
        <input value={input} onChange={(e) => setInput(e.target.value)} />
        <button onClick={handleAddItem}>Add Item</button>
        <ul>
          {data.map((item, index) => (
            <li key={index}>{item}</li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app queues actions when offline and syncs them when the connection is restored, demonstrating offline-first behavior.
```

**Resources:**
- [Handling Offline Actions with Redux Offline](https://redux-offline.github.io/redux-offline/docs/basics/offline-actions/)
- [Redux Offline Configuration](https://redux-offline.github.io/redux-offline/docs/config/)

### Example 3: Conflict Resolution with Redux Offline

**Explanation:**
This example demonstrates how to handle conflict resolution with Redux Offline. It shows how to manage conflicts when synchronizing data, ensuring that the state remains consistent.

**Example Code:**
```js
// actions.js
export const updateItem = (item) => ({
  type: 'UPDATE_ITEM',
  payload: item,
  meta: {
    offline: {
      effect: { url: '/updateItem', method: 'POST', body: JSON.stringify({ item }) },
      commit: { type: 'UPDATE_ITEM_COMMIT', meta: { item } },
      rollback: { type: 'UPDATE_ITEM_ROLLBACK', meta: { item } },
    },
  },
});

// store.js
import { createStore, applyMiddleware } from 'redux';
import { offline } from 'redux-offline';
import offlineConfig from 'redux-offline/lib/defaults';
import rootReducer from './reducers';

const store = createStore(
  rootReducer,
  applyMiddleware(offline(offlineConfig))
);

export default store;

// exampleReducer.js
const initialState = {
  data: [],
};

const exampleReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'UPDATE_ITEM':
      return {
        ...state,
        data: state.data.map((item) =>
          item.id === action.payload.id ? action.payload : item
        ),
      };
    case 'UPDATE_ITEM_COMMIT':
      return {
        ...state,
        data: state.data.map((item) =>
          item.id === action.meta.item.id ? { ...item, committed: true } : item
        ),
      };
    case 'UPDATE_ITEM_ROLLBACK':
      return {
        ...state,
        data: state.data.map((item) =>
          item.id === action.meta.item.id ? { ...item, rollback: true } : item
        ),
      };
    default:
      return state;
  }
};

export default exampleReducer;

// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';
import { updateItem } from './actions';

const App = () => {
  const [input, setInput] = useState('');
  const dispatch = useDispatch();
  const data = useSelector((state) => state.example.data);

  const handleUpdateItem = (id, newValue) => {
    dispatch(updateItem({ id, value: newValue }));
  };

  return (
    <Provider store={store}>
      <div>
        <input value={input} onChange={(e) => setInput(e.target.value)} />
        <ul>
          {data.map((item, index) => (
            <li key={index}>
              {item.value}
              <button onClick={() => handleUpdateItem(item.id, input)}>Update</button>
            </li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app updates items with conflict resolution handling, ensuring consistent state synchronization.
```

**Resources:**
- [Conflict Resolution with Redux Offline](https://redux-offline.github.io/redux-offline/docs/basics/handling-conflicts/)
- [Optimistic Updates with Redux Offline](https://redux-offline.github.io/redux-offline/docs/optimistic-updates/)

---

### Task 7: Study backend-as-a-service (BaaS) solutions

**Explanation:**
Backend-as-a-Service (BaaS) solutions provide ready-made backend functionalities that developers can integrate into their applications without needing to set up and manage their own server infrastructure. These services typically include databases, authentication, file storage, and real-time data synchronization. By using BaaS, developers can focus on building front-end features while leveraging scalable and secure backend services. Popular BaaS providers include Firebase, AWS Amplify, and Supabase.

BaaS solutions offer significant advantages, such as reducing development time, providing built-in security, and handling scalability automatically. They also come with comprehensive SDKs and APIs that make integration straightforward. However, it's important to understand the limitations and costs associated with these services to ensure they align with your application's requirements and budget.

**Resources:**
- [What is Backend-as-a-Service (BaaS)?](https://www.techopedia.com/definition/29959/backend-as-a-service-baas)
- [Choosing the Best BaaS for Your Project](https://www.simform.com/blog/backend-as-a-service/)

### Example 1: Using Firebase as a BaaS

**Explanation:**
Firebase is a comprehensive BaaS solution provided by Google. It includes a real-time NoSQL database (Firestore), authentication, cloud functions, and hosting services. This example demonstrates how to set up a Firebase project and use its Firestore database and authentication services.

**Example Code:**
```js
// firebase.js
import firebase from 'firebase/app';
import 'firebase/firestore';
import 'firebase/auth';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

const db = firebase.firestore();
const auth = firebase.auth();

export { db, auth };

// App.js
import React, { useState, useEffect } from 'react';
import { db, auth } from './firebase';

const App = () => {
  const [user, setUser] = useState(null);
  const [data, setData] = useState([]);
  const [input, setInput] = useState('');

  useEffect(() => {
    const unsubscribe = auth.onAuthStateChanged((user) => {
      setUser(user);
    });
    return unsubscribe;
  }, []);

  useEffect(() => {
    const unsubscribe = db.collection('items').onSnapshot((snapshot) => {
      setData(snapshot.docs.map((doc) => ({ id: doc.id, ...doc.data() })));
    });
    return unsubscribe;
  }, []);

  const handleAddItem = () => {
    db.collection('items').add({ name: input });
    setInput('');
  };

  const handleLogin = () => {
    auth.signInAnonymously();
  };

  const handleLogout = () => {
    auth.signOut();
  };

  return (
    <div>
      {user ? (
        <>
          <button onClick={handleLogout}>Logout</button>
          <input value={input} onChange={(e) => setInput(e.target.value)} />
          <button onClick={handleAddItem}>Add Item</button>
          <ul>
            {data.map((item) => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        </>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows users to log in anonymously, add items to Firestore, and display the list of items in real-time.
```

**Resources:**
- [Firebase Documentation](https://firebase.google.com/docs)
- [Firebase Firestore](https://firebase.google.com/docs/firestore)

### Example 2: Using AWS Amplify as a BaaS

**Explanation:**
AWS Amplify is a BaaS solution provided by Amazon Web Services. It offers services like authentication, storage, APIs, and analytics. This example demonstrates how to set up an Amplify project and use its authentication and API services.

**Example Code:**
```js
// amplify.js
import Amplify, { Auth, API, graphqlOperation } from 'aws-amplify';
import awsconfig from './aws-exports';
import { createItem } from './graphql/mutations';
import { listItems } from './graphql/queries';

Amplify.configure(awsconfig);

// App.js
import React, { useState, useEffect } from 'react';
import Amplify, { Auth, API, graphqlOperation } from 'aws-amplify';
import awsconfig from './aws-exports';
import { createItem } from './graphql/mutations';
import { listItems } from './graphql/queries';

Amplify.configure(awsconfig);

const App = () => {
  const [user, setUser] = useState(null);
  const [data, setData] = useState([]);
  const [input, setInput] = useState('');

  useEffect(() => {
    const fetchUser = async () => {
      try {
        const user = await Auth.currentAuthenticatedUser();
        setUser(user);
      } catch {
        setUser(null);
      }
    };
    fetchUser();
  }, []);

  useEffect(() => {
    const fetchData = async () => {
      const result = await API.graphql(graphqlOperation(listItems));
      setData(result.data.listItems.items);
    };
    fetchData();
  }, []);

  const handleAddItem = async () => {
    await API.graphql(graphqlOperation(createItem, { input: { name: input } }));
    setInput('');
  };

  const handleLogin = () => {
    Auth.federatedSignIn();
  };

  const handleLogout = () => {
    Auth.signOut();
  };

  return (
    <div>
      {user ? (
        <>
          <button onClick={handleLogout}>Logout</button>
          <input value={input} onChange={(e) => setInput(e.target.value)} />
          <button onClick={handleAddItem}>Add Item</button>
          <ul>
            {data.map((item) => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        </>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows users to log in, add items to AWS AppSync, and display the list of items in real-time.
```

**Resources:**
- [AWS Amplify Documentation](https://docs.amplify.aws/)
- [AWS Amplify Auth](https://docs.amplify.aws/lib/auth/getting-started/q/platform/js/)

### Example 3: Using Supabase as a BaaS

**Explanation:**
Supabase is an open-source BaaS that provides instant APIs, real-time subscriptions, authentication, and storage. This example demonstrates how to set up a Supabase project and use its database and authentication services.

**Example Code:**
```js
// supabase.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://xyzcompany.supabase.co';
const supabaseKey = 'public-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;

// App.js
import React, { useState, useEffect } from 'react';
import supabase from './supabase';

const App = () => {
  const [user, setUser] = useState(null);
  const [data, setData] = useState([]);
  const [input, setInput] = useState('');

  useEffect(() => {
    const fetchUser = async () => {
      const user = supabase.auth.user();
      setUser(user);
    };
    fetchUser();
  }, []);

  useEffect(() => {
    const fetchData = async () => {
      const { data } = await supabase.from('items').select('*');
      setData(data);
    };
    fetchData();
  }, []);

  const handleAddItem = async () => {
    await supabase.from('items').insert([{ name: input }]);
    setInput('');
  };

  const handleLogin = async () => {
    const { user } = await supabase.auth.signIn({ provider: 'google' });
    setUser(user);
  };

  const handleLogout = async () => {
    await supabase.auth.signOut();
    setUser(null);
  };

  return (
    <div>
      {user ? (
        <>
          <button onClick={handleLogout}>Logout</button>
          <input value={input} onChange={(e) => setInput(e.target.value)} />
          <button onClick={handleAddItem}>Add Item</button>
          <ul>
            {data.map((item) => (
              <li key={item.id}>{item.name}</li>
            ))}
          </ul>
        </>
      ) : (
        <button onClick={handleLogin}>Login</button>
      )}
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows users to log in via Google, add items to Supabase, and display the list of items in real-time.
```

**Resources:**
- [Supabase Documentation](https://supabase.io/docs)
- [Supabase Auth](https://supabase.io/docs/guides/auth)

---

### Task 8: Integrate Supabase for backend services

**Explanation:**
Supabase is an open-source Backend-as-a-Service (BaaS) that offers real-time databases, authentication, storage, and edge functions. Built on PostgreSQL, it provides a comprehensive solution for modern web and mobile applications, making it easy to manage databases and integrate authentication. Supabase also supports real-time data updates, making it ideal for applications that require live data synchronization.

Integrating Supabase into your application involves setting up a Supabase project, connecting to the Supabase client, and using its APIs to manage data and authentication. Supabase's SDKs and extensive documentation simplify this process, allowing developers to quickly build and deploy backend services without managing server infrastructure. This makes it an excellent choice for developers looking to streamline their backend development process.

**Resources:**
- [Supabase Documentation](https://supabase.io/docs)
- [Getting Started with Supabase](https://supabase.io/docs/guides/getting-started)

### Example 1: Setting Up Supabase and Basic CRUD Operations

**Explanation:**
This example demonstrates how to set up a Supabase project and perform basic Create, Read, Update, and Delete (CRUD) operations. It involves initializing the Supabase client and using it to interact with a Supabase database.

**Example Code:**
```js
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://xyzcompany.supabase.co';
const supabaseKey = 'public-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;

// App.js
import React, { useState, useEffect } from 'react';
import supabase from './supabaseClient';

const App = () => {
  const [items, setItems] = useState([]);
  const [name, setName] = useState('');

  useEffect(() => {
    fetchItems();
  }, []);

  const fetchItems = async () => {
    const { data } = await supabase.from('items').select('*');
    setItems(data);
  };

  const addItem = async () => {
    await supabase.from('items').insert([{ name }]);
    setName('');
    fetchItems();
  };

  const updateItem = async (id, newName) => {
    await supabase.from('items').update({ name: newName }).eq('id', id);
    fetchItems();
  };

  const deleteItem = async (id) => {
    await supabase.from('items').delete().eq('id', id);
    fetchItems();
  };

  return (
    <div>
      <input value={name} onChange={(e) => setName(e.target.value)} placeholder="Item name" />
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>
            {item.name}
            <button onClick={() => updateItem(item.id, 'Updated Name')}>Update</button>
            <button onClick={() => deleteItem(item.id)}>Delete</button>
          </li>
        ))}
      </ul>
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows adding, updating, and deleting items in the Supabase database, with changes reflected in real-time.
```

**Resources:**
- [Supabase CRUD Documentation](https://supabase.io/docs/guides/database/crud)
- [Supabase JavaScript Library](https://supabase.io/docs/reference/javascript/supabase-client)

### Example 2: Implementing Authentication with Supabase

**Explanation:**
This example demonstrates how to implement user authentication using Supabase. It includes setting up sign-in and sign-out functionality and managing the authentication state in a React application.

**Example Code:**
```js
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://xyzcompany.supabase.co';
const supabaseKey = 'public-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;

// App.js
import React, { useState, useEffect } from 'react';
import supabase from './supabaseClient';

const App = () => {
  const [user, setUser] = useState(null);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  useEffect(() => {
    const session = supabase.auth.session();
    setUser(session?.user || null);
    
    const { data: authListener } = supabase.auth.onAuthStateChange((_event, session) => {
      setUser(session?.user || null);
    });

    return () => {
      authListener?.unsubscribe();
    };
  }, []);

  const signUp = async () => {
    const { user, error } = await supabase.auth.signUp({ email, password });
    if (error) console.error('Error signing up:', error.message);
    else setUser(user);
  };

  const signIn = async () => {
    const { user, error } = await supabase.auth.signIn({ email, password });
    if (error) console.error('Error signing in:', error.message);
    else setUser(user);
  };

  const signOut = async () => {
    await supabase.auth.signOut();
    setUser(null);
  };

  return (
    <div>
      {user ? (
        <>
          <button onClick={signOut}>Sign Out</button>
          <p>Welcome, {user.email}</p>
        </>
      ) : (
        <>
          <input value={email} onChange={(e) => setEmail(e.target.value)} placeholder="Email" />
          <input value={password} onChange={(e) => setPassword(e.target.value)} placeholder="Password" type="password" />
          <button onClick={signUp}>Sign Up</button>
          <button onClick={signIn}>Sign In</button>
        </>
      )}
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app allows users to sign up, sign in, and sign out using Supabase authentication services.
```

**Resources:**
- [Supabase Authentication Documentation](https://supabase.io/docs/guides/auth)
- [Supabase Auth Client](https://supabase.io/docs/reference/javascript/auth-signup)

### Example 3: Real-Time Data Synchronization with Supabase

**Explanation:**
This example demonstrates how to implement real-time data synchronization using Supabase's real-time capabilities. It shows how to subscribe to changes in a Supabase table and update the UI accordingly.

**Example Code:**
```js
// supabaseClient.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = 'https://xyzcompany.supabase.co';
const supabaseKey = 'public-anon-key';
const supabase = createClient(supabaseUrl, supabaseKey);

export default supabase;

// App.js
import React, { useState, useEffect } from 'react';
import supabase from './supabaseClient';

const App = () => {
  const [items, setItems] = useState([]);

  useEffect(() => {
    fetchItems();

    const subscription = supabase
      .from('items')
      .on('INSERT', (payload) => {
        setItems((prevItems) => [...prevItems, payload.new]);
      })
      .on('UPDATE', (payload) => {
        setItems((prevItems) =>
          prevItems.map((item) => (item.id === payload.new.id ? payload.new : item))
        );
      })
      .on('DELETE', (payload) => {
        setItems((prevItems) => prevItems.filter((item) => item.id !== payload.old.id));
      })
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  }, []);

  const fetchItems = async () => {
    const { data } = await supabase.from('items').select('*');
    setItems(data);
  };

  const addItem = async () => {
    await supabase.from('items').insert([{ name: 'New Item' }]);
  };

  return (
    <div>
      <button onClick={addItem}>Add Item</button>
      <ul>
        {items.map((item) => (
          <li key={item.id}>{item.name}</li>
        ))}
      </ul>
    </div>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app displays items in real-time, updating the list as changes occur in the Supabase database.
```

**Resources:**
- [Supabase Real-time Documentation](https://supabase.io/docs/guides/realtime)
- [Supabase JavaScript Client](https://supabase.io/docs/reference/javascript/)

---

### Task 9: Study advanced state management patterns

**Explanation:**
Advanced state management patterns are essential for managing complex state in modern web and mobile applications. These patterns include techniques and libraries that help maintain and manipulate state efficiently and predictably. Some of the most popular advanced state management solutions include Redux, MobX, Context API with hooks, and state machines like XState. Each of these approaches offers unique benefits and is suitable for different types of applications and development preferences.

Understanding advanced state management patterns allows developers to handle large-scale applications where state needs to be shared across many components. This includes managing asynchronous data fetching, handling side effects, ensuring immutability, and optimizing performance. Mastering these patterns can lead to more maintainable, scalable, and performant applications.

**Resources:**
- [State Management in React](https://reactjs.org/docs/state-management.html)
- [Advanced State Management with Redux](https://redux.js.org/introduction/getting-started)

### Example 1: Advanced State Management with Redux

**Explanation:**
Redux is a predictable state container for JavaScript apps. It helps manage the state of an application in a single, centralized store. Advanced Redux patterns include using middleware for side effects, handling complex actions, and optimizing performance with selectors.

**Example Code:**
```js
// store.js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import rootReducer from './reducers';

const store = createStore(rootReducer, applyMiddleware(thunk));

export default store;

// reducers.js
import { combineReducers } from 'redux';

const initialState = {
  data: [],
};

const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'FETCH_DATA_SUCCESS':
      return {
        ...state,
        data: action.payload,
      };
    default:
      return state;
  }
};

const rootReducer = combineReducers({
  data: dataReducer,
});

export default rootReducer;

// actions.js
import axios from 'axios';

export const fetchData = () => async (dispatch) => {
  const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
  dispatch({ type: 'FETCH_DATA_SUCCESS', payload: response.data });
};

// App.js
import React, { useEffect } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';
import { fetchData } from './actions';

const App = () => {
  const dispatch = useDispatch();
  const data = useSelector((state) => state.data.data);

  useEffect(() => {
    dispatch(fetchData());
  }, [dispatch]);

  return (
    <Provider store={store}>
      <div>
        <h1>Data</h1>
        <ul>
          {data.map((item) => (
            <li key={item.id}>{item.title}</li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```
**Expected Output:**
```sh
# The app fetches data from an API and displays it in a list, using Redux for state management.
```

**Resources:**
- [Redux Thunk Middleware](https://redux.js.org/usage/writing-logic-thunks)
- [Redux Selectors](https://redux.js.org/usage/deriving-data-selectors)

### Example 2: State Management with MobX

**Explanation:**
MobX is a simple and scalable state management solution. It uses observable state, actions, and reactions to manage state. MobX is known for its simplicity and efficiency, making it a good choice for applications that require reactive state management.

**Example Code:**
```js
// store.js
import { makeAutoObservable } from 'mobx';

class Store {
  data = [];

  constructor() {
    makeAutoObservable(this);
  }

  setData(data) {
    this.data = data;
  }

  async fetchData() {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts');
    const data = await response.json();
    this.setData(data);
  }
}

const store = new Store();
export default store;

// App.js
import React, { useEffect } from 'react';
import { observer } from 'mobx-react-lite';
import store from './store';

const App = observer(() => {
  useEffect(() => {
    store.fetchData();
  }, []);

  return (
    <div>
      <h1>Data</h1>
      <ul>
        {store.data.map((item) => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
});

export default App;
```
**Expected Output:**
```sh
# The app fetches data from an API and displays it in a list, using MobX for state management.
```

**Resources:**
- [MobX Documentation](https://mobx.js.org/README.html)
- [Getting Started with MobX](https://mobx.js.org/getting-started)

### Example 3: State Management with Context API and Hooks

**Explanation:**
The Context API combined with React Hooks provides a lightweight solution for state management. This approach is ideal for applications where the state needs to be shared across several components but doesn't require the full capabilities of Redux or MobX.

**Example Code:**
```js
// DataContext.js
import React, { createContext, useReducer, useContext, useEffect } from 'react';

const DataContext = createContext();

const initialState = {
  data: [],
};

const dataReducer = (state, action) => {
  switch (action.type) {
    case 'SET_DATA':
      return { ...state, data: action.payload };
    default:
      return state;
  }
};

export const DataProvider = ({ children }) => {
  const [state, dispatch] = useReducer(dataReducer, initialState);

  const fetchData = async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts');
    const data = await response.json();
    dispatch({ type: 'SET_DATA', payload: data });
  };

  useEffect(() => {
    fetchData();
  }, []);

  return (
    <DataContext.Provider value={{ state, dispatch }}>
      {children}
    </DataContext.Provider>
  );
};

export const useData = () => useContext(DataContext);

// App.js
import React from 'react';
import { DataProvider, useData } from './DataContext';

const DataList = () => {
  const { state } = useData();

  return (
    <ul>
      {state.data.map((item) => (
        <li key={item.id}>{item.title}</li>
      ))}
    </ul>
  );
};

const App = () => (
  <DataProvider>
    <div>
      <h1>Data</h1>
      <DataList />
    </div>
  </DataProvider>
);

export default App;
```
**Expected Output:**
```sh
# The app fetches data from an API and displays it in a list, using Context API and Hooks for state management.
```

**Resources:**
- [React Context API](https://reactjs.org/docs/context.html)
- [Using React Hooks](https://reactjs.org/docs/hooks-intro.html)

---

### Task 10: Implement Redux Toolkit for State Management

####  Setting Up Redux Toolkit in a React Native Project

**Explanation:**
Redux Toolkit is the official, recommended way to write Redux logic. It helps you to avoid common mistakes and reduces boilerplate code. Redux Toolkit includes utilities to simplify store setup, create reducers, and manage middleware. Setting up Redux Toolkit in a React Native project begins with installing the necessary packages and configuring the Redux store. This involves using `configureStore` to set up the store and `createSlice` to create reducers and actions.

Using Redux Toolkit ensures that you follow best practices and maintain a standardized approach to state management. By providing a more intuitive API, Redux Toolkit makes it easier to implement complex state logic with fewer lines of code. It also integrates well with TypeScript, allowing for better type safety and autocompletion in your IDE.

**Online Resources:**
- [Redux Toolkit Documentation](https://redux-toolkit.js.org/introduction/getting-started)
- [React Native and Redux Toolkit Tutorial](https://reactnative.dev/docs/state-management#redux)

**Examples to Practice:**
1. **Setting Up a Basic Redux Store:**
   ```javascript
   import { configureStore } from '@reduxjs/toolkit';

   const store = configureStore({
     reducer: {
       // Add your reducers here
     },
   });

   export default store;
   ```
   **Explanation:**
   This example demonstrates the initial setup of a Redux store using Redux Toolkit. The `configureStore` function simplifies the configuration by automatically setting up the store with good defaults, including Redux DevTools and thunk middleware.

2. **Creating a Slice:**
   ```javascript
   import { createSlice } from '@reduxjs/toolkit';

   const counterSlice = createSlice({
     name: 'counter',
     initialState: { value: 0 },
     reducers: {
       increment: state => {
         state.value += 1;
       },
       decrement: state => {
         state.value -= 1;
       },
     },
   });

   export const { increment, decrement } = counterSlice.actions;
   export default counterSlice.reducer;
   ```
   **Explanation:**
   This example creates a slice for a counter feature. The `createSlice` function generates a slice with a name, initial state, and reducers. It also automatically generates action creators and action types that correspond to the reducers.

3. **Connecting Redux to a React Native Component:**
   ```javascript
   import React from 'react';
   import { useSelector, useDispatch } from 'react-redux';
   import { increment, decrement } from './counterSlice';
   import { View, Text, Button } from 'react-native';

   const Counter = () => {
     const count = useSelector((state) => state.counter.value);
     const dispatch = useDispatch();

     return (
       <View>
         <Text>Count: {count}</Text>
         <Button title="Increment" onPress={() => dispatch(increment())} />
         <Button title="Decrement" onPress={() => dispatch(decrement())} />
       </View>
     );
   };

   export default Counter;
   ```
   **Explanation:**
   This example shows how to connect the Redux store to a React Native component. The `useSelector` hook retrieves the current state from the Redux store, and the `useDispatch` hook dispatches actions. This pattern helps keep components declarative and predictable by managing state in a centralized store.

**Online Resources:**
- [React Redux Documentation](https://react-redux.js.org/introduction/getting-started)
- [Redux Toolkit Quick Start](https://redux-toolkit.js.org/tutorials/quick-start)

**Code to Practice and Expected Output:**

1. **Setting Up a Basic Redux Store:**
   ```javascript
   import { configureStore } from '@reduxjs/toolkit';

   const store = configureStore({
     reducer: {
       // Add your reducers here
     },
   });

   export default store;
   ```
   **Expected Output:**
   A configured Redux store with the default middleware and Redux DevTools integration.

2. **Creating a Slice:**
   ```javascript
   import { createSlice } from '@reduxjs/toolkit';

   const counterSlice = createSlice({
     name: 'counter',
     initialState: { value: 0 },
     reducers: {
       increment: state => {
         state.value += 1;
       },
       decrement: state => {
         state.value -= 1;
       },
     },
   });

   export const { increment, decrement } = counterSlice.actions;
   export default counterSlice.reducer;
   ```
   **Expected Output:**
   A counter slice with actions (`increment`, `decrement`) and a reducer that manages the state of the counter.

3. **Connecting Redux to a React Native Component:**
   ```javascript
   import React from 'react';
   import { useSelector, useDispatch } from 'react-redux';
   import { increment, decrement } from './counterSlice';
   import { View, Text, Button } from 'react-native';

   const Counter = () => {
     const count = useSelector((state) => state.counter.value);
     const dispatch = useDispatch();

     return (
       <View>
         <Text>Count: {count}</Text>
         <Button title="Increment" onPress={() => dispatch(increment())} />
         <Button title="Decrement" onPress={() => dispatch(decrement())} />
       </View>
     );
   };

   export default Counter;
   ```
   **Expected Output:**
   A functional React Native component that displays a counter and buttons to increment and decrement the counter. The component is connected to the Redux store, and the state updates accordingly when the buttons are pressed.

### Task 11: Study Advanced Routing Patterns

#### Nested Routing in React Navigation

**Explanation:**
Nested routing is an advanced pattern in React Navigation where a navigator can be placed inside another navigator. This pattern is particularly useful for applications with complex navigation structures, such as having a tab navigator inside a stack navigator. It allows for better organization of routes and the creation of more intuitive user flows. By nesting navigators, you can manage navigation state more efficiently and create more dynamic navigation experiences.

Nested routing enables you to encapsulate navigation logic within individual features or screens, making the codebase more modular and maintainable. It also allows for deeper linking and improved user experience by ensuring that the navigation hierarchy is consistent and predictable.

**Online Resources:**
- [React Navigation Nested Navigators Documentation](https://reactnavigation.org/docs/nesting-navigators)
- [React Navigation Patterns and Best Practices](https://reactnavigation.org/docs/navigation-patterns)

**Examples to Practice:**
1. **Stack Navigator with Nested Tab Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Home" component={MyTabs} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   This example demonstrates how to nest a tab navigator inside a stack navigator. The `MyTabs` function defines the tab navigator with two screens: Home and Settings. The `MyStack` function nests the `MyTabs` component within a stack navigator and adds a Profile screen. This pattern allows for both tab navigation and deep linking within the stack.

2. **Drawer Navigator with Nested Stack Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import NotificationsScreen from './screens/NotificationsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const HomeStack = createStackNavigator();

   function HomeStackScreen() {
     return (
       <HomeStack.Navigator>
         <HomeStack.Screen name="Home" component={HomeScreen} />
         <HomeStack.Screen name="Details" component={DetailsScreen} />
       </HomeStack.Navigator>
     );
   }

   const ProfileStack = createStackNavigator();

   function ProfileStackScreen() {
     return (
       <ProfileStack.Navigator>
         <ProfileStack.Screen name="Profile" component={ProfileScreen} />
         <ProfileStack.Screen name="Notifications" component={NotificationsScreen} />
       </ProfileStack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator initialRouteName="Home">
           <Drawer.Screen name="Home" component={HomeStackScreen} />
           <Drawer.Screen name="Profile" component={ProfileStackScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   This example demonstrates how to nest stack navigators within a drawer navigator. The `HomeStackScreen` and `ProfileStackScreen` functions define separate stack navigators for the Home and Profile sections, respectively. These stack navigators are then nested within a drawer navigator, providing a side menu for navigating between the Home and Profile sections.

3. **Deep Linking with Nested Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Tabs" component={MyTabs} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator initialRouteName="Stack">
           <Drawer.Screen name="Stack" component={MyStack} />
           <Drawer.Screen name="Profile" component={ProfileScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   This example demonstrates a complex navigation setup with nested navigators and deep linking. The `MyTabs` component defines a tab navigator nested within a stack navigator (`MyStack`). This stack navigator is then nested within a drawer navigator, providing a robust navigation hierarchy that supports deep linking and modular navigation.

**Online Resources:**
- [React Navigation Deep Linking](https://reactnavigation.org/docs/deep-linking)
- [Advanced Navigation Patterns in React Navigation](https://reactnavigation.org/docs/nesting-navigators#navigators-in-tab)

**Code to Practice and Expected Output:**

1. **Stack Navigator with Nested Tab Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Home" component={MyTabs} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Expected Output:**
   A navigation structure where the Home screen contains a tab navigator with Home and Settings tabs. The Profile screen is accessible from the stack navigator, providing a layered navigation experience.

2. **Drawer Navigator with Nested Stack Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import NotificationsScreen from './screens/NotificationsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const HomeStack = createStackNavigator();

   function HomeStackScreen() {
     return (
       <HomeStack.Navigator>
         <HomeStack.Screen name="Home" component={HomeScreen} />
         <HomeStack.Screen name="Details" component={DetailsScreen} />
       </HomeStack.Navigator>
     );
   }

   const ProfileStack = createStackNavigator();

   function ProfileStackScreen() {
     return (
       <ProfileStack.Navigator>
         <ProfileStack.Screen name="Profile" component={ProfileScreen} />
         <ProfileStack.Screen name="Notifications" component={NotificationsScreen} />
       </ProfileStack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator initialRouteName="Home">
           <Drawer.Screen name="Home" component={HomeStackScreen} />
           <Drawer.Screen name="Profile" component={ProfileStackScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
   **Expected Output:**
   A drawer navigation structure where the Home and Profile sections each have their own stack navigator. This setup allows for deep navigation within each section while maintaining a side menu for overall navigation.

3. **Deep Linking with Nested Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Tabs" component={MyTabs} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator initialRouteName="Stack">
           <Drawer.Screen name="Stack" component={MyStack} />
           <Drawer.Screen name="Profile" component={ProfileScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
**Expected Output:**
   A complex navigation setup with nested navigators that supports deep linking. The Home and Settings screens are accessible via tabs within a stack navigator, which is nested inside a drawer navigator. This allows for organized and intuitive navigation within the app.


### Task 12: Implement Nested and Conditional Navigation

#### Task 1: Nested Navigation

**Explanation:**
Nested navigation in React Native allows you to embed one navigator inside another. This is useful for managing complex navigation flows within an app. For example, you might have a tab navigator inside a stack navigator, where each tab represents a stack of screens. This hierarchical navigation structure helps in organizing the navigation logic and making the app's user interface more intuitive and manageable.

Implementing nested navigation involves defining multiple navigators and combining them. Each navigator manages its own set of screens and can navigate independently. This setup not only keeps your navigation code clean and modular but also allows for better state management and easier debugging.

**Online Resources:**
- [React Navigation Nested Navigators](https://reactnavigation.org/docs/nesting-navigators)
- [React Navigation Patterns and Best Practices](https://reactnavigation.org/docs/navigation-patterns)

**Examples to Practice:**

1. **Tab Navigator Inside a Stack Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="HomeTabs" component={MyTabs} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   This example creates a stack navigator (`MyStack`) that contains a tab navigator (`MyTabs`). The `MyTabs` function defines two tabs: Home and Settings. The stack navigator includes the tab navigator as one of its screens, alongside a Profile screen. This setup allows for nested navigation, where the tabs can be navigated independently within the stack.

2. **Drawer Navigator Inside a Stack Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import NotificationsScreen from './screens/NotificationsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Drawer = createDrawerNavigator();

   function MyDrawer() {
     return (
       <Drawer.Navigator>
         <Drawer.Screen name="Home" component={HomeScreen} />
         <Drawer.Screen name="Notifications" component={NotificationsScreen} />
       </Drawer.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Drawer" component={MyDrawer} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   In this example, a drawer navigator (`MyDrawer`) is nested inside a stack navigator (`MyStack`). The drawer navigator includes Home and Notifications screens, while the stack navigator manages the drawer navigator along with Profile and Details screens. This nested structure allows for a drawer-based navigation within a stack navigation context.

3. **Combining Stack and Tab Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Tabs" component={MyTabs} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator>
           <Drawer.Screen name="Stack" component={MyStack} />
           <Drawer.Screen name="Profile" component={ProfileScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
   **Explanation:**
   This example showcases a complex navigation structure combining stack, tab, and drawer navigators. The tab navigator (`MyTabs`) is nested inside a stack navigator (`MyStack`), and the stack navigator is further nested inside a drawer navigator. This configuration provides a highly flexible navigation setup suitable for large applications with multiple levels of navigation.

**Online Resources:**
- [React Navigation Drawer Navigator](https://reactnavigation.org/docs/drawer-navigator)
- [React Navigation Stack Navigator](https://reactnavigation.org/docs/stack-navigator)

**Code to Practice and Expected Output:**

1. **Tab Navigator Inside a Stack Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="HomeTabs" component={MyTabs} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Expected Output:**
   A navigation structure where the Home screen contains a tab navigator with Home and Settings tabs. The Profile screen is accessible from the stack navigator, providing a layered navigation experience.

2. **Drawer Navigator Inside a Stack Navigator:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import NotificationsScreen from './screens/NotificationsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Drawer = createDrawerNavigator();

   function MyDrawer() {
     return (
       <Drawer.Navigator>
         <Drawer.Screen name="Home" component={HomeScreen} />
         <Drawer.Screen name="Notifications" component={NotificationsScreen} />
       </Drawer.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Drawer" component={MyDrawer} />
         <Stack.Screen name="Profile" component={ProfileScreen} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   export default function App() {
     return (
       <NavigationContainer>
         <MyStack />
       </NavigationContainer>
     );
   }
   ```
   **Expected Output:**
   A drawer navigation structure where the Home and Notifications sections are managed by a drawer navigator. The Profile and Details screens are managed by the stack navigator, providing a side menu for navigation.

3. **Combining Stack and Tab Navigators:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
   import { createDrawerNavigator } from '@react-navigation/drawer';
   import HomeScreen from './screens/HomeScreen';
   import SettingsScreen from './screens/SettingsScreen';
   import ProfileScreen from './screens/ProfileScreen';
   import DetailsScreen from './screens/DetailsScreen';

   const Tab = createBottomTabNavigator();

   function MyTabs() {
     return (
       <Tab.Navigator>
         <Tab.Screen name="Home" component={HomeScreen} />
         <Tab.Screen name="Settings" component={SettingsScreen} />
       </Tab.Navigator>
     );
   }

   const Stack = createStackNavigator();

   function MyStack() {
     return (
       <Stack.Navigator>
         <Stack.Screen name="Tabs" component={MyTabs} />
         <Stack.Screen name="Details" component={DetailsScreen} />
       </Stack.Navigator>
     );
   }

   const Drawer = createDrawerNavigator();

   export default function App() {
     return (
       <NavigationContainer>
         <Drawer.Navigator>
           <Drawer.Screen name="Stack" component={MyStack} />
           <Drawer.Screen name="Profile" component={ProfileScreen} />
         </Drawer.Navigator>
       </NavigationContainer>
     );
   }
   ```
   **Expected Output:**
   A complex navigation setup combining stack, tab, and drawer navigators. The Home and Settings screens are accessible via tabs within a stack navigator, which is nested inside a drawer navigator. This allows for organized and intuitive navigation within the app.

#### Task 2: Conditional Navigation

**Explanation:**
Conditional navigation in React Native refers to navigating to different screens based on certain conditions or states. This pattern is often used for authentication flows, where a user might be directed to a login screen if they are not authenticated, or to a home screen if they are. Conditional navigation ensures that users are taken to the appropriate screens based on their current state or the app's state.

Implementing conditional navigation involves using state management to keep track of conditions and using conditional rendering to navigate to different screens. This might involve checking authentication status, user roles, or other state variables. This approach improves user experience by providing relevant navigation based on the user's context.

**Online Resources:**
- [React Navigation Authentication Flows](https://reactnavigation.org/docs/auth-flow)
- [React Navigation Conditional Rendering](https://reactnavigation.org/docs/conditional-rendering)

**Examples to Practice:**

1. **Basic Authentication Flow:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [isLoggedIn, setIsLoggedIn] = React.useState(false);

     return (
       <AuthContext.Provider value={{ isLoggedIn, setIsLoggedIn }}>
         <NavigationContainer>
           <Stack.Navigator>
             {isLoggedIn ? (
               <Stack.Screen name="Home" component={HomeScreen} />
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates a basic authentication flow using conditional navigation. The app checks the `isLoggedIn` state and renders the Home screen if the user is logged in, or the Login screen if they are not. The `AuthContext` provides the authentication state to the rest of the app.

2. **Role-Based Navigation:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import AdminScreen from './screens/AdminScreen';
   import UserScreen from './screens/UserScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [user, setUser] = React.useState(null);

     return (
       <AuthContext.Provider value={{ user, setUser }}>
         <NavigationContainer>
           <Stack.Navigator>
             {user ? (
               user.role === 'admin' ? (
                 <Stack.Screen name="Admin" component={AdminScreen} />
               ) : (
                 <Stack.Screen name="User" component={UserScreen} />
               )
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates role-based navigation. The app checks the user's role and navigates to different screens accordingly. If the user is an admin, it navigates to the Admin screen; if the user is a regular user, it navigates to the User screen. If the user is not logged in, it shows the Login screen.

3. **Conditional Navigation Based on Data:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import DataScreen from './screens/DataScreen';
   import NoDataScreen from './screens/NoDataScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [user, setUser] = React.useState(null);
     const [data, setData] = React.useState(null);

     return (
       <AuthContext.Provider value={{ user, setUser }}>
         <NavigationContainer>
           <Stack.Navigator>
             {user ? (
               data ? (
                 <Stack.Screen name="Data" component={DataScreen} />
               ) : (
                 <Stack.Screen name="NoData" component={NoDataScreen} />
               )
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates conditional navigation based on the presence of data. The app checks if the user is logged in and if there is data available. If data is available, it navigates to the Data screen; if not, it navigates to the NoData screen. If the user is not logged in, it shows the Login screen.

**Online Resources:**
- [React Navigation Authentication Flows](https://reactnavigation.org/docs/auth-flow)
- [React Navigation Conditional Rendering](https://reactnavigation.org/docs/conditional-rendering)

**Code to Practice and Expected Output:**

1. **Basic Authentication Flow:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import HomeScreen from './screens/HomeScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [isLoggedIn, setIsLoggedIn] = React.useState(false);

     return (
       <AuthContext.Provider value={{ isLoggedIn, setIsLoggedIn }}>
         <NavigationContainer>
           <Stack.Navigator>
             {isLoggedIn ? (
               <Stack.Screen name="Home" component={HomeScreen} />
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Expected Output:**
   A navigation structure that conditionally renders the Home screen if the user is logged in, or the Login screen if they are not.

2. **Role-Based Navigation:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import AdminScreen from './screens/AdminScreen';
   import UserScreen from './screens/UserScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [user, setUser] = React.useState(null);

     return (
       <AuthContext.Provider value={{ user, setUser }}>
         <NavigationContainer>
           <Stack.Navigator>
             {user ? (
               user.role === 'admin' ? (
                 <Stack.Screen name="Admin" component={AdminScreen} />
               ) : (
                 <Stack.Screen name="User" component={UserScreen} />
               )
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Expected Output:**
   A navigation structure that conditionally renders the Admin screen for admin users, the User screen for regular users, or the Login screen if the user is not logged in.

3. **Conditional Navigation Based on Data:**
   ```javascript
   import * as React from 'react';
   import { NavigationContainer } from '@react-navigation/native';
   import { createStackNavigator } from '@react-navigation/stack';
   import DataScreen from './screens/DataScreen';
   import NoDataScreen from './screens/NoDataScreen';
   import LoginScreen from './screens/LoginScreen';
   import AuthContext from './context/AuthContext';

   const Stack = createStackNavigator();

   export default function App() {
     const [user, setUser] = React.useState(null);
     const [data, setData] = React.useState(null);

     return (
       <AuthContext.Provider value={{ user, setUser }}>
         <NavigationContainer>
           <Stack.Navigator>
             {user ? (
               data ? (
                 <Stack.Screen name="Data" component={DataScreen} />
               ) : (
                 <Stack.Screen name="NoData" component={NoDataScreen} />
               )
             ) : (
               <Stack.Screen name="Login" component={LoginScreen} />
             )}
           </Stack.Navigator>
         </NavigationContainer>
       </AuthContext.Provider>
     );
   }
   ```
   **Expected Output:**
   A navigation structure that conditionally renders the Data screen if data is available, the NoData screen if data is not available, or the Login screen if the user is not logged in.

### Task 13: Study Context API Patterns

#### Task 1: Basic Context API Usage

**Explanation:**
The Context API in React allows you to create global variables that can be passed around the entire application. This is the alternative to "prop drilling" or passing props from grandparent to child to parent, and so on. Context is also touted as an easier, lighter approach to state management using Redux. The Context API is often used to manage themes, user authentication, and other global state data.

Using the Context API involves three main steps: creating a context, providing the context, and consuming the context. First, you create a context using `React.createContext()`. Then, you provide the context to your component tree using a `Context.Provider`. Finally, you consume the context in your components using `Context.Consumer` or the `useContext` hook in functional components.

**Online Resources:**
- [React Context API Documentation](https://reactjs.org/docs/context.html)
- [Using the Context API in React](https://www.digitalocean.com/community/tutorials/react-react-context-api)

**Examples to Practice:**

1. **Creating and Using a Context:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const ThemeContext = createContext();

   function ThemeProvider({ children }) {
     const [theme, setTheme] = useState('light');

     return (
       <ThemeContext.Provider value={{ theme, setTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   }

   function ThemedComponent() {
     const { theme, setTheme } = useContext(ThemeContext);
     return (
       <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
         <p>The current theme is {theme}</p>
         <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
           Toggle Theme
         </button>
       </div>
     );
   }

   export default function App() {
     return (
       <ThemeProvider>
         <ThemedComponent />
       </ThemeProvider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates how to create and use a context for theme management. The `ThemeProvider` component uses the `ThemeContext.Provider` to provide the theme state and a function to toggle the theme. The `ThemedComponent` uses the `useContext` hook to consume the theme context and render the UI accordingly.

2. **Using Context in a Class Component:**
   ```javascript
   import React, { createContext, Component } from 'react';

   const UserContext = createContext();

   class UserProvider extends Component {
     state = { name: 'John Doe', loggedIn: true };

     render() {
       return (
         <UserContext.Provider value={{ user: this.state }}>
           {this.props.children}
         </UserContext.Provider>
       );
     }
   }

   class UserProfile extends Component {
     static contextType = UserContext;

     render() {
       const { user } = this.context;
       return (
         <div>
           <h1>{user.name}</h1>
           <p>{user.loggedIn ? 'Logged In' : 'Logged Out'}</p>
         </div>
       );
     }
   }

   export default function App() {
     return (
       <UserProvider>
         <UserProfile />
       </UserProvider>
     );
   }
   ```
   **Explanation:**
   This example shows how to use the Context API in a class component. The `UserProvider` component provides user data through context. The `UserProfile` component consumes the user context using the `contextType` property. This setup allows the class component to access the context directly.

3. **Multiple Contexts:**
   ```javascript
   import React, { createContext, useContext } from 'react';

   const AuthContext = createContext();
   const ThemeContext = createContext();

   function AuthProvider({ children }) {
     const auth = { user: 'Jane Doe', isAuthenticated: true };
     return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
   }

   function ThemeProvider({ children }) {
     const theme = { color: 'blue' };
     return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;
   }

   function UserProfile() {
     const auth = useContext(AuthContext);
     const theme = useContext(ThemeContext);

     return (
       <div style={{ color: theme.color }}>
         <h1>{auth.user}</h1>
         <p>{auth.isAuthenticated ? 'Authenticated' : 'Not Authenticated'}</p>
       </div>
     );
   }

   export default function App() {
     return (
       <AuthProvider>
         <ThemeProvider>
           <UserProfile />
         </ThemeProvider>
       </AuthProvider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates the use of multiple contexts. The `AuthProvider` provides authentication data, and the `ThemeProvider` provides theme data. The `UserProfile` component consumes both contexts using the `useContext` hook, allowing it to display user information and apply theme styles.

**Online Resources:**
- [React Context Multiple Providers](https://blog.logrocket.com/react-context-api-multiple-providers/)
- [React Context with Hooks](https://dev.to/frontendengineer/create-and-use-context-in-react-with-hooks-2oda)

**Code to Practice and Expected Output:**

1. **Creating and Using a Context:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const ThemeContext = createContext();

   function ThemeProvider({ children }) {
     const [theme, setTheme] = useState('light');

     return (
       <ThemeContext.Provider value={{ theme, setTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   }

   function ThemedComponent() {
     const { theme, setTheme } = useContext(ThemeContext);
     return (
       <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
         <p>The current theme is {theme}</p>
         <button onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}>
           Toggle Theme
         </button>
       </div>
     );
   }

   export default function App() {
     return (
       <ThemeProvider>
         <ThemedComponent />
       </ThemeProvider>
     );
   }
   ```
   **Expected Output:**
   A component that displays the current theme and a button to toggle between light and dark themes. The theme state is managed using the Context API.

2. **Using Context in a Class Component:**
   ```javascript
   import React, { createContext, Component } from 'react';

   const UserContext = createContext();

   class UserProvider extends Component {
     state = { name: 'John Doe', loggedIn: true };

     render() {
       return (
         <UserContext.Provider value={{ user: this.state }}>
           {this.props.children}
         </UserContext.Provider>
       );
     }
   }

   class UserProfile extends Component {
     static contextType = UserContext;

     render() {
       const { user } = this.context;
       return (
         <div>
           <h1>{user.name}</h1>
           <p>{user.loggedIn ? 'Logged In' : 'Logged Out'}</p>
         </div>
       );
     }
   }

   export default function App() {
     return (
       <UserProvider>
         <UserProfile />
       </UserProvider>
     );
   }
   ```
   **Expected Output:**
   A class component that displays the user's name and login status. The user state is managed using the Context API.

3. **Multiple Contexts:**
   ```javascript
   import React, { createContext, useContext } from 'react';

   const AuthContext = createContext();
   const ThemeContext = createContext();

   function AuthProvider({ children }) {
     const auth = { user: 'Jane Doe', isAuthenticated: true };
     return <AuthContext.Provider value={auth}>{children}</AuthContext.Provider>;
   }

   function ThemeProvider({ children }) {
     const theme = { color: 'blue' };
     return <ThemeContext.Provider value={theme}>{children}</ThemeContext.Provider>;
   }

   function UserProfile() {
     const auth = useContext(AuthContext);
     const theme = useContext(ThemeContext);

     return (
       <div style={{ color: theme.color }}>
         <h1>{auth.user}</h1>
         <p>{auth.isAuthenticated ? 'Authenticated' : 'Not Authenticated'}</p>
       </div>
     );
   }

   export default function App() {
     return (
       <AuthProvider>
         <ThemeProvider>
           <UserProfile />
         </ThemeProvider>
       </AuthProvider>
     );
   }
   ```
   **Expected Output:**
   A component that displays the user's name and authentication status with a specific theme color. The state is managed using multiple contexts (authentication and theme).

### Task 14: Implement Context API for Global State

#### Task 1: Creating and Using a Global State with Context API

**Explanation:**
Using the Context API for global state management in React allows you to create a centralized state that can be accessed and modified from any component within the application. This approach avoids "prop drilling," where props are passed down through multiple levels of the component tree, making the state management more efficient and the code cleaner. The Context API involves creating a context, providing the context to the component tree, and consuming the context in any component that needs access to the global state.

To implement global state management with the Context API, you start by creating a context using `React.createContext()`. You then wrap your application (or parts of it) in a `Provider` component, which supplies the global state and functions to modify it. Any component within the `Provider` can access the context using the `useContext` hook (for functional components) or `contextType` (for class components).

**Online Resources:**
- [React Context API Documentation](https://reactjs.org/docs/context.html)
- [React Context for State Management](https://www.taniarascia.com/using-context-for-state-management-in-react/)

**Examples to Practice:**

1. **Global State for User Authentication:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const AuthContext = createContext();

   function AuthProvider({ children }) {
     const [user, setUser] = useState(null);

     const login = (userData) => setUser(userData);
     const logout = () => setUser(null);

     return (
       <AuthContext.Provider value={{ user, login, logout }}>
         {children}
       </AuthContext.Provider>
     );
   }

   function UserProfile() {
     const { user, logout } = useContext(AuthContext);
     return user ? (
       <div>
         <p>Welcome, {user.name}</p>
         <button onClick={logout}>Logout</button>
       </div>
     ) : (
       <p>Please log in.</p>
     );
   }

   function App() {
     const { login } = useContext(AuthContext);
     const mockUser = { name: 'John Doe', email: 'john.doe@example.com' };

     return (
       <div>
         <button onClick={() => login(mockUser)}>Login as John Doe</button>
         <UserProfile />
       </div>
     );
   }

   export default function MainApp() {
     return (
       <AuthProvider>
         <App />
       </AuthProvider>
     );
   }
   ```
   **Explanation:**
   This example creates a global state for user authentication using the Context API. The `AuthProvider` component manages the user state and provides functions to log in and log out. The `UserProfile` component consumes the context to display the user's name and a logout button, while the `App` component includes a button to log in as a mock user.

2. **Global State for Theme Management:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const ThemeContext = createContext();

   function ThemeProvider({ children }) {
     const [theme, setTheme] = useState('light');

     const toggleTheme = () => {
       setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
     };

     return (
       <ThemeContext.Provider value={{ theme, toggleTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   }

   function ThemedComponent() {
     const { theme, toggleTheme } = useContext(ThemeContext);
     return (
       <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
         <p>The current theme is {theme}</p>
         <button onClick={toggleTheme}>Toggle Theme</button>
       </div>
     );
   }

   export default function MainApp() {
     return (
       <ThemeProvider>
         <ThemedComponent />
       </ThemeProvider>
     );
   }
   ```
   **Explanation:**
   This example demonstrates a global state for theme management using the Context API. The `ThemeProvider` component manages the theme state and provides a function to toggle between light and dark themes. The `ThemedComponent` consumes the context to apply the current theme and includes a button to toggle the theme.

3. **Global State for Cart Management:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const CartContext = createContext();

   function CartProvider({ children }) {
     const [cart, setCart] = useState([]);

     const addToCart = (item) => setCart((prevCart) => [...prevCart, item]);
     const removeFromCart = (item) => setCart((prevCart) => prevCart.filter((i) => i !== item));

     return (
       <CartContext.Provider value={{ cart, addToCart, removeFromCart }}>
         {children}
       </CartContext.Provider>
     );
   }

   function Cart() {
     const { cart, removeFromCart } = useContext(CartContext);
     return (
       <div>
         <h2>Your Cart</h2>
         <ul>
           {cart.map((item, index) => (
             <li key={index}>
               {item} <button onClick={() => removeFromCart(item)}>Remove</button>
             </li>
           ))}
         </ul>
       </div>
     );
   }

   function App() {
     const { addToCart } = useContext(CartContext);
     const items = ['Apple', 'Banana', 'Orange'];

     return (
       <div>
         <h1>Shop</h1>
         <ul>
           {items.map((item) => (
             <li key={item}>
               {item} <button onClick={() => addToCart(item)}>Add to Cart</button>
             </li>
           ))}
         </ul>
         <Cart />
       </div>
     );
   }

   export default function MainApp() {
     return (
       <CartProvider>
         <App />
       </CartProvider>
     );
   }
   ```
   **Explanation:**
   This example illustrates a global state for cart management using the Context API. The `CartProvider` component manages the cart state and provides functions to add and remove items from the cart. The `Cart` component consumes the context to display the cart items and includes buttons to remove items. The `App` component includes buttons to add items to the cart.

**Online Resources:**
- [React Context for State Management](https://www.taniarascia.com/using-context-for-state-management-in-react/)
- [React Context API by Example](https://kentcdodds.com/blog/how-to-use-react-context-effectively)

**Code to Practice and Expected Output:**

1. **Global State for User Authentication:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const AuthContext = createContext();

   function AuthProvider({ children }) {
     const [user, setUser] = useState(null);

     const login = (userData) => setUser(userData);
     const logout = () => setUser(null);

     return (
       <AuthContext.Provider value={{ user, login, logout }}>
         {children}
       </AuthContext.Provider>
     );
   }

   function UserProfile() {
     const { user, logout } = useContext(AuthContext);
     return user ? (
       <div>
         <p>Welcome, {user.name}</p>
         <button onClick={logout}>Logout</button>
       </div>
     ) : (
       <p>Please log in.</p>
     );
   }

   function App() {
     const { login } = useContext(AuthContext);
     const mockUser = { name: 'John Doe', email: 'john.doe@example.com' };

     return (
       <div>
         <button onClick={() => login(mockUser)}>Login as John Doe</button>
         <UserProfile />
       </div>
     );
   }

   export default function MainApp() {
     return (
       <AuthProvider>
         <App />
       </AuthProvider>
     );
   }
   ```
   **Expected Output:**
   A component that allows logging in and out, displaying the user's name when logged in and a login prompt when not.

2. **Global State for Theme Management:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const ThemeContext = createContext();

   function ThemeProvider({ children }) {
     const [theme, setTheme] = useState('light');

     const toggleTheme = () => {
       setTheme((prevTheme) => (prevTheme === 'light' ? 'dark' : 'light'));
     };

     return (
       <ThemeContext.Provider value={{ theme, toggleTheme }}>
         {children}
       </ThemeContext.Provider>
     );
   }

   function ThemedComponent() {
     const { theme, toggleTheme } = useContext(ThemeContext);
     return (
       <div style={{ background: theme === 'light' ? '#fff' : '#333', color: theme === 'light' ? '#000' : '#fff' }}>
         <p>The current theme is {theme}</p>
         <button onClick={toggleTheme}>Toggle Theme</button>
       </div>
     );
   }

   export default function MainApp() {
     return (
       <ThemeProvider>
         <ThemedComponent />
       </ThemeProvider>
     );
   }
   ```


   **Expected Output:**
   A component that displays the current theme and a button to toggle between light and dark themes. The theme state is managed using the Context API.

3. **Global State for Cart Management:**
   ```javascript
   import React, { createContext, useState, useContext } from 'react';

   const CartContext = createContext();

   function CartProvider({ children }) {
     const [cart, setCart] = useState([]);

     const addToCart = (item) => setCart((prevCart) => [...prevCart, item]);
     const removeFromCart = (item) => setCart((prevCart) => prevCart.filter((i) => i !== item));

     return (
       <CartContext.Provider value={{ cart, addToCart, removeFromCart }}>
         {children}
       </CartContext.Provider>
     );
   }

   function Cart() {
     const { cart, removeFromCart } = useContext(CartContext);
     return (
       <div>
         <h2>Your Cart</h2>
         <ul>
           {cart.map((item, index) => (
             <li key={index}>
               {item} <button onClick={() => removeFromCart(item)}>Remove</button>
             </li>
           ))}
         </ul>
       </div>
     );
   }

   function App() {
     const { addToCart } = useContext(CartContext);
     const items = ['Apple', 'Banana', 'Orange'];

     return (
       <div>
         <h1>Shop</h1>
         <ul>
           {items.map((item) => (
             <li key={item}>
               {item} <button onClick={() => addToCart(item)}>Add to Cart</button>
             </li>
           ))}
         </ul>
         <Cart />
       </div>
     );
   }

   export default function MainApp() {
     return (
       <CartProvider>
         <App />
       </CartProvider>
     );
   }
   ```
   **Expected Output:**
   A shopping cart system where items can be added to and removed from the cart. The cart state is managed globally using the Context API.

### Task 15: Study Advanced Form Handling Techniques

#### Task 1: Managing Form State with Controlled Components

**Explanation:**
In React, controlled components are form elements where the form data is handled by the React component. The component's state controls the form fields, making it easier to handle complex forms. Controlled components provide more control over the form's behavior, validation, and state management, as each input's value is set and updated through React's state.

By using controlled components, you can ensure that the form inputs always reflect the state of your React component. This approach allows you to validate input values, format user input, and perform other operations before setting the state. Controlled components are useful for handling user input in a predictable and consistent manner, especially in large and complex forms.

**Online Resources:**
- [React Controlled Components](https://reactjs.org/docs/forms.html#controlled-components)
- [Managing Form State in React](https://blog.logrocket.com/the-best-way-to-manage-your-form-state-in-react/)

**Examples to Practice:**

1. **Basic Controlled Input:**
   ```javascript
   import React, { useState } from 'react';

   function BasicForm() {
     const [name, setName] = useState('');

     const handleChange = (event) => {
       setName(event.target.value);
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       alert(`Submitted name: ${name}`);
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           Name:
           <input type="text" value={name} onChange={handleChange} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default BasicForm;
   ```
   **Explanation:**
   This example demonstrates a basic controlled input form. The input field's value is controlled by the React state (`name`). The `handleChange` function updates the state as the user types, and the `handleSubmit` function handles form submission, displaying an alert with the submitted name.

2. **Controlled Form with Multiple Inputs:**
   ```javascript
   import React, { useState } from 'react';

   function MultiInputForm() {
     const [formData, setFormData] = useState({ firstName: '', lastName: '' });

     const handleChange = (event) => {
       const { name, value } = event.target;
       setFormData({ ...formData, [name]: value });
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       alert(`Submitted: ${formData.firstName} ${formData.lastName}`);
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           First Name:
           <input type="text" name="firstName" value={formData.firstName} onChange={handleChange} />
         </label>
         <label>
           Last Name:
           <input type="text" name="lastName" value={formData.lastName} onChange={handleChange} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default MultiInputForm;
   ```
   **Explanation:**
   This example handles a form with multiple inputs using controlled components. The `formData` state object holds the values of the input fields. The `handleChange` function updates the corresponding field in the `formData` state. The `handleSubmit` function alerts the submitted data when the form is submitted.

3. **Form Validation with Controlled Components:**
   ```javascript
   import React, { useState } from 'react';

   function ValidatedForm() {
     const [email, setEmail] = useState('');
     const [error, setError] = useState('');

     const handleChange = (event) => {
       const { value } = event.target;
       setEmail(value);

       if (!value.includes('@')) {
         setError('Email must include "@"');
       } else {
         setError('');
       }
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       if (!error) {
         alert(`Submitted email: ${email}`);
       }
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           Email:
           <input type="email" value={email} onChange={handleChange} />
         </label>
         {error && <p style={{ color: 'red' }}>{error}</p>}
         <button type="submit" disabled={!!error}>Submit</button>
       </form>
     );
   }

   export default ValidatedForm;
   ```
   **Explanation:**
   This example demonstrates form validation with controlled components. The `email` state holds the input value, and the `error` state holds any validation errors. The `handleChange` function validates the input as the user types, and the `handleSubmit` function prevents submission if there are errors.

**Online Resources:**
- [React Form Validation](https://www.telerik.com/blogs/react-form-validation)
- [Handling Forms in React](https://flaviocopes.com/react-forms/)

**Code to Practice and Expected Output:**

1. **Basic Controlled Input:**
   ```javascript
   import React, { useState } from 'react';

   function BasicForm() {
     const [name, setName] = useState('');

     const handleChange = (event) => {
       setName(event.target.value);
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       alert(`Submitted name: ${name}`);
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           Name:
           <input type="text" value={name} onChange={handleChange} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default BasicForm;
   ```
   **Expected Output:**
   A simple form that allows the user to enter a name and submit it. An alert displays the submitted name.

2. **Controlled Form with Multiple Inputs:**
   ```javascript
   import React, { useState } from 'react';

   function MultiInputForm() {
     const [formData, setFormData] = useState({ firstName: '', lastName: '' });

     const handleChange = (event) => {
       const { name, value } = event.target;
       setFormData({ ...formData, [name]: value });
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       alert(`Submitted: ${formData.firstName} ${formData.lastName}`);
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           First Name:
           <input type="text" name="firstName" value={formData.firstName} onChange={handleChange} />
         </label>
         <label>
           Last Name:
           <input type="text" name="lastName" value={formData.lastName} onChange={handleChange} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default MultiInputForm;
   ```
   **Expected Output:**
   A form with two input fields (first name and last name) that displays an alert with the submitted names upon form submission.

3. **Form Validation with Controlled Components:**
   ```javascript
   import React, { useState } from 'react';

   function ValidatedForm() {
     const [email, setEmail] = useState('');
     const [error, setError] = useState('');

     const handleChange = (event) => {
       const { value } = event.target;
       setEmail(value);

       if (!value.includes('@')) {
         setError('Email must include "@"');
       } else {
         setError('');
       }
     };

     const handleSubmit = (event) => {
       event.preventDefault();
       if (!error) {
         alert(`Submitted email: ${email}`);
       }
     };

     return (
       <form onSubmit={handleSubmit}>
         <label>
           Email:
           <input type="email" value={email} onChange={handleChange} />
         </label>
         {error && <p style={{ color: 'red' }}>{error}</p>}
         <button type="submit" disabled={!!error}>Submit</button>
       </form>
     );
   }

   export default ValidatedForm;
   ```
   **Expected Output:**
   A form with an email input field that validates the input. If the email does not contain '@', an error message is displayed, and the form cannot be submitted.

#### Task 2: Handling Forms with Formik and Yup

**Explanation:**
Formik is a popular library for managing form state in React applications. It simplifies form handling by providing a set of hooks and components to manage form state, validation, and submission. Formik integrates seamlessly with Yup, a JavaScript schema builder for value parsing and validation. Together, Formik and Yup provide a powerful combination for building robust, maintainable forms.

Using Formik, you can manage form state and validation without writing much boilerplate code. Formik's `useFormik` hook or `Formik` component manages the form state, while Yup schemas define the validation rules. This separation of concerns makes the code more modular and easier to maintain. Additionally, Formik provides built-in support for handling form submission and errors, making it a comprehensive solution for form management.

**Online Resources:**
- [Formik Documentation](https://formik.org/docs/overview)
- [Yup Documentation](https://github.com/jquense/yup)

**Examples to Practice:**

1. **Basic Form with Formik:**
  

 ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function BasicFormikForm() {
     const formik = useFormik({
       initialValues: {
         name: '',
       },
       onSubmit: (values) => {
         alert(`Submitted name: ${values.name}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Name:
           <input type="text" name="name" onChange={formik.handleChange} value={formik.values.name} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default BasicFormikForm;
   ```
   **Explanation:**
   This example demonstrates a basic form using Formik. The `useFormik` hook manages the form state and handles the form submission. The `handleChange` method updates the form state, and the `handleSubmit` method triggers the submission logic.

2. **Form with Formik and Yup Validation:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function FormikYupForm() {
     const formik = useFormik({
       initialValues: {
         email: '',
       },
       validationSchema: Yup.object({
         email: Yup.string().email('Invalid email address').required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted email: ${values.email}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default FormikYupForm;
   ```
   **Explanation:**
   This example shows how to integrate Yup validation with Formik. The `validationSchema` property defines the validation rules using Yup. The form displays validation errors when the input does not meet the validation criteria, such as an invalid email address.

3. **Complex Form with Formik and Yup:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function ComplexFormikForm() {
     const formik = useFormik({
       initialValues: {
         firstName: '',
         lastName: '',
         email: '',
       },
       validationSchema: Yup.object({
         firstName: Yup.string().max(15, 'Must be 15 characters or less').required('Required'),
         lastName: Yup.string().max(20, 'Must be 20 characters or less').required('Required'),
         email: Yup.string().email('Invalid email address').required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName} ${values.email}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName ? <p style={{ color: 'red' }}>{formik.errors.firstName}</p> : null}
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName ? <p style={{ color: 'red' }}>{formik.errors.lastName}</p> : null}
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default ComplexFormikForm;
   ```
   **Explanation:**
   This example demonstrates a more complex form with multiple fields and validation rules. Each input field has its validation schema defined using Yup. The form shows error messages for each field when the validation criteria are not met. The `useFormik` hook handles the form state and submission.

**Online Resources:**
- [Handling Forms in React with Formik](https://blog.bitsrc.io/handling-forms-in-react-using-formik-and-yup-47a97e5eab5b)
- [Formik and Yup Tutorial](https://dev.to/milu_franz/how-to-use-formik-and-yup-in-react-js-2b7e)

**Code to Practice and Expected Output:**

1. **Basic Form with Formik:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function BasicFormikForm() {
     const formik = useFormik({
       initialValues: {
         name: '',
       },
       onSubmit: (values) => {
         alert(`Submitted name: ${values.name}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Name:
           <input type="text" name="name" onChange={formik.handleChange} value={formik.values.name} />
         </label>
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default BasicFormikForm;
   ```
   **Expected Output:**
   A form that allows the user to enter a name and submit it using Formik. An alert displays the submitted name.

2. **Form with Formik and Yup Validation:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function FormikYupForm() {
     const formik = useFormik({
       initialValues: {
         email: '',
       },
       validationSchema: Yup.object({
         email: Yup.string().email('Invalid email address').required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted email: ${values.email}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default FormikYupForm;
   ```
   **Expected Output:**
   A form that validates the email input using Yup and displays error messages. An alert shows the submitted email if the validation passes.

3. **Complex Form with Formik and Yup:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function ComplexFormikForm() {
     const formik = useFormik({
       initialValues: {
         firstName: '',
         lastName: '',
         email: '',
       },
       validationSchema: Yup.object({
         firstName: Yup.string().max(15, 'Must be 15 characters or less').required('Required'),
         lastName: Yup.string().max(20, 'Must be 20 characters or less').required('Required'),
         email: Yup.string().email('Invalid email address').required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName} ${values.email}`);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName ? <p style={{ color: 'red' }}>{formik.errors.firstName}</p> : null}
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName ? <p style={{ color: 'red' }}>{formik.errors.lastName}</p> : null}
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit">Submit</button>
       </form>
     );
   }

   export default ComplexFormikForm;
   ```
   **Expected Output:**
   A complex form with multiple fields and validation using Formik and Yup. Error messages are displayed for invalid inputs, and an alert shows the submitted data if validation passes.

#### Task 3: Handling Form Submissions and Errors

**Explanation:**
Handling form submissions and errors is a crucial aspect of form management in React applications. Proper handling ensures a smooth user experience by providing immediate feedback and guiding users to correct their input. Using libraries like Formik, you can manage form state, handle submissions, and display validation errors effectively.

Formik simplifies form submission handling by providing built-in methods to manage submission state and errors. It offers functions like `handleSubmit` to manage form submissions and `setFieldError

` to handle field-specific errors. By integrating these methods, you can ensure that your forms handle submissions and errors gracefully, providing a better user experience.

**Online Resources:**
- [Handling Form Submissions with Formik](https://formik.org/docs/guides/form-submission)
- [Error Handling with Formik](https://formik.org/docs/guides/validation)

**Examples to Practice:**

1. **Basic Form Submission Handling:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikSubmissionForm() {
     const formik = useFormik({
       initialValues: {
         name: '',
       },
       onSubmit: (values, { setSubmitting }) => {
         setTimeout(() => {
           alert(`Submitted name: ${values.name}`);
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Name:
           <input type="text" name="name" onChange={formik.handleChange} value={formik.values.name} />
         </label>
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikSubmissionForm;
   ```
   **Explanation:**
   This example demonstrates basic form submission handling with Formik. The `onSubmit` method simulates a submission delay and updates the submission state. The form displays a "Submitting..." button state while the submission is in progress.

2. **Form Submission with Error Handling:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikErrorHandlingForm() {
     const formik = useFormik({
       initialValues: {
         email: '',
       },
       validate: (values) => {
         const errors = {};
         if (!values.email) {
           errors.email = 'Required';
         } else if (!/\S+@\S+\.\S+/.test(values.email)) {
           errors.email = 'Invalid email address';
         }
         return errors;
       },
       onSubmit: (values, { setSubmitting }) => {
         setTimeout(() => {
           if (values.email === 'test@test.com') {
             alert('This email is already taken');
           } else {
             alert(`Submitted email: ${values.email}`);
           }
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikErrorHandlingForm;
   ```
   **Explanation:**
   This example shows form submission with error handling using Formik. The `validate` function performs client-side validation, and the `onSubmit` method simulates server-side validation, checking for an existing email and displaying an appropriate message.

3. **Handling Server-Side Errors:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikServerErrorHandlingForm() {
     const formik = useFormik({
       initialValues: {
         username: '',
       },
       validate: (values) => {
         const errors = {};
         if (!values.username) {
           errors.username = 'Required';
         }
         return errors;
       },
       onSubmit: (values, { setSubmitting, setErrors }) => {
         setTimeout(() => {
           if (values.username === 'taken') {
             setErrors({ username: 'Username already taken' });
           } else {
             alert(`Submitted username: ${values.username}`);
           }
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Username:
           <input type="text" name="username" onChange={formik.handleChange} value={formik.values.username} />
         </label>
         {formik.errors.username ? <p style={{ color: 'red' }}>{formik.errors.username}</p> : null}
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikServerErrorHandlingForm;
   ```
   **Explanation:**
   This example demonstrates handling server-side errors in a Formik form. The `onSubmit` method simulates a server-side validation check for a taken username and updates the form errors accordingly. The form shows error messages based on the server response.

**Online Resources:**
- [Formik Guide to Form Submission](https://formik.org/docs/guides/form-submission)
- [Error Handling in Formik](https://formik.org/docs/guides/validation)

**Code to Practice and Expected Output:**

1. **Basic Form Submission Handling:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikSubmissionForm() {
     const formik = useFormik({
       initialValues: {
         name: '',
       },
       onSubmit: (values, { setSubmitting }) => {
         setTimeout(() => {
           alert(`Submitted name: ${values.name}`);
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Name:
           <input type="text" name="name" onChange={formik.handleChange} value={formik.values.name} />
         </label>
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikSubmissionForm;
   ```
   **Expected Output:**
   A form that handles submissions and displays a "Submitting..." button state while submission is in progress. An alert shows the submitted name after a delay.

2. **Form Submission with Error Handling:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikErrorHandlingForm() {
     const formik = useFormik({
       initialValues: {
         email: '',
       },
       validate: (values) => {
         const errors = {};
         if (!values.email) {
           errors.email = 'Required';
         } else if (!/\S+@\S+\.\S+/.test(values.email)) {
           errors.email = 'Invalid email address';
         }
         return errors;
       },
       onSubmit: (values, { setSubmitting }) => {
         setTimeout(() => {
           if (values.email === 'test@test.com') {
             alert('This email is already taken');
           } else {
             alert(`Submitted email: ${values.email}`);
           }
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Email:
           <input type="email" name="email" onChange={formik.handleChange} value={formik.values.email} />
         </label>
         {formik.errors.email ? <p style={{ color: 'red' }}>{formik.errors.email}</p> : null}
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikErrorHandlingForm;
   ```
   **Expected Output:**
   A form that validates the email input and handles submission errors. An alert shows the submitted email or an error message if the email is already taken.

3. **Handling Server-Side Errors:**
   ```javascript
   import React from 'react';
   import { useFormik } from 'formik';

   function FormikServerErrorHandlingForm() {
     const formik = useFormik({
       initialValues: {
         username: '',
       },
       validate: (values) => {
         const errors = {};
         if (!values.username) {
           errors.username = 'Required';
         }
         return errors;
       },
       onSubmit: (values, { setSubmitting, setErrors }) => {
         setTimeout(() => {
           if (values.username === 'taken') {
             setErrors({ username: 'Username already taken' });
           } else {
             alert(`Submitted username: ${values.username}`);
           }
           setSubmitting(false);
         }, 500);
       },
     });

     return (
       <form onSubmit={formik.handleSubmit}>
         <label>
           Username:
           <input type="text" name="username" onChange={formik.handleChange} value={formik.values.username} />
         </label>
         {formik.errors.username ? <p style={{ color: 'red' }}>{formik.errors.username}</p> : null}
         <button type="submit" disabled={formik.isSubmitting}>
           {formik.isSubmitting ? 'Submitting...' : 'Submit'}
         </button>
       </form>
     );
   }

   export default FormikServerErrorHandlingForm;
   ```
   **Expected Output:**
   A form that handles server-side validation errors for the username input. An alert shows the submitted username or an error message if the username is already taken.

### Task 16: Implement Multi-Step Forms with Formik

#### Task 1: Building Multi-Step Forms

**Explanation:**
Multi-step forms break down a lengthy form into multiple steps, making the process less overwhelming and more user-friendly. By segmenting the form into logical sections, users can focus on one part of the form at a time, which can reduce errors and improve completion rates. In React, multi-step forms can be managed effectively using Formik, a popular library for form handling, which offers easy-to-use state management and validation.

To build a multi-step form with Formik, you need to manage the state for the current step and handle form data across different steps. This involves creating separate components for each step and using Formik's state management to keep track of the form values and validation errors. The state for the current step determines which form component is displayed, and form submissions are handled at the end of the multi-step process to gather all data.

**Online Resources:**
- [Formik Multi-Step Form Example](https://formik.org/docs/examples/with-redux)
- [Creating a Multi-Step Form with Formik](https://www.smashingmagazine.com/2020/10/creating-multistep-form-react/)

**Examples to Practice:**

1. **Basic Multi-Step Form with Formik:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function MultiStepForm() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '' },
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default MultiStepForm;
   ```
   **Explanation:**
   This example shows a basic multi-step form with Formik. The form consists of two steps: the first step collects the user's first name, and the second step collects the last name. The `MultiStepForm` component manages the current step and passes the Formik instance to each step component. The form data is submitted when the user reaches the final step and clicks the submit button.

2. **Multi-Step Form with Validation:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName && <p style={{ color: 'red' }}>{formik.errors.firstName}</p>}
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName && <p style={{ color: 'red' }}>{formik.errors.lastName}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function MultiStepFormWithValidation() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '' },
       validationSchema: Yup.object({
         firstName: Yup.string().required('Required'),
         lastName: Yup.string().required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default MultiStepFormWithValidation;
   ```
   **Explanation:**
   This example extends the basic multi-step form by adding validation with Yup. Each step component displays validation errors if the input is invalid. The `validationSchema` defines the validation rules for the form fields. The form data is validated at each step before allowing the user to proceed.

3. **Complex Multi-Step Form with Conditional Steps:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName && <p style={{ color: 'red' }}>{formik.errors.firstName}</p>}
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, next, previous }) {
     return (
       <div>
         <label>
           Age:
           <input type="number" name="age" onChange={formik.handleChange} value={formik.values.age} />
         </label>
         {formik.errors.age && <p style={{ color: 'red' }}>{formik.errors.age}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step3({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName && <p style={{ color: 'red' }}>{formik.errors.lastName}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function ComplexMultiStepForm() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '', age: '' },
       validationSchema: Yup.object({
         firstName: Yup.string().required('Required'),
         lastName: Yup.string().required('Required'),
         age: Yup.number().required('Required').min(18, 'Must be at least 18'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName} ${values.age}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} next={next} previous={previous} />}
         {step === 3 && <Step3 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default ComplexMultiStepForm;
   ```
   **Explanation:**
   This example demonstrates a complex multi-step form with conditional steps. The form includes an additional step for collecting the user's age. The `validationSchema` includes validation rules for the age field. The form dynamically progresses through the steps, and each step includes navigation buttons to move forward and backward.

**Online Resources:**
- [Formik Multi-Step Form Tutorial](https://www.smashingmagazine.com/2020/10/creating-multistep-form-react/)
- [Building Multi-Step Forms with Formik](https://dev.to/

tnzk/using-formik-to-build-multi-step-forms-in-react-7bh)

**Code to Practice and Expected Output:**

1. **Basic Multi-Step Form with Formik:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function MultiStepForm() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '' },
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default MultiStepForm;
   ```
   **Expected Output:**
   A multi-step form that collects the user's first and last names. The form includes navigation buttons to move between steps and submits the data when the user completes the final step.

2. **Multi-Step Form with Validation:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName && <p style={{ color: 'red' }}>{formik.errors.firstName}</p>}
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName && <p style={{ color: 'red' }}>{formik.errors.lastName}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function MultiStepFormWithValidation() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '' },
       validationSchema: Yup.object({
         firstName: Yup.string().required('Required'),
         lastName: Yup.string().required('Required'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default MultiStepFormWithValidation;
   ```
   **Expected Output:**
   A multi-step form with validation that collects the user's first and last names. The form displays validation errors and includes navigation buttons to move between steps. The data is submitted when the user completes the final step.

3. **Complex Multi-Step Form with Conditional Steps:**
   ```javascript
   import React, { useState } from 'react';
   import { useFormik } from 'formik';
   import * as Yup from 'yup';

   function Step1({ formik, next }) {
     return (
       <div>
         <label>
           First Name:
           <input type="text" name="firstName" onChange={formik.handleChange} value={formik.values.firstName} />
         </label>
         {formik.errors.firstName && <p style={{ color: 'red' }}>{formik.errors.firstName}</p>}
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step2({ formik, next, previous }) {
     return (
       <div>
         <label>
           Age:
           <input type="number" name="age" onChange={formik.handleChange} value={formik.values.age} />
         </label>
         {formik.errors.age && <p style={{ color: 'red' }}>{formik.errors.age}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={next}>Next</button>
       </div>
     );
   }

   function Step3({ formik, previous, submit }) {
     return (
       <div>
         <label>
           Last Name:
           <input type="text" name="lastName" onChange={formik.handleChange} value={formik.values.lastName} />
         </label>
         {formik.errors.lastName && <p style={{ color: 'red' }}>{formik.errors.lastName}</p>}
         <button type="button" onClick={previous}>Previous</button>
         <button type="button" onClick={submit}>Submit</button>
       </div>
     );
   }

   function ComplexMultiStepForm() {
     const [step, setStep] = useState(1);
     const formik = useFormik({
       initialValues: { firstName: '', lastName: '', age: '' },
       validationSchema: Yup.object({
         firstName: Yup.string().required('Required'),
         lastName: Yup.string().required('Required'),
         age: Yup.number().required('Required').min(18, 'Must be at least 18'),
       }),
       onSubmit: (values) => {
         alert(`Submitted: ${values.firstName} ${values.lastName} ${values.age}`);
       },
     });

     const next = () => setStep(step + 1);
     const previous = () => setStep(step - 1);
     const submit = () => formik.handleSubmit();

     return (
       <form>
         {step === 1 && <Step1 formik={formik} next={next} />}
         {step === 2 && <Step2 formik={formik} next={next} previous={previous} />}
         {step === 3 && <Step3 formik={formik} previous={previous} submit={submit} />}
       </form>
     );
   }

   export default ComplexMultiStepForm;
   ```
   **Expected Output:**
   A complex multi-step form with conditional steps that collects the user's first name, age, and last name. The form includes validation for each step and navigation buttons to move between steps. The data is submitted when the user completes the final step.

### Task 17: Study Advanced UI/UX Design Principles

#### Task 1: Designing for Accessibility

**Explanation:**
Designing for accessibility ensures that your web applications are usable by people with various disabilities, including visual, auditory, motor, and cognitive impairments. Accessibility features, such as keyboard navigation, screen reader support, and color contrast adjustments, help make your application inclusive to all users. Following accessibility standards, like the Web Content Accessibility Guidelines (WCAG), is crucial for creating an accessible web.

Accessibility in UI/UX design also involves considering the usability of your application for users with temporary disabilities or situational limitations. By implementing best practices like providing alt text for images, ensuring sufficient color contrast, and enabling keyboard navigation, you can create a more inclusive user experience. Tools like screen readers, accessibility checkers, and color contrast analyzers can help you test and improve your application's accessibility.

**Online Resources:**
- [Web Content Accessibility Guidelines (WCAG)](https://www.w3.org/WAI/standards-guidelines/wcag/)
- [Accessibility in React Applications](https://reactjs.org/docs/accessibility.html)

**Examples to Practice:**

1. **Implementing Keyboard Navigation:**
   ```javascript
   import React from 'react';

   function AccessibleButton() {
     return (
       <button
         onKeyDown={(e) => {
           if (e.key === 'Enter' || e.key === ' ') {
             e.preventDefault();
             // Handle button action
           }
         }}
       >
         Accessible Button
       </button>
     );
   }

   export default AccessibleButton;
   ```
   **Explanation:**
   This example demonstrates how to implement keyboard navigation for a button component. The `onKeyDown` event handler checks for the 'Enter' or 'Space' key and performs the button action accordingly. This ensures that users who rely on keyboard navigation can interact with the button.

2. **Providing Alt Text for Images:**
   ```javascript
   import React from 'react';

   function AccessibleImage() {
     return (
       <img src="example.jpg" alt="Description of the image" />
     );
   }

   export default AccessibleImage;
   ```
   **Explanation:**
   This example shows how to provide alt text for an image. The `alt` attribute describes the content of the image, which is essential for screen readers. This practice ensures that visually impaired users can understand the context of the image.

3. **Ensuring Sufficient Color Contrast:**
   ```javascript
   import React from 'react';

   function HighContrastText() {
     const style = {
       color: '#000', // Black text
       backgroundColor: '#fff', // White background
       padding: '10px',
     };

     return (
       <div style={style}>
         High Contrast Text for Better Readability
       </div>
     );
   }

   export default HighContrastText;
   ```
   **Explanation:**
   This example ensures sufficient color contrast between the text and background. High contrast improves readability for users with visual impairments. The black text on a white background provides a clear and distinct contrast, adhering to accessibility guidelines.

**Online Resources:**
- [W3C Accessibility Guidelines](https://www.w3.org/WAI/standards-guidelines/)
- [Accessible Rich Internet Applications (ARIA)](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA)

#### Task 2: Creating Responsive Design

**Explanation:**
Responsive design ensures that your web application looks and functions well on various devices and screen sizes. This approach involves using flexible grids, fluid images, and media queries to adapt the layout to different viewport sizes. A responsive design provides an optimal user experience, whether the user is on a desktop, tablet, or smartphone.

Creating a responsive design involves a mobile-first approach, where you design for the smallest screen size first and progressively enhance the design for larger screens. Techniques such as CSS Flexbox, Grid, and media queries are essential for building responsive layouts. Ensuring that touch targets are appropriately sized and spacing is adequate for touch interactions is also critical for mobile usability.

**Online Resources:**
- [Responsive Web Design Basics](https://developers.google.com/web/fundamentals/design-and-ux/responsive)
- [CSS Tricks: A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

**Examples to Practice:**

1. **Using CSS Flexbox for Responsive Layout:**
   ```html
   <style>
     .container {
       display: flex;
       flex-wrap: wrap;
     }
     .item {
       flex: 1 1 200px;
       margin: 10px;
       background-color: #f0f0f0;
       padding: 20px;
     }
   </style>
   <div class="container">
     <div class="item">Item 1</div>
     <div class="item">Item 2</div>
     <div class="item">Item 3</div>
   </div>
   ```
   **Explanation:**
   This example uses CSS Flexbox to create a responsive layout. The `.container` class sets the display to flex and allows items to wrap onto the next line. The `.item` class defines flex-grow, flex-shrink, and flex-basis properties, making the items responsive to different screen sizes.

2. **Creating a Responsive Grid with CSS Grid:**
   ```html
   <style>
     .grid-container {
       display: grid;
       grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
       gap: 10px;
     }
     .grid-item {
       background-color: #ddd;
       padding: 20px;
     }
   </style>
   <div class="grid-container">
     <div class="grid-item">Grid Item 1</div>
     <div class="grid-item">Grid Item 2</div>
     <div class="grid-item">Grid Item 3</div>
   </div>
   ```
   **Explanation:**
   This example creates a responsive grid layout using CSS Grid. The `grid-template-columns` property uses the `repeat` function and `minmax` to create flexible columns that adapt to different screen sizes. The grid items adjust their width based on the available space, ensuring a responsive design.

3. **Implementing Media Queries for Responsive Design:**
   ```html
   <style>
     .responsive-text {
       font-size: 16px;
     }
     @media (min-width: 600px) {
       .responsive-text {
         font-size: 18px;
       }
     }
     @media (min-width: 900px) {
       .responsive-text {
         font-size: 20px;
       }
     }
   </style>
   <div class="responsive-text">
     This text adjusts its size based on the screen width.
   </div>
   ```
   **Explanation:**
   This example demonstrates how to use media queries to create a responsive design. The `.responsive-text` class adjusts the font size based on the screen width. As the viewport width increases, the font size changes to provide an optimal reading experience.

**Online Resources:**
- [MDN Web Docs: Responsive Design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [A Complete Guide to Grid](https://css-tricks.com/snippets/css/complete-guide-grid/)

#### Task 3: Enhancing User Experience with Microinteractions

**Explanation:**
Microinteractions are small, subtle animations or feedback elements that enhance the user experience by providing visual cues and feedback on interactions. They can make the user interface feel more responsive and engaging, guiding users through tasks and making the interface more intuitive. Examples of microinteractions include button animations, hover effects, and form validation feedback.

Implementing microinteractions involves using CSS animations, transitions, and JavaScript to create responsive and interactive elements. Well-designed microinteractions can improve the overall usability of an application by making it clear when actions are recognized and completed. They add a layer of polish to the user interface, making the application feel more modern and professional.

**Online Resources:**
- [Microinteractions in UX Design](https://uxdesign.cc/microinteractions-6d8a42a4c1b8)
- [Creating Microinteractions with CSS and JavaScript](https://www.smashingmagazine.com/2019/04/microinteractions-css-animations/)

**Examples to Practice:**

1. **Button Hover Effect:**
   ```html
   <style>
     .button {
       padding: 10px 20px;
       background-color: #007bff;
       color: white;
       border: none;
       cursor: pointer;
       transition: background-color 0.3s ease;
     }
     .button:hover {
       background-color: #0056b3;
     }
   </style>
   <button class="button">Hover Me</button>
   ```
   **Explanation:**
   This example creates a hover effect for a button. The `transition` property defines the transition effect, and the `:hover` pseudo-class changes the background color when the user hovers over the button. This subtle effect enhances the user's interaction with the button.

2. **Form Validation Feedback:**
   ```html
   <style>
     .input {
       padding: 10px;
       border: 1px solid #ccc;
       transition: border-color 0.3s ease;
     }
     .input:invalid {
       border-color: #ff0000;
     }
   </style>
   <input class="input" type="text" required placeholder="Enter text">
   ```
   **Explanation:**
   This example provides form validation feedback using CSS. The `:invalid` pseudo-class changes the border

 color of the input field when the input is invalid. This visual feedback helps users understand when they need to correct their input.

3. **Loading Spinner Animation:**
   ```html
   <style>
     .spinner {
       width: 40px;
       height: 40px;
       border: 4px solid rgba(0, 0, 0, 0.1);
       border-top-color: #007bff;
       border-radius: 50%;
       animation: spin 1s linear infinite;
     }
     @keyframes spin {
       to {
         transform: rotate(360deg);
       }
     }
   </style>
   <div class="spinner"></div>
   ```
   **Explanation:**
   This example creates a loading spinner animation. The `@keyframes` rule defines the animation, and the `animation` property applies it to the spinner element. This microinteraction provides visual feedback during loading processes, enhancing the user experience by indicating that an action is in progress.

**Online Resources:**
- [CSS Animations and Transitions](https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Animations)
- [Animating with CSS Transitions](https://css-tricks.com/almanac/properties/t/transition/)

#### Task 4: Implementing Dark Mode

**Explanation:**
Dark mode is a popular design trend that provides a dark-themed user interface, reducing eye strain and saving battery life on OLED screens. Implementing dark mode involves creating a separate set of styles for the dark theme and allowing users to toggle between light and dark modes. This feature enhances the user experience by offering a comfortable viewing option in low-light environments.

To implement dark mode, you can use CSS variables to define colors and other styles that can be easily switched between light and dark themes. JavaScript can be used to handle the toggle functionality, saving the user's preference in local storage to persist the theme across sessions. This approach ensures a seamless and customizable experience for users.

**Online Resources:**
- [Implementing Dark Mode in React](https://blog.logrocket.com/the-complete-guide-to-implementing-dark-mode-in-react/)
- [Dark Mode in CSS](https://css-tricks.com/a-complete-guide-to-dark-mode-on-the-web/)

**Examples to Practice:**

1. **Basic Dark Mode Toggle:**
   ```html
   <style>
     body {
       --bg-color: #fff;
       --text-color: #000;
       background-color: var(--bg-color);
       color: var(--text-color);
       transition: background-color 0.3s, color 0.3s;
     }
     body.dark-mode {
       --bg-color: #121212;
       --text-color: #fff;
     }
   </style>
   <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
   <script>
     function toggleDarkMode() {
       document.body.classList.toggle('dark-mode');
     }
   </script>
   ```
   **Explanation:**
   This example demonstrates a basic dark mode toggle. CSS variables define the background and text colors, and the `dark-mode` class applies the dark theme styles. The JavaScript function toggles the `dark-mode` class on the `body` element, allowing users to switch between light and dark modes.

2. **Persisting Dark Mode Preference:**
   ```html
   <style>
     body {
       --bg-color: #fff;
       --text-color: #000;
       background-color: var(--bg-color);
       color: var(--text-color);
       transition: background-color 0.3s, color 0.3s;
     }
     body.dark-mode {
       --bg-color: #121212;
       --text-color: #fff;
     }
   </style>
   <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
   <script>
     function toggleDarkMode() {
       document.body.classList.toggle('dark-mode');
       localStorage.setItem('dark-mode', document.body.classList.contains('dark-mode'));
     }

     window.onload = () => {
       if (localStorage.getItem('dark-mode') === 'true') {
         document.body.classList.add('dark-mode');
       }
     }
   </script>
   ```
   **Explanation:**
   This example extends the basic dark mode toggle by persisting the user's preference in local storage. The `toggleDarkMode` function updates the local storage when the user toggles the dark mode. The script checks the stored preference on page load and applies the dark mode if it was previously enabled.

3. **Using CSS Variables for Theming:**
   ```html
   <style>
     :root {
       --bg-color-light: #fff;
       --text-color-light: #000;
       --bg-color-dark: #121212;
       --text-color-dark: #fff;
     }
     body {
       background-color: var(--bg-color-light);
       color: var(--text-color-light);
       transition: background-color 0.3s, color 0.3s;
     }
     body.dark-mode {
       background-color: var(--bg-color-dark);
       color: var(--text-color-dark);
     }
   </style>
   <button onclick="toggleDarkMode()">Toggle Dark Mode</button>
   <script>
     function toggleDarkMode() {
       document.body.classList.toggle('dark-mode');
       localStorage.setItem('dark-mode', document.body.classList.contains('dark-mode'));
     }

     window.onload = () => {
       if (localStorage.getItem('dark-mode') === 'true') {
         document.body.classList.add('dark-mode');
       }
     }
   </script>
   ```
   **Explanation:**
   This example uses CSS variables for theming, defining separate variables for light and dark modes. The `body` element's styles switch based on the presence of the `dark-mode` class, providing a clean and maintainable way to manage themes. The JavaScript functions handle toggling and persisting the dark mode preference.

**Online Resources:**
- [Dark Mode Design: Best Practices](https://www.smashingmagazine.com/2020/02/dark-mode-uimode/)
- [How to Implement Dark Mode on a Website](https://www.sitepoint.com/dark-mode/)

#### Task 5: Improving User Experience with Loading Indicators

**Explanation:**
Loading indicators provide visual feedback to users while content is being loaded or processed, improving the user experience by reducing uncertainty and frustration. They can be implemented using various techniques, such as spinners, progress bars, and skeleton screens. These indicators help users understand that the application is working and prevent them from assuming that it is unresponsive.

Implementing loading indicators involves using CSS animations, JavaScript, and conditional rendering to display the indicators during loading times. It's essential to ensure that loading indicators are visible and appropriately placed, so users know where the content will appear. Well-designed loading indicators can significantly enhance the perceived performance of an application.

**Online Resources:**
- [Creating Loading Spinners with CSS](https://css-tricks.com/creating-loading-spinners-with-css/)
- [Implementing Skeleton Screens](https://www.smashingmagazine.com/2020/04/skeleton-screens-react/)

**Examples to Practice:**

1. **CSS Loading Spinner:**
   ```html
   <style>
     .spinner {
       width: 40px;
       height: 40px;
       border: 4px solid rgba(0, 0, 0, 0.1);
       border-top-color: #007bff;
       border-radius: 50%;
       animation: spin 1s linear infinite;
     }
     @keyframes spin {
       to {
         transform: rotate(360deg);
       }
     }
   </style>
   <div class="spinner"></div>
   ```
   **Explanation:**
   This example creates a simple loading spinner using CSS. The `@keyframes` rule defines the spinning animation, and the `animation` property applies it to the spinner element. This spinner can be displayed while content is being loaded to indicate progress.

2. **JavaScript Loading Indicator:**
   ```html
   <style>
     .spinner {
       width: 40px;
       height: 40px;
       border: 4px solid rgba(0, 0, 0, 0.1);
       border-top-color: #007bff;
       border-radius: 50%;
       animation: spin 1s linear infinite;
       display: none;
     }
     @keyframes spin {
       to {
         transform: rotate(360deg);
       }
     }
   </style>
   <button onclick="loadData()">Load Data</button>
   <div class="spinner" id="spinner"></div>
   <div id="content"></div>
   <script>
     function loadData() {
       document.getElementById('spinner').style.display = 'block';
       setTimeout(() => {
         document.getElementById('spinner').style.display = 'none';
         document.getElementById('content').innerText = 'Data loaded';
       }, 2000);
     }
   </script>
   ```
   **Explanation:**
   This example uses JavaScript to show a loading spinner while data is being loaded. The `loadData` function displays the spinner, simulates a data loading delay with `setTimeout`, and hides the spinner once the data is loaded. This approach provides visual feedback to users during the loading process.

3. **Skeleton Screen for Content Loading:**
   ```html
   <style>
     .skeleton {
       background-color: #eee;
       border-radius: 4px;
       width: 100%;
       height: 20px;
       margin: 10px 0;
       animation: pulse 1.5s infinite;
    

 }
     @keyframes pulse {
       0% {
         background-color: #eee;
       }
       50% {
         background-color: #ddd;
       }
       100% {
         background-color: #eee;
       }
     }
   </style>
   <button onclick="loadContent()">Load Content</button>
   <div id="skeleton" class="skeleton"></div>
   <div id="realContent" style="display: none;">Content loaded</div>
   <script>
     function loadContent() {
       document.getElementById('skeleton').style.display = 'block';
       setTimeout(() => {
         document.getElementById('skeleton').style.display = 'none';
         document.getElementById('realContent').style.display = 'block';
       }, 2000);
     }
   </script>
   ```
   **Explanation:**
   This example implements a skeleton screen to indicate content loading. The `skeleton` class defines the appearance of the skeleton screen, and the `pulse` keyframes animation creates a pulsating effect. The `loadContent` function simulates content loading and switches from the skeleton screen to the actual content once loading is complete.

**Online Resources:**
- [UX Design: Loading Indicators](https://uxdesign.cc/loading-indicators-in-web-design-2b6c200772c5)
- [Improving UX with Skeleton Screens](https://medium.com/swlh/improving-user-experience-with-skeleton-screens-ec0f648ccdc9)

### Task 18: Implement Responsive and Adaptive UI

#### Task 1: Responsive Design Principles

**Explanation:**
Responsive design ensures that your web application adapts to various screen sizes and devices, providing an optimal user experience across desktops, tablets, and smartphones. This approach involves using flexible grid layouts, fluid images, and media queries to adjust the design based on the viewport size. By creating a responsive design, you ensure that content is readable, navigation is accessible, and interactive elements are usable regardless of the device being used.

Responsive design is crucial in today's multi-device world, where users expect seamless experiences whether they are on a mobile phone or a desktop computer. Techniques such as CSS Flexbox, Grid, and media queries enable developers to create layouts that adjust dynamically to different screen sizes. Implementing responsive design principles enhances the usability and accessibility of your web application, making it more inclusive and user-friendly.

**Online Resources:**
- [Responsive Web Design Basics](https://developers.google.com/web/fundamentals/design-and-ux/responsive)
- [CSS Tricks: A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

**Examples to Practice:**

1. **Using CSS Flexbox for Responsive Layout:**
   ```html
   <style>
     .container {
       display: flex;
       flex-wrap: wrap;
     }
     .item {
       flex: 1 1 200px;
       margin: 10px;
       background-color: #f0f0f0;
       padding: 20px;
     }
   </style>
   <div class="container">
     <div class="item">Item 1</div>
     <div class="item">Item 2</div>
     <div class="item">Item 3</div>
   </div>
   ```
   **Explanation:**
   This example demonstrates using CSS Flexbox to create a responsive layout. The `.container` class applies `display: flex` and `flex-wrap: wrap` to make the items wrap onto the next line when necessary. Each `.item` has flexible width and margin, ensuring they adjust to the available space.

2. **Creating a Responsive Grid with CSS Grid:**
   ```html
   <style>
     .grid-container {
       display: grid;
       grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
       gap: 10px;
     }
     .grid-item {
       background-color: #ddd;
       padding: 20px;
     }
   </style>
   <div class="grid-container">
     <div class="grid-item">Grid Item 1</div>
     <div class="grid-item">Grid Item 2</div>
     <div class="grid-item">Grid Item 3</div>
   </div>
   ```
   **Explanation:**
   This example creates a responsive grid layout using CSS Grid. The `grid-template-columns` property uses the `repeat` function with `minmax` to create flexible columns that adapt to different screen sizes. The grid items adjust their width based on the available space, ensuring a responsive design.

3. **Implementing Media Queries for Responsive Design:**
   ```html
   <style>
     .responsive-text {
       font-size: 16px;
     }
     @media (min-width: 600px) {
       .responsive-text {
         font-size: 18px;
       }
     }
     @media (min-width: 900px) {
       .responsive-text {
         font-size: 20px;
       }
     }
   </style>
   <div class="responsive-text">
     This text adjusts its size based on the screen width.
   </div>
   ```
   **Explanation:**
   This example demonstrates using media queries to create a responsive design. The `.responsive-text` class adjusts the font size based on the screen width. As the viewport width increases, the font size changes to provide an optimal reading experience.

**Online Resources:**
- [MDN Web Docs: Responsive Design](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
- [A Complete Guide to Grid](https://css-tricks.com/snippets/css/complete-guide-grid/)

#### Task 2: Adaptive Design Principles

**Explanation:**
Adaptive design creates layouts that are tailored to specific device types or screen sizes. Unlike responsive design, which uses fluid grids and media queries to adjust layouts dynamically, adaptive design involves creating distinct layouts for different devices. This approach ensures an optimal user experience by designing for the specific capabilities and limitations of each device type.

Adaptive design typically involves creating multiple fixed layouts that correspond to different screen sizes or breakpoints. When a user accesses the web application, the appropriate layout is served based on the device's screen size. This method provides more control over the design and can lead to better performance and user experience on specific devices, but it can also require more development and maintenance effort.

**Online Resources:**
- [Adaptive vs. Responsive Design](https://uxplanet.org/adaptive-vs-responsive-design-cc27d7b4e3c2)
- [Creating Adaptive Layouts in CSS](https://web.dev/adaptive-loading/)

**Examples to Practice:**

1. **Basic Adaptive Layout:**
   ```html
   <style>
     .container {
       display: none;
     }
     @media (min-width: 320px) and (max-width: 480px) {
       .container-mobile {
         display: block;
       }
     }
     @media (min-width: 481px) and (max-width: 768px) {
       .container-tablet {
         display: block;
       }
     }
     @media (min-width: 769px) {
       .container-desktop {
         display: block;
       }
     }
   </style>
   <div class="container container-mobile">Mobile Layout</div>
   <div class="container container-tablet">Tablet Layout</div>
   <div class="container container-desktop">Desktop Layout</div>
   ```
   **Explanation:**
   This example demonstrates a basic adaptive layout. Different `.container` classes are defined for mobile, tablet, and desktop layouts. Media queries are used to show the appropriate layout based on the screen size. This approach ensures that the layout is tailored to the specific device.

2. **Adaptive Navigation Menu:**
   ```html
   <style>
     .menu {
       display: flex;
       list-style: none;
       padding: 0;
     }
     .menu-item {
       margin: 0 10px;
     }
     @media (max-width: 600px) {
       .menu {
         flex-direction: column;
       }
       .menu-item {
         margin: 10px 0;
       }
     }
   </style>
   <ul class="menu">
     <li class="menu-item">Home</li>
     <li class="menu-item">About</li>
     <li class="menu-item">Contact</li>
   </ul>
   ```
   **Explanation:**
   This example shows an adaptive navigation menu. The `.menu` class displays menu items in a horizontal row by default. A media query is used to change the layout to a vertical column on smaller screens. This ensures that the navigation menu is accessible and easy to use on different devices.

3. **Adaptive Image Gallery:**
   ```html
   <style>
     .gallery {
       display: flex;
       flex-wrap: wrap;
     }
     .gallery-item {
       flex: 1 1 200px;
       margin: 10px;
     }
     @media (max-width: 600px) {
       .gallery-item {
         flex: 1 1 100%;
       }
     }
   </style>
   <div class="gallery">
     <div class="gallery-item">Image 1</div>
     <div class="gallery-item">Image 2</div>
     <div class="gallery-item">Image 3</div>
   </div>
   ```
   **Explanation:**
   This example creates an adaptive image gallery. The `.gallery` class uses Flexbox to display gallery items in a flexible grid. A media query adjusts the layout on smaller screens, making each item take up the full width. This ensures that the gallery looks good on all devices.

**Online Resources:**
- [Creating Adaptive Layouts](https://developers.google.com/web/fundamentals/design-and-ux/responsive)
- [Understanding Media Queries](https://developer.mozilla.org/en-US/docs/Web/CSS/Media_Queries/Using_media_queries)

#### Task 3: Implementing Responsive and Adaptive UI in React

**Explanation:**
Implementing responsive and adaptive UI in React involves using CSS techniques alongside React's component-based architecture to create layouts that adapt to different screen sizes and devices. You can use libraries like styled-components or CSS-in-JS solutions to manage styles within your React components. Additionally, tools like React Responsive can help detect screen size changes and adjust the UI accordingly.

Combining responsive and adaptive design principles in React ensures that your application provides an optimal user experience across various devices. By leveraging media queries, Flexbox, Grid, and JavaScript, you can create flexible and adaptable layouts. React's declarative nature and component-based structure make it easier to manage and reuse responsive and adaptive UI components.

**Online Resources:**
- [Responsive Design in React](https://www.smashingmagazine.com/2020/07/responsive-design-react/)
- [Styled-components Documentation](https://styled-components.com/)

**Examples to Practice:**

1. **Responsive Layout with Styled-components:**
   ```javascript
   import React from 'react';
   import styled from 'styled-components';

   const Container = styled.div`
     display: flex;
     flex-wrap: wrap;
   `;

  

 const Item = styled.div`
     flex: 1 1 200px;
     margin: 10px;
     background-color: #f0f0f0;
     padding: 20px;
   `;

   function ResponsiveLayout() {
     return (
       <Container>
         <Item>Item 1</Item>
         <Item>Item 2</Item>
         <Item>Item 3</Item>
       </Container>
     );
   }

   export default ResponsiveLayout;
   ```
   **Explanation:**
   This example demonstrates a responsive layout using styled-components in React. The `Container` and `Item` components use Flexbox properties to create a flexible and responsive layout. The items adjust their width based on the available space, ensuring a responsive design.

2. **Adaptive UI with Media Queries in React:**
   ```javascript
   import React from 'react';
   import styled from 'styled-components';

   const Container = styled.div`
     padding: 20px;
     @media (max-width: 600px) {
       background-color: lightblue;
     }
     @media (min-width: 601px) and (max-width: 900px) {
       background-color: lightgreen;
     }
     @media (min-width: 901px) {
       background-color: lightcoral;
     }
   `;

   function AdaptiveUI() {
     return <Container>Adaptive UI</Container>;
   }

   export default AdaptiveUI;
   ```
   **Explanation:**
   This example shows how to create an adaptive UI using media queries in styled-components. The `Container` component's background color changes based on the screen width, demonstrating how different styles can be applied for different screen sizes. This approach ensures the UI adapts to various devices.

3. **Using React Responsive for Conditional Rendering:**
   ```javascript
   import React from 'react';
   import { useMediaQuery } from 'react-responsive';

   function ResponsiveComponent() {
     const isMobile = useMediaQuery({ query: '(max-width: 600px)' });
     const isTablet = useMediaQuery({ query: '(min-width: 601px) and (max-width: 900px)' });
     const isDesktop = useMediaQuery({ query: '(min-width: 901px)' });

     return (
       <div>
         {isMobile && <div>Mobile View</div>}
         {isTablet && <div>Tablet View</div>}
         {isDesktop && <div>Desktop View</div>}
       </div>
     );
   }

   export default ResponsiveComponent;
   ```
   **Explanation:**
   This example uses the `react-responsive` library to conditionally render different components based on the screen size. The `useMediaQuery` hook detects the screen size and renders the appropriate view for mobile, tablet, or desktop devices. This approach ensures that the UI adapts to different devices dynamically.

**Online Resources:**
- [React Responsive Documentation](https://github.com/contra/react-responsive)
- [Styled-components Documentation](https://styled-components.com/)

### Task 19: Study Internationalization Best Practices

#### Task 1: Understanding Internationalization (i18n)

**Explanation:**
Internationalization (i18n) is the process of designing and developing applications that can be easily adapted to different languages and regions without requiring significant changes to the codebase. It involves separating localizable content, such as text and date formats, from the core logic of the application. This enables developers to add support for new languages and regions by simply adding new translations and configurations.

Implementing i18n involves using libraries and frameworks that provide tools for managing translations, formatting dates and numbers according to locale-specific conventions, and handling other localization needs. By following best practices for i18n, developers can create applications that are accessible to a global audience, improving user experience and expanding the potential user base.

**Online Resources:**
- [MDN Web Docs: Internationalization](https://developer.mozilla.org/en-US/docs/Web/Internationalization)
- [Internationalization in React](https://react.i18next.com/)

**Examples to Practice:**

1. **Using React-i18next for Basic Translation:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         welcome: "Welcome",
       },
     },
     fr: {
       translation: {
         welcome: "Bienvenue",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function App() {
     const { t } = useTranslation();

     return (
       <div>
         <h1>{t('welcome')}</h1>
         <button onClick={() => i18n.changeLanguage('fr')}>Change to French</button>
         <button onClick={() => i18n.changeLanguage('en')}>Change to English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates the use of React-i18next for basic translation. The `resources` object contains translations for English and French. The `useTranslation` hook is used to get the translation function `t`, which retrieves the appropriate translation based on the current language. Buttons are provided to switch between languages.

2. **Formatting Dates and Numbers Using Intl API:**
   ```javascript
   import React from 'react';

   function App() {
     const number = 1234567.89;
     const date = new Date();

     const formattedNumber = new Intl.NumberFormat('de-DE').format(number);
     const formattedDate = new Intl.DateTimeFormat('de-DE').format(date);

     return (
       <div>
         <p>Formatted Number: {formattedNumber}</p>
         <p>Formatted Date: {formattedDate}</p>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to format numbers and dates using the `Intl` API. The `Intl.NumberFormat` and `Intl.DateTimeFormat` constructors are used to format the number and date according to the 'de-DE' locale (German). This approach ensures that numbers and dates are displayed in a format appropriate for the user's locale.

3. **Handling Pluralization in React-i18next:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         item: "You have {{count}} item",
         item_plural: "You have {{count}} items",
       },
     },
     fr: {
       translation: {
         item: "Vous avez {{count}} élément",
         item_plural: "Vous avez {{count}} éléments",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function App() {
     const { t } = useTranslation();
     const itemCount = 3;

     return (
       <div>
         <p>{t('item', { count: itemCount })}</p>
         <button onClick={() => i18n.changeLanguage('fr')}>Change to French</button>
         <button onClick={() => i18n.changeLanguage('en')}>Change to English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example shows how to handle pluralization using React-i18next. The `resources` object includes translations for both singular and plural forms of the text. The `t` function automatically selects the correct form based on the `count` value provided. Buttons are provided to switch between languages.

**Online Resources:**
- [React-i18next Documentation](https://react.i18next.com/)
- [JavaScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)

#### Task 2: Implementing Localization (l10n)

**Explanation:**
Localization (l10n) refers to the process of adapting an application to meet the language and cultural preferences of a specific target market. This involves translating the user interface text, formatting dates and numbers according to local conventions, and addressing other cultural nuances such as currency symbols, time zones, and text direction. Localization ensures that the application is relevant and user-friendly for the target audience.

To implement localization, developers need to manage and store translations, format dates and numbers, and handle other locale-specific requirements. This can be achieved using libraries such as React-i18next for translation management and the `Intl` API for formatting. By implementing localization best practices, developers can create applications that provide a seamless and culturally appropriate experience for users in different regions.

**Online Resources:**
- [Localization Best Practices](https://www.w3.org/International/questions/qa-i18n)
- [Localizing Your App with React-i18next](https://medium.com/@nikolaymironov/localizing-your-app-with-react-i18next-8b8e8d3e8966)

**Examples to Practice:**

1. **Managing Translations with React-i18next:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         greeting: "Hello, {{name}}!",
       },
     },
     es: {
       translation: {
         greeting: "¡Hola, {{name}}!",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function App() {
     const { t } = useTranslation();

     return (
       <div>
         <p>{t('greeting', { name: 'John' })}</p>
         <button onClick={() => i18n.changeLanguage('es')}>Change to Spanish</button>
         <button onClick={() => i18n.changeLanguage('en')}>Change to English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to manage translations with React-i18next. The `resources` object contains translations for English and Spanish. The `useTranslation` hook retrieves the translation function `t`, which is used to display a personalized greeting. Buttons are provided to switch between languages.

2. **Formatting Currency with Intl API:**
   ```javascript
   import React from 'react';

   function App() {
     const amount = 1234.56;

     const formattedAmountUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
     const formattedAmountEUR = new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(amount);

     return (
       <div>
         <p>Amount in USD: {formattedAmountUSD}</p>
         <p>Amount in EUR: {formattedAmountEUR}</p>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to format currency using the `Intl` API. The `Intl.NumberFormat` constructor formats the amount according to the 'en-US' and 'de-DE' locales, displaying it in USD and EUR respectively. This approach ensures that currency amounts are formatted correctly for different regions.

3. **Handling Text Direction for RTL Languages:**
   ```javascript
   import React, { useEffect } from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         message: "This is a left-to-right language.",
       },
     },
     ar: {
       translation: {
         message: "هذه لغة من اليمين إلى اليسار.",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
    

 lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function App() {
     const { t } = useTranslation();

     useEffect(() => {
       document.body.dir = i18n.language === 'ar' ? 'rtl' : 'ltr';
     }, [i18n.language]);

     return (
       <div>
         <p>{t('message')}</p>
         <button onClick={() => i18n.changeLanguage('ar')}>Change to Arabic</button>
         <button onClick={() => i18n.changeLanguage('en')}>Change to English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example shows how to handle text direction for right-to-left (RTL) languages using React-i18next. The `useEffect` hook updates the `dir` attribute of the `body` element based on the current language. The `resources` object contains translations for English and Arabic, with the Arabic text displayed in RTL direction.

**Online Resources:**
- [React-i18next Handling RTL Languages](https://react.i18next.com/guides/handle-rtl-languages)
- [W3C Internationalization: Language Direction](https://www.w3.org/International/questions/qa-html-dir)

#### Task 3: Integrating Internationalization with Routing

**Explanation:**
Integrating internationalization with routing ensures that your web application can handle different languages and locales in the URL. This approach allows users to access the application in their preferred language by navigating to URLs with language prefixes or query parameters. It also makes it easier to manage localization and ensure that the correct language is loaded based on the URL.

To integrate internationalization with routing in a React application, you can use libraries like React Router along with React-i18next. By configuring routes to include language prefixes and updating the i18n language based on the URL, you can create a seamless multi-language experience. This approach ensures that users can easily switch between languages by changing the URL.

**Online Resources:**
- [Internationalization in React Router](https://react.i18next.com/latest/using-with-router)
- [React Router Documentation](https://reactrouter.com/)

**Examples to Practice:**

1. **Setting Up Routes with Language Prefixes:**
   ```javascript
   import React from 'react';
   import { BrowserRouter as Router, Route, Switch, Redirect } from 'react-router-dom';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         home: "Home",
         about: "About",
       },
     },
     es: {
       translation: {
         home: "Inicio",
         about: "Acerca de",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function Home() {
     const { t } = useTranslation();
     return <h1>{t('home')}</h1>;
   }

   function About() {
     const { t } = useTranslation();
     return <h1>{t('about')}</h1>;
   }

   function App() {
     return (
       <Router>
         <Switch>
           <Route path="/:lang(en|es)/home" component={Home} />
           <Route path="/:lang(en|es)/about" component={About} />
           <Redirect from="/" to="/en/home" />
         </Switch>
       </Router>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example sets up routes with language prefixes using React Router and React-i18next. The `Router` component defines routes with language prefixes (`en` or `es`) for the `Home` and `About` components. The `Redirect` component redirects the root URL to the default language (`en`). This setup ensures that the correct language is loaded based on the URL.

2. **Dynamically Changing Language Based on URL:**
   ```javascript
   import React, { useEffect } from 'react';
   import { BrowserRouter as Router, Route, Switch, useParams, useHistory } from 'react-router-dom';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         home: "Home",
         about: "About",
       },
     },
     es: {
       translation: {
         home: "Inicio",
         about: "Acerca de",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function LanguageWrapper({ children }) {
     const { lang } = useParams();
     const history = useHistory();

     useEffect(() => {
       if (['en', 'es'].includes(lang)) {
         i18n.changeLanguage(lang);
       } else {
         history.push('/en/home');
       }
     }, [lang, history]);

     return children;
   }

   function Home() {
     const { t } = useTranslation();
     return <h1>{t('home')}</h1>;
   }

   function About() {
     const { t } = useTranslation();
     return <h1>{t('about')}</h1>;
   }

   function App() {
     return (
       <Router>
         <LanguageWrapper>
           <Switch>
             <Route path="/:lang(en|es)/home" component={Home} />
             <Route path="/:lang(en|es)/about" component={About} />
             <Redirect from="/" to="/en/home" />
           </Switch>
         </LanguageWrapper>
       </Router>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example extends the routing setup by dynamically changing the language based on the URL. The `LanguageWrapper` component retrieves the language parameter from the URL and updates the i18n language accordingly. If the language is not supported, it redirects to the default language. This setup ensures that the application displays the correct language based on the URL.

3. **Handling Locale-Specific Routes with React Router:**
   ```javascript
   import React from 'react';
   import { BrowserRouter as Router, Route, Switch, Link, useParams, useRouteMatch } from 'react-router-dom';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         home: "Home",
         about: "About",
         contact: "Contact",
       },
     },
     fr: {
       translation: {
         home: "Accueil",
         about: "À propos",
         contact: "Contact",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en", // default language
     interpolation: {
       escapeValue: false, // React already does escaping
     },
   });

   function LanguageMenu() {
     const { url } = useRouteMatch();

     return (
       <nav>
         <Link to={`${url}/home`}>{i18n.t('home')}</Link>
         <Link to={`${url}/about`}>{i18n.t('about')}</Link>
         <Link to={`${url}/contact`}>{i18n.t('contact')}</Link>
       </nav>
     );
   }

   function LanguageWrapper({ children }) {
     const { lang } = useParams();

     React.useEffect(() => {
       i18n.changeLanguage(lang);
     }, [lang]);

     return children;
   }

   function Home() {
     const { t } = useTranslation();
     return <h1>{t('home')}</h1>;
   }

   function About() {
     const { t } = useTranslation();
     return <h1>{t('about')}</h1>;
   }

   function Contact() {
     const { t } = useTranslation();
     return <h1>{t('contact')}</h1>;
   }

   function App() {
     return (
       <Router>
         <Switch>
           <Route path="/:lang(en|fr)">
             <LanguageWrapper>
               <LanguageMenu />
               <Switch>
                 <Route path="/:lang(en|fr)/home" component={Home} />
                 <Route path="/:lang(en|fr)/about" component={About} />
                 <Route path="/:lang(en|fr)/contact" component={Contact} />
                 <Redirect from="/:lang(en|fr)" to="/:lang(en|fr)/home" />
               </Switch>
             </LanguageWrapper>
           </Route>
           <Redirect from="/" to="/en/home" />
         </Switch>
       </Router>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example handles locale-specific routes with React Router. The `LanguageMenu` component provides navigation links that include the current language in the URL. The `LanguageWrapper` component updates the i18n language based on the URL parameter. The application displays different components based on the current language and route, ensuring a localized experience.

**Online Resources:**
- [React Router i18n Example](

https://react.i18next.com/latest/using-with-router)
- [Multilingual React Apps](https://blog.logrocket.com/creating-multilingual-react-apps-using-react-context-and-react-i18next/)

### Task 20: Implement Localization with React-i18next

#### Task 1: Setting Up React-i18next

**Explanation:**
React-i18next is a powerful internationalization framework for React based on the popular i18next library. It allows developers to easily manage translations and localize their applications. The library provides tools for translating text, handling pluralization, formatting dates and numbers, and more. Setting up React-i18next involves installing the necessary packages, configuring the i18n instance, and integrating it with your React application.

To get started with React-i18next, you need to install `react-i18next` and `i18next` packages. After installation, you configure the i18n instance by defining the available languages, adding translations, and initializing the library. Finally, you wrap your application with the `I18nextProvider` component and use hooks like `useTranslation` to access translations in your components. This setup provides a robust foundation for managing localization in your React application.

**Online Resources:**
- [React-i18next Documentation](https://react.i18next.com/)
- [i18next Documentation](https://www.i18next.com/)

**Examples to Practice:**

1. **Basic Setup of React-i18next:**
   ```javascript
   import React from 'react';
   import ReactDOM from 'react-dom';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         welcome: "Welcome to React",
       },
     },
     fr: {
       translation: {
         welcome: "Bienvenue à React",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     interpolation: {
       escapeValue: false,
     },
   });

   function App() {
     const { t } = useTranslation();

     return (
       <div>
         <h1>{t('welcome')}</h1>
         <button onClick={() => i18n.changeLanguage('fr')}>French</button>
         <button onClick={() => i18n.changeLanguage('en')}>English</button>
       </div>
     );
   }

   ReactDOM.render(<App />, document.getElementById('root'));
   ```
   **Explanation:**
   This example demonstrates the basic setup of React-i18next. It includes defining the translations for English and French and initializing the i18n instance. The `App` component uses the `useTranslation` hook to access the translation function `t` and displays the translated welcome message. Buttons allow users to switch between languages.

2. **Adding and Using Translation Files:**
   ```javascript
   // src/locales/en/translation.json
   {
     "welcome": "Welcome to React"
   }

   // src/locales/fr/translation.json
   {
     "welcome": "Bienvenue à React"
   }

   // src/i18n.js
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';
   import translationEN from './locales/en/translation.json';
   import translationFR from './locales/fr/translation.json';

   const resources = {
     en: {
       translation: translationEN,
     },
     fr: {
       translation: translationFR,
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     interpolation: {
       escapeValue: false,
     },
   });

   export default i18n;

   // src/App.js
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import './i18n';

   function App() {
     const { t } = useTranslation();

     return (
       <div>
         <h1>{t('welcome')}</h1>
         <button onClick={() => i18n.changeLanguage('fr')}>French</button>
         <button onClick={() => i18n.changeLanguage('en')}>English</button>
       </div>
     );
   }

   export default App;

   // src/index.js
   import React from 'react';
   import ReactDOM from 'react-dom';
   import App from './App';

   ReactDOM.render(<App />, document.getElementById('root'));
   ```
   **Explanation:**
   This example shows how to organize translations into separate JSON files and use them in your application. The translations for English and French are stored in `translation.json` files in the `locales` directory. The i18n configuration imports these files and initializes the i18n instance. The `App` component remains the same, accessing translations using the `useTranslation` hook.

3. **Using Namespaces for Translations:**
   ```javascript
   // src/locales/en/common.json
   {
     "welcome": "Welcome to React"
   }

   // src/locales/fr/common.json
   {
     "welcome": "Bienvenue à React"
   }

   // src/locales/en/footer.json
   {
     "contact": "Contact us"
   }

   // src/locales/fr/footer.json
   {
     "contact": "Contactez-nous"
   }

   // src/i18n.js
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';
   import commonEN from './locales/en/common.json';
   import commonFR from './locales/fr/common.json';
   import footerEN from './locales/en/footer.json';
   import footerFR from './locales/fr/footer.json';

   const resources = {
     en: {
       common: commonEN,
       footer: footerEN,
     },
     fr: {
       common: commonFR,
       footer: footerFR,
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     ns: ["common", "footer"],
     defaultNS: "common",
     interpolation: {
       escapeValue: false,
     },
   });

   export default i18n;

   // src/App.js
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import './i18n';

   function App() {
     const { t } = useTranslation();

     return (
       <div>
         <h1>{t('welcome')}</h1>
         <Footer />
         <button onClick={() => i18n.changeLanguage('fr')}>French</button>
         <button onClick={() => i18n.changeLanguage('en')}>English</button>
       </div>
     );
   }

   function Footer() {
     const { t } = useTranslation('footer');
     return <p>{t('contact')}</p>;
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates the use of namespaces for organizing translations. The translations are split into `common` and `footer` namespaces, and the i18n configuration is updated accordingly. The `useTranslation` hook is used with the `footer` namespace in the `Footer` component to access footer-specific translations. This approach helps organize translations for large applications.

**Online Resources:**
- [Namespaces in React-i18next](https://react.i18next.com/latest/namespaces)
- [Organizing Translations](https://www.i18next.com/principles/namespaces)

#### Task 2: Handling Pluralization and Interpolation

**Explanation:**
Handling pluralization and interpolation is a crucial aspect of localization. Pluralization involves displaying different text based on the quantity of an item, while interpolation involves inserting dynamic values into translations. React-i18next provides built-in support for both, allowing you to handle complex localization scenarios easily. Proper pluralization ensures that your application displays grammatically correct messages, and interpolation allows you to create dynamic and contextually appropriate content.

React-i18next uses the ICU MessageFormat syntax for pluralization and interpolation, which is flexible and widely used. By defining pluralization rules and using placeholders for dynamic values, you can create translations that adapt to different contexts and quantities. This approach ensures that your application provides a natural and accurate user experience across different languages and locales.

**Online Resources:**
- [React-i18next Pluralization](https://react.i18next.com/latest/plurals)
- [ICU MessageFormat Syntax](https://formatjs.io/docs/core-concepts/icu-syntax)

**Examples to Practice:**

1. **Basic Pluralization:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         item: "You have {{count}} item",
         item_plural: "You have {{count}} items",
       },
     },
     fr: {
       translation: {
         item: "Vous avez {{count}} élément",
         item_plural: "Vous avez {{count}} éléments",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     interpolation: {
       escapeValue: false,
     },
   });

   function App() {
     const { t } = useTranslation();
     const itemCount = 3;

     return (
       <div>
         <p>{t('item', { count: itemCount })}</p>
         <button onClick={() => i18n.changeLanguage('fr')}>French</button>
         <button onClick={() => i18n.changeLanguage('en')}>English

</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example shows how to handle pluralization using React-i18next. The `resources` object includes translations for both singular and plural forms of the text. The `t` function automatically selects the correct form based on the `count` value provided. This ensures that the correct grammatical form is used for different quantities.

2. **Interpolation with Dynamic Values:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         greeting: "Hello, {{name}}!",
       },
     },
     es: {
       translation: {
         greeting: "¡Hola, {{name}}!",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     interpolation: {
       escapeValue: false,
     },
   });

   function App() {
     const { t } = useTranslation();
     const userName = "John";

     return (
       <div>
         <p>{t('greeting', { name: userName })}</p>
         <button onClick={() => i18n.changeLanguage('es')}>Spanish</button>
         <button onClick={() => i18n.changeLanguage('en')}>English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to use interpolation to insert dynamic values into translations. The `resources` object contains translations with placeholders for the user's name. The `t` function replaces the placeholder with the actual value provided, ensuring that the message is personalized and contextually appropriate.

3. **Combining Pluralization and Interpolation:**
   ```javascript
   import React from 'react';
   import { useTranslation } from 'react-i18next';
   import i18n from 'i18next';
   import { initReactI18next } from 'react-i18next';

   const resources = {
     en: {
       translation: {
         item: "{{name}} has {{count}} item",
         item_plural: "{{name}} has {{count}} items",
       },
     },
     fr: {
       translation: {
         item: "{{name}} a {{count}} élément",
         item_plural: "{{name}} a {{count}} éléments",
       },
     },
   };

   i18n.use(initReactI18next).init({
     resources,
     lng: "en",
     interpolation: {
       escapeValue: false,
     },
   });

   function App() {
     const { t } = useTranslation();
     const userName = "John";
     const itemCount = 3;

     return (
       <div>
         <p>{t('item', { name: userName, count: itemCount })}</p>
         <button onClick={() => i18n.changeLanguage('fr')}>French</button>
         <button onClick={() => i18n.changeLanguage('en')}>English</button>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example combines pluralization and interpolation. The translations include placeholders for both the user's name and the item count. The `t` function replaces these placeholders with the actual values provided, ensuring that the message is grammatically correct and personalized.

**Online Resources:**
- [React-i18next Interpolation](https://react.i18next.com/latest/interpolation)
- [ICU MessageFormat](https://formatjs.io/docs/core-concepts/icu-syntax)

#### Task 3: Localizing Dates and Numbers

**Explanation:**
Localizing dates and numbers ensures that your application displays these values in a format that is familiar and appropriate for users in different regions. This involves using locale-specific formats for dates, times, currencies, and numbers. Proper localization of dates and numbers enhances the user experience by making the information more understandable and relevant.

React-i18next and the `Intl` API provide tools for formatting dates and numbers according to the user's locale. The `Intl.DateTimeFormat` and `Intl.NumberFormat` constructors allow you to specify the desired locale and options for formatting. By integrating these tools into your application, you can ensure that dates and numbers are displayed in a way that meets the expectations of users in different regions.

**Online Resources:**
- [JavaScript Internationalization API](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl)
- [Formatting Dates and Times with Intl.DateTimeFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)

**Examples to Practice:**

1. **Formatting Dates Using Intl.DateTimeFormat:**
   ```javascript
   import React from 'react';

   function App() {
     const date = new Date();
     const formattedDateEN = new Intl.DateTimeFormat('en-US', { dateStyle: 'full' }).format(date);
     const formattedDateFR = new Intl.DateTimeFormat('fr-FR', { dateStyle: 'full' }).format(date);

     return (
       <div>
         <p>US Format: {formattedDateEN}</p>
         <p>French Format: {formattedDateFR}</p>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to format dates using `Intl.DateTimeFormat`. The date is formatted according to the 'en-US' and 'fr-FR' locales, displaying it in full date style. This ensures that dates are displayed in a format appropriate for different regions.

2. **Formatting Numbers Using Intl.NumberFormat:**
   ```javascript
   import React from 'react';

   function App() {
     const number = 1234567.89;
     const formattedNumberEN = new Intl.NumberFormat('en-US').format(number);
     const formattedNumberDE = new Intl.NumberFormat('de-DE').format(number);

     return (
       <div>
         <p>US Format: {formattedNumberEN}</p>
         <p>German Format: {formattedNumberDE}</p>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example shows how to format numbers using `Intl.NumberFormat`. The number is formatted according to the 'en-US' and 'de-DE' locales. This ensures that numbers are displayed in a way that is familiar to users in different regions, improving readability and comprehension.

3. **Formatting Currencies Using Intl.NumberFormat:**
   ```javascript
   import React from 'react';

   function App() {
     const amount = 1234.56;
     const formattedAmountUSD = new Intl.NumberFormat('en-US', { style: 'currency', currency: 'USD' }).format(amount);
     const formattedAmountEUR = new Intl.NumberFormat('de-DE', { style: 'currency', currency: 'EUR' }).format(amount);

     return (
       <div>
         <p>Amount in USD: {formattedAmountUSD}</p>
         <p>Amount in EUR: {formattedAmountEUR}</p>
       </div>
     );
   }

   export default App;
   ```
   **Explanation:**
   This example demonstrates how to format currency amounts using `Intl.NumberFormat`. The amount is formatted in USD and EUR according to the 'en-US' and 'de-DE' locales, respectively. This ensures that currency values are displayed correctly for users in different regions.

**Online Resources:**
- [Formatting Numbers with Intl.NumberFormat](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/NumberFormat)
- [Intl.DateTimeFormat Documentation](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Intl/DateTimeFormat)
