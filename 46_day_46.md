### Task 1: Study Advanced GraphQL Techniques for Cross-Platform Development using React Native

#### Explanation of the Topic

Advanced GraphQL techniques involve delving deeper into features such as query optimization, caching strategies, subscription management, and using GraphQL with modern tools like Apollo Client or Relay. Understanding these techniques helps in building efficient, scalable, and maintainable APIs that work seamlessly with React Native applications.

For cross-platform development, mastering these advanced techniques ensures that your mobile application can effectively communicate with the server, handle real-time updates, and provide a smooth user experience. Techniques such as using directives, fragments, and optimizing query performance are crucial for creating robust GraphQL APIs.

#### Online Resources to Refer

1. [Advanced GraphQL with Apollo](https://www.apollographql.com/docs/tutorial/introduction/)
2. [GraphQL Advanced Features](https://graphql.org/learn/queries/)

#### Examples to Practice

1. **Implementing GraphQL Fragments**
2. **Using GraphQL Directives**
3. **Setting Up Subscriptions in GraphQL**

---

### Example 1: Implementing GraphQL Fragments

#### Explanation

GraphQL fragments allow you to reuse parts of queries in multiple places, making your queries more modular and easier to maintain. This is especially useful in large applications where the same piece of data is needed in different parts of the application. By using fragments, you avoid repetitive query code and make your queries cleaner.

In a React Native application, you can define fragments for common data structures and include them in your queries. This not only simplifies your code but also ensures consistency across different parts of your app.

#### Code to Practice

```graphql
fragment UserDetails on User {
  id
  name
  email
}

query GetUsers {
  users {
    ...UserDetails
  }
}
```

```javascript
import { gql, useQuery } from '@apollo/client';

const USER_DETAILS = gql`
  fragment UserDetails on User {
    id
    name
    email
  }
`;

const GET_USERS = gql`
  query GetUsers {
    users {
      ...UserDetails
    }
  }
  ${USER_DETAILS}
`;

function Users() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
}
```

#### Expected Output

A list of users with their names and email addresses displayed.

#### Online Resources to Refer

1. [GraphQL Fragments Documentation](https://graphql.org/learn/queries/#fragments)
2. [Apollo Client - Using Fragments](https://www.apollographql.com/docs/react/data/fragments/)

---

### Example 2: Using GraphQL Directives

#### Explanation

GraphQL directives are a powerful feature that allow you to dynamically alter the execution of your queries. Directives can be used for a variety of purposes, such as conditionally including or skipping fields, applying transformations, and more.

In React Native, directives can be particularly useful for scenarios where you need to fetch data conditionally based on user actions or application state. By using directives, you can create more flexible and efficient queries.

#### Code to Practice

```graphql
query GetUser($includeEmail: Boolean!) {
  user(id: "1") {
    id
    name
    email @include(if: $includeEmail)
  }
}
```

```javascript
import { gql, useQuery } from '@apollo/client';

const GET_USER = gql`
  query GetUser($includeEmail: Boolean!) {
    user(id: "1") {
      id
      name
      email @include(if: $includeEmail)
    }
  }
`;

function User({ includeEmail }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { includeEmail },
  });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <p>{data.user.name}</p>
      {includeEmail && <p>{data.user.email}</p>}
    </div>
  );
}
```

#### Expected Output

The user's name and, optionally, their email based on the `includeEmail` variable.

#### Online Resources to Refer

1. [GraphQL Directives Documentation](https://graphql.org/learn/queries/#directives)
2. [Apollo Client - Query Options](https://www.apollographql.com/docs/react/data/queries/#options)

---

### Example 3: Setting Up Subscriptions in GraphQL

#### Explanation

Subscriptions in GraphQL allow you to set up real-time updates, which are essential for features like live chats, notifications, and live data feeds. By using subscriptions, your React Native application can receive updates from the server as soon as they happen, providing a dynamic and interactive user experience.

Setting up subscriptions involves defining subscription queries on the server and handling them in your React Native client. This typically requires using WebSocket connections to maintain a persistent connection for receiving updates.

#### Code to Practice

```graphql
subscription OnUserAdded {
  userAdded {
    id
    name
    email
  }
}
```

```javascript
import { gql, useSubscription } from '@apollo/client';

const USER_ADDED = gql`
  subscription OnUserAdded {
    userAdded {
      id
      name
      email
    }
  }
`;

function UserList() {
  const { data, loading } = useSubscription(USER_ADDED);

  if (loading) return <p>Loading...</p>;

  return (
    <ul>
      {data.userAdded.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
}
```

#### Expected Output

A dynamically updating list of users as new users are added.

#### Online Resources to Refer

1. [GraphQL Subscriptions Documentation](https://graphql.org/learn/queries/#subscriptions)
2. [Apollo Client - Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)

---

### Task 2: Implement GraphQL Fragments and Directives for Cross-Platform Development using React Native

#### Explanation of the Topic

**GraphQL Fragments**:
GraphQL fragments allow you to reuse pieces of query logic across multiple queries. This helps reduce redundancy and maintain consistency in your data fetching logic. Fragments are particularly useful in large applications where the same data structure is required in various parts of the application. By defining a fragment once, you can include it in multiple queries, making your code cleaner and easier to maintain.

In a React Native application, fragments help streamline your GraphQL queries by modularizing your query components. This results in more manageable code, especially when dealing with complex data structures and nested queries. Fragments also ensure that any changes to the structure of your data only need to be made in one place, which minimizes the risk of errors and inconsistencies.

**GraphQL Directives**:
GraphQL directives are used to modify the execution of queries, mutations, and subscriptions. Directives can be applied to fields or fragments to conditionally include or exclude parts of the query. They offer a way to implement dynamic query behavior based on variables or other runtime conditions. Common directives include `@include`, `@skip`, and `@deprecated`.

In a React Native context, directives enable you to create flexible and adaptive queries that respond to user interactions and application state. For example, you can use directives to conditionally fetch additional data based on user permissions or preferences, improving the performance and responsiveness of your application.

#### Online Resources to Refer

1. [GraphQL Fragments Documentation](https://graphql.org/learn/queries/#fragments)
2. [GraphQL Directives Documentation](https://graphql.org/learn/queries/#directives)

---

### Examples to Practice

1. **Using GraphQL Fragments to Modularize Queries**
2. **Conditionally Fetching Data with `@include` and `@skip` Directives**
3. **Combining Fragments and Directives in a Single Query**

---

### Example 1: Using GraphQL Fragments to Modularize Queries

#### Explanation

GraphQL fragments help in breaking down complex queries into smaller, reusable pieces. This is particularly beneficial when the same data fields are required in multiple queries across different components of your React Native application. By defining fragments for common data fields, you ensure consistency and reduce redundancy in your GraphQL queries.

In this example, we'll create a fragment for user details and use it in multiple queries. This demonstrates how fragments can simplify your queries and make your code more maintainable.

#### Code to Practice

```graphql
fragment UserDetails on User {
  id
  name
  email
}

query GetUser {
  user(id: "1") {
    ...UserDetails
  }
}

query GetUsers {
  users {
    ...UserDetails
  }
}
```

```javascript
import { gql, useQuery } from '@apollo/client';

const USER_DETAILS = gql`
  fragment UserDetails on User {
    id
    name
    email
  }
`;

const GET_USER = gql`
  query GetUser($id: ID!) {
    user(id: $id) {
      ...UserDetails
    }
  }
  ${USER_DETAILS}
`;

const GET_USERS = gql`
  query GetUsers {
    users {
      ...UserDetails
    }
  }
  ${USER_DETAILS}
`;

function User({ id }) {
  const { loading, error, data } = useQuery(GET_USER, { variables: { id } });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <p>{data.user.name}</p>
      <p>{data.user.email}</p>
    </div>
  );
}

function UserList() {
  const { loading, error, data } = useQuery(GET_USERS);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <ul>
      {data.users.map(user => (
        <li key={user.id}>{user.name} - {user.email}</li>
      ))}
    </ul>
  );
}
```

#### Expected Output

- **GetUser**: Displays the details of a specific user (name and email).
- **GetUsers**: Displays a list of all users with their names and emails.

#### Online Resources to Refer

1. [Apollo Client - Using Fragments](https://www.apollographql.com/docs/react/data/fragments/)
2. [GraphQL Fragments Tutorial](https://www.howtographql.com/advanced/4-data-fetching/)

---

### Example 2: Conditionally Fetching Data with `@include` and `@skip` Directives

#### Explanation

GraphQL directives like `@include` and `@skip` allow you to conditionally include or exclude fields in your queries based on variables. This is useful for fetching data dynamically based on user interactions or application state. By using these directives, you can optimize your data fetching logic and improve the performance of your application.

In this example, we'll create a query that conditionally includes the user's email based on a variable. This demonstrates how to use directives to make your queries more flexible and efficient.

#### Code to Practice

```graphql
query GetUser($id: ID!, $includeEmail: Boolean!) {
  user(id: $id) {
    id
    name
    email @include(if: $includeEmail)
  }
}
```

```javascript
import { gql, useQuery } from '@apollo/client';

const GET_USER = gql`
  query GetUser($id: ID!, $includeEmail: Boolean!) {
    user(id: $id) {
      id
      name
      email @include(if: $includeEmail)
    }
  }
`;

function User({ id, includeEmail }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id, includeEmail },
  });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <p>{data.user.name}</p>
      {includeEmail && <p>{data.user.email}</p>}
    </div>
  );
}
```

#### Expected Output

- Displays the user's name.
- Conditionally displays the user's email based on the `includeEmail` variable.

#### Online Resources to Refer

1. [Apollo Client - Query Options](https://www.apollographql.com/docs/react/data/queries/#options)
2. [GraphQL Directives Tutorial](https://www.howtographql.com/advanced/3-directives/)

---

### Example 3: Combining Fragments and Directives in a Single Query

#### Explanation

Combining fragments and directives allows you to create powerful and flexible queries. Fragments modularize your query logic, while directives enable you to conditionally fetch data based on runtime variables. This combination ensures that your queries are both reusable and adaptive, improving the maintainability and performance of your application.

In this example, we'll use both fragments and directives in a single query to fetch user details conditionally. This demonstrates how to leverage the strengths of both features in a cohesive manner.

#### Code to Practice

```graphql
fragment UserDetails on User {
  id
  name
  email
}

query GetUser($id: ID!, $includeEmail: Boolean!) {
  user(id: $id) {
    ...UserDetails
    email @include(if: $includeEmail)
  }
}
```

```javascript
import { gql, useQuery } from '@apollo/client';

const USER_DETAILS = gql`
  fragment UserDetails on User {
    id
    name
    email
  }
`;

const GET_USER = gql`
  query GetUser($id: ID!, $includeEmail: Boolean!) {
    user(id: $id) {
      ...UserDetails
      email @include(if: $includeEmail)
    }
  }
  ${USER_DETAILS}
`;

function User({ id, includeEmail }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id, includeEmail },
  });

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <p>{data.user.name}</p>
      {includeEmail && <p>{data.user.email}</p>}
    </div>
  );
}
```

#### Expected Output

- Displays the user's name.
- Conditionally displays the user's email based on the `includeEmail` variable.

#### Online Resources to Refer

1. [GraphQL Advanced Features](https://graphql.org/learn/advanced/)
2. [Apollo Client - Fragments and Directives](https://www.apollographql.com/docs/react/data/fragments/#fragments-in-queries)

---

### Task 3: Study Advanced State Management with Recoil for Cross-Platform Development using React Native

#### Explanation of the Topic

**Advanced State Management with Recoil**:
Recoil is a state management library for React and React Native applications, designed to work seamlessly with React's Concurrent Mode and provide a better developer experience for managing complex state. Recoil provides a set of tools for managing global state with atoms (state units) and selectors (derived state). Its core concepts include the ability to manage state across different parts of your app, create reactive data flows, and optimize performance through fine-grained updates.

Advanced state management with Recoil involves using features like asynchronous selectors, which allow you to derive state from asynchronous operations, and leveraging the library's built-in tools for debugging and performance optimization. Mastering these advanced techniques helps in creating scalable, maintainable, and high-performance applications that can handle complex state requirements efficiently.

#### Online Resources to Refer

1. [Recoil Documentation](https://recoiljs.org/docs/introduction/getting-started)
2. [Recoil State Management in React](https://www.taniarascia.com/recoil-state-management/)

---

### Examples to Practice

1. **Creating and Using Atoms in Recoil**
2. **Implementing Selectors for Derived State**
3. **Using Asynchronous Selectors for Data Fetching**

---

### Example 1: Creating and Using Atoms in Recoil

#### Explanation

Atoms are the fundamental building blocks of state in Recoil. An atom represents a piece of state that can be read from and written to from any component in your React Native application. When an atom's state changes, all components that depend on it will re-render automatically, making it an ideal tool for managing global state in a reactive way.

In this example, we will create a simple atom to manage a counter state. This demonstrates how to set up an atom, read its state, and update it from within your components.

#### Code to Practice

```javascript
import React from 'react';
import { RecoilRoot, atom, useRecoilState } from 'recoil';
import { View, Text, Button } from 'react-native';

// Define an atom
const counterState = atom({
  key: 'counterState', // unique ID (with respect to other atoms/selectors)
  default: 0, // default value (aka initial value)
});

function Counter() {
  const [count, setCount] = useRecoilState(counterState);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button onPress={() => setCount(count + 1)} title="Increment" />
      <Button onPress={() => setCount(count - 1)} title="Decrement" />
    </View>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}
```

#### Expected Output

- Displays the current count.
- Provides buttons to increment and decrement the count.

#### Online Resources to Refer

1. [Recoil Atoms](https://recoiljs.org/docs/basic-tutorial/atoms)
2. [Managing Global State with Recoil](https://medium.com/@melissamcewen/state-management-with-recoiljs-7f4c76fbd0e1)

---

### Example 2: Implementing Selectors for Derived State

#### Explanation

Selectors in Recoil are functions that allow you to compute derived state from atoms or other selectors. They enable you to encapsulate logic that depends on multiple pieces of state, ensuring that the derived state is automatically updated whenever the underlying state changes. Selectors can be used to transform data, combine multiple atoms, or fetch data based on the current state.

In this example, we will create a selector to derive the double of the counter state. This demonstrates how to define a selector and use it within your components.

#### Code to Practice

```javascript
import React from 'react';
import { RecoilRoot, atom, selector, useRecoilValue, useRecoilState } from 'recoil';
import { View, Text, Button } from 'react-native';

// Define an atom
const counterState = atom({
  key: 'counterState',
  default: 0,
});

// Define a selector
const doubleCounterState = selector({
  key: 'doubleCounterState',
  get: ({ get }) => {
    const count = get(counterState);
    return count * 2;
  },
});

function Counter() {
  const [count, setCount] = useRecoilState(counterState);
  const doubleCount = useRecoilValue(doubleCounterState);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Text>Double Count: {doubleCount}</Text>
      <Button onPress={() => setCount(count + 1)} title="Increment" />
      <Button onPress={() => setCount(count - 1)} title="Decrement" />
    </View>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}
```

#### Expected Output

- Displays the current count and its double.
- Provides buttons to increment and decrement the count.

#### Online Resources to Refer

1. [Recoil Selectors](https://recoiljs.org/docs/basic-tutorial/selectors)
2. [State Derivation with Recoil](https://www.digitalocean.com/community/tutorials/react-recoil-selectors)

---

### Example 3: Using Asynchronous Selectors for Data Fetching

#### Explanation

Asynchronous selectors in Recoil allow you to compute state that depends on asynchronous operations, such as fetching data from an API. This makes it easier to manage asynchronous data and keep your components reactive and up-to-date. Asynchronous selectors can handle loading and error states, providing a streamlined way to manage complex data flows in your application.

In this example, we will create an asynchronous selector to fetch data from a public API. This demonstrates how to use asynchronous selectors to manage and display data in a React Native application.

#### Code to Practice

```javascript
import React from 'react';
import { RecoilRoot, atom, selector, useRecoilValue } from 'recoil';
import { View, Text } from 'react-native';

// Define an atom for the URL
const urlState = atom({
  key: 'urlState',
  default: 'https://jsonplaceholder.typicode.com/todos/1',
});

// Define an asynchronous selector
const fetchDataSelector = selector({
  key: 'fetchDataSelector',
  get: async ({ get }) => {
    const url = get(urlState);
    const response = await fetch(url);
    const data = await response.json();
    return data;
  },
});

function DataFetcher() {
  const data = useRecoilValue(fetchDataSelector);

  return (
    <View>
      <Text>Title: {data.title}</Text>
      <Text>Completed: {data.completed ? 'Yes' : 'No'}</Text>
    </View>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <DataFetcher />
    </RecoilRoot>
  );
}
```

#### Expected Output

- Fetches and displays data from the specified URL.
- Shows the title and completion status of a to-do item.

#### Online Resources to Refer

1. [Recoil Asynchronous Selectors](https://recoiljs.org/docs/guides/asynchronous-data-queries)
2. [Managing Asynchronous Data with Recoil](https://dev.to/vicentedealencar/react-state-management-with-recoil-async-selectors-2g8c)

---

### Task 4: Integrate Recoil for State Management in Cross-Platform Development using React Native

#### Explanation of the Topic

**Integrating Recoil for State Management**:
Recoil is a state management library designed specifically for React, offering a modern and efficient way to manage state in both React and React Native applications. It provides an intuitive API for creating and managing global state using atoms and selectors. Atoms are units of state that can be shared across components, while selectors are pure functions that derive state from atoms or other selectors.

Integrating Recoil into a React Native project enhances the application's state management capabilities, enabling you to handle complex state dependencies and asynchronous data flows effectively. Recoil's reactive data flow ensures that components automatically re-render when their dependencies change, leading to more responsive and maintainable applications.

#### Online Resources to Refer

1. [Recoil Documentation](https://recoiljs.org/docs/introduction/getting-started)
2. [Managing Global State with Recoil](https://blog.logrocket.com/manage-global-state-react-recoil/)

---

### Examples to Practice

1. **Setting Up Recoil in a React Native Project**
2. **Managing Global State with Atoms**
3. **Creating Derived State with Selectors**

---

### Example 1: Setting Up Recoil in a React Native Project

#### Explanation

To integrate Recoil into your React Native project, you need to install the Recoil library and wrap your application with the `RecoilRoot` component. This provides the context required for Recoil's state management. Once set up, you can start defining atoms and selectors to manage your application's state.

This example demonstrates the initial setup process for integrating Recoil into a React Native project. We'll go through the steps of installing the Recoil library, wrapping the application with `RecoilRoot`, and creating a basic atom to manage a piece of state.

#### Code to Practice

1. Install Recoil:

```sh
npm install recoil
```

2. Setup Recoil in your application:

```javascript
import React from 'react';
import { RecoilRoot } from 'recoil';
import { View, Text } from 'react-native';

function App() {
  return (
    <RecoilRoot>
      <View>
        <Text>Hello, Recoil!</Text>
      </View>
    </RecoilRoot>
  );
}

export default App;
```

#### Expected Output

A simple application displaying "Hello, Recoil!" with Recoil state management setup.

#### Online Resources to Refer

1. [Recoil Getting Started](https://recoiljs.org/docs/introduction/getting-started)
2. [Integrating Recoil with React Native](https://recoiljs.org/docs/introduction/installation)

---

### Example 2: Managing Global State with Atoms

#### Explanation

Atoms are the fundamental units of state in Recoil. An atom represents a piece of state that can be read and written to from any component in your application. When an atom's state changes, all components that depend on that state will re-render, ensuring a reactive data flow. Atoms are ideal for managing global state that needs to be accessed or modified by multiple components.

In this example, we will create an atom to manage a counter state. We will then create a component that reads and updates this state, demonstrating how to use atoms for global state management in a React Native application.

#### Code to Practice

```javascript
import React from 'react';
import { RecoilRoot, atom, useRecoilState } from 'recoil';
import { View, Text, Button } from 'react-native';

// Define an atom
const counterState = atom({
  key: 'counterState',
  default: 0,
});

function Counter() {
  const [count, setCount] = useRecoilState(counterState);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button onPress={() => setCount(count + 1)} title="Increment" />
      <Button onPress={() => setCount(count - 1)} title="Decrement" />
    </View>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}
```

#### Expected Output

- Displays the current count.
- Provides buttons to increment and decrement the count.

#### Online Resources to Refer

1. [Recoil Atoms](https://recoiljs.org/docs/basic-tutorial/atoms)
2. [Managing Global State with Recoil](https://medium.com/@melissamcewen/state-management-with-recoiljs-7f4c76fbd0e1)

---

### Example 3: Creating Derived State with Selectors

#### Explanation

Selectors in Recoil are used to derive state from atoms or other selectors. They are pure functions that transform or combine state, allowing you to encapsulate complex state logic in a single place. Selectors can also be asynchronous, enabling you to fetch data from APIs and compute state based on the result.

In this example, we will create a selector that derives the double of the counter state. This demonstrates how to define a selector and use it within your components to display derived state.

#### Code to Practice

```javascript
import React from 'react';
import { RecoilRoot, atom, selector, useRecoilValue, useRecoilState } from 'recoil';
import { View, Text, Button } from 'react-native';

// Define an atom
const counterState = atom({
  key: 'counterState',
  default: 0,
});

// Define a selector
const doubleCounterState = selector({
  key: 'doubleCounterState',
  get: ({ get }) => {
    const count = get(counterState);
    return count * 2;
  },
});

function Counter() {
  const [count, setCount] = useRecoilState(counterState);
  const doubleCount = useRecoilValue(doubleCounterState);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Text>Double Count: {doubleCount}</Text>
      <Button onPress={() => setCount(count + 1)} title="Increment" />
      <Button onPress={() => setCount(count - 1)} title="Decrement" />
    </View>
  );
}

export default function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}
```

#### Expected Output

- Displays the current count and its double.
- Provides buttons to increment and decrement the count.

#### Online Resources to Refer

1. [Recoil Selectors](https://recoiljs.org/docs/basic-tutorial/selectors)
2. [State Derivation with Recoil](https://www.digitalocean.com/community/tutorials/react-recoil-selectors)

---

### Task 5: Study Advanced Caching Strategies for Cross-Platform Development using React Native

#### Explanation of the Topic

**Advanced Caching Strategies**:
Caching is a crucial aspect of improving the performance and responsiveness of mobile applications. Advanced caching strategies involve techniques like cache invalidation, cache replacement policies, and the use of persistent storage to manage and store data efficiently. Implementing effective caching strategies can significantly reduce network requests, speed up data retrieval, and provide a seamless user experience even when offline.

In React Native, advanced caching can be achieved using libraries like `react-query`, `Apollo Client`, and other state management tools that provide built-in caching mechanisms. By leveraging these libraries, developers can implement sophisticated caching strategies that include stale-while-revalidate, time-based caching, and data prefetching to optimize the application's performance.

#### Online Resources to Refer

1. [Advanced Caching with Apollo Client](https://www.apollographql.com/docs/react/caching/overview/)
2. [react-query: Caching](https://react-query.tanstack.com/guides/caching)

---

### Examples to Practice

1. **Implementing Cache with Apollo Client**
2. **Using `react-query` for Data Caching**
3. **Local Storage Caching with AsyncStorage**

---

### Example 1: Implementing Cache with Apollo Client

#### Explanation

Apollo Client is a powerful tool for managing GraphQL data in React Native applications. It includes a sophisticated caching mechanism that helps manage local state and server data efficiently. By configuring the Apollo cache, you can control how data is cached, invalidated, and retrieved, improving the performance and responsiveness of your app.

In this example, we'll set up Apollo Client with a normalized cache and demonstrate how to query and cache data. This setup ensures that repeated queries for the same data are served from the cache, reducing network requests and speeding up the application.

#### Code to Practice

1. Install Apollo Client and GraphQL:

```sh
npm install @apollo/client graphql
```

2. Setup Apollo Client with cache:

```javascript
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client';
import { View, Text } from 'react-native';

const client = new ApolloClient({
  uri: 'https://your-graphql-endpoint.com/graphql',
  cache: new InMemoryCache(),
});

const GET_DATA = gql`
  query GetData {
    items {
      id
      name
    }
  }
`;

function DataDisplay() {
  const { loading, error, data } = useQuery(GET_DATA);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.items.map(item => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <ApolloProvider client={client}>
      <DataDisplay />
    </ApolloProvider>
  );
}
```

#### Expected Output

- Displays a list of items retrieved from the GraphQL endpoint.
- Uses Apollo Client's cache to improve performance.

#### Online Resources to Refer

1. [Apollo Client Caching](https://www.apollographql.com/docs/react/caching/overview/)
2. [Managing Local State with Apollo Client](https://www.apollographql.com/docs/react/local-state/overview/)

---

### Example 2: Using `react-query` for Data Caching

#### Explanation

`react-query` is a powerful library for fetching, caching, and synchronizing server state in React applications. It provides an efficient caching mechanism that allows you to manage remote data with ease. `react-query` supports various caching strategies, including stale-while-revalidate, which ensures that your data is always fresh while minimizing network requests.

In this example, we'll set up `react-query` in a React Native project and demonstrate how to fetch and cache data. This setup will show how `react-query` handles caching and synchronization, improving the overall performance of your application.

#### Code to Practice

1. Install `react-query`:

```sh
npm install @tanstack/react-query
```

2. Setup `react-query`:

```javascript
import React from 'react';
import { QueryClient, QueryClientProvider, useQuery } from '@tanstack/react-query';
import { View, Text } from 'react-native';

const queryClient = new QueryClient();

const fetchItems = async () => {
  const response = await fetch('https://your-api-endpoint.com/items');
  return response.json();
};

function DataDisplay() {
  const { data, error, isLoading } = useQuery('items', fetchItems);

  if (isLoading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.map(item => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <DataDisplay />
    </QueryClientProvider>
  );
}
```

#### Expected Output

- Displays a list of items retrieved from the API.
- Utilizes `react-query`'s caching to optimize data fetching and performance.

#### Online Resources to Refer

1. [react-query Caching](https://react-query.tanstack.com/guides/caching)
2. [react-query Introduction](https://react-query.tanstack.com/overview)

---

### Example 3: Local Storage Caching with AsyncStorage

#### Explanation

AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the React Native application. It is perfect for caching data locally on the device, allowing your app to work offline or improve performance by reducing the need for repeated network requests.

In this example, we will use AsyncStorage to cache data locally in a React Native application. We will demonstrate how to store, retrieve, and update cached data, ensuring that the app can work efficiently even without an internet connection.

#### Code to Practice

1. Install AsyncStorage:

```sh
npm install @react-native-async-storage/async-storage
```

2. Setup AsyncStorage:

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, Button, AsyncStorage } from 'react-native';

const fetchData = async () => {
  const response = await fetch('https://your-api-endpoint.com/items');
  const data = await response.json();
  await AsyncStorage.setItem('cachedData', JSON.stringify(data));
  return data;
};

const getCachedData = async () => {
  const cachedData = await AsyncStorage.getItem('cachedData');
  return cachedData ? JSON.parse(cachedData) : [];
};

function DataDisplay() {
  const [data, setData] = useState([]);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      const cachedData = await getCachedData();
      setData(cachedData);
      setLoading(false);
      fetchData().then(fetchedData => setData(fetchedData));
    })();
  }, []);

  if (loading) return <Text>Loading...</Text>;

  return (
    <View>
      {data.map(item => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <View>
      <DataDisplay />
    </View>
  );
}
```

#### Expected Output

- Displays a list of items retrieved from the API or cache.
- Uses AsyncStorage to cache data locally and provide offline access.

#### Online Resources to Refer

1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/docs/install/)
2. [Managing Persistent State with AsyncStorage](https://reactnative.dev/docs/asyncstorage)

---

### Task 6: Implement Caching with SWR (Stale-While-Revalidate) for Cross-Platform Development using React Native

#### Explanation of the Topic

**SWR (Stale-While-Revalidate)**:
SWR is a React Hooks library for data fetching that provides a simple and efficient way to handle remote data. The name SWR stands for "stale-while-revalidate," which is a caching strategy that allows you to serve stale (cached) data while revalidating (fetching) new data in the background. This approach ensures that users always see the data immediately while keeping it up-to-date with minimal latency.

Using SWR in a React Native application can greatly enhance the user experience by providing fast and responsive data loading. SWR handles various aspects of data fetching, including caching, revalidation, focus tracking, and error handling, making it an excellent choice for managing remote data in your cross-platform applications.

#### Online Resources to Refer

1. [SWR Documentation](https://swr.vercel.app/)
2. [SWR GitHub Repository](https://github.com/vercel/swr)

---

### Examples to Practice

1. **Basic Data Fetching with SWR**
2. **Optimistic UI Updates with SWR**
3. **Error Handling and Revalidation with SWR**

---

### Example 1: Basic Data Fetching with SWR

#### Explanation

SWR makes it easy to fetch data in React Native applications with a simple API. By using the `useSWR` hook, you can define a data fetching function and pass a key to identify the request. SWR will automatically handle caching, revalidation, and updating the UI when the data changes.

In this example, we will set up SWR to fetch data from a public API and display it in a React Native component. This will demonstrate the basic usage of SWR for data fetching and caching.

#### Code to Practice

1. Install SWR:

```sh
npm install swr
```

2. Setup SWR for data fetching:

```javascript
import React from 'react';
import { View, Text } from 'react-native';
import useSWR from 'swr';

// Define the fetcher function
const fetcher = (url) => fetch(url).then((res) => res.json());

function DataDisplay() {
  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher);

  if (error) return <Text>Error loading data</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      {data.map((post) => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <View>
      <DataDisplay />
    </View>
  );
}
```

#### Expected Output

- Displays a list of post titles fetched from the API.
- Shows a loading message while fetching data and an error message if the fetch fails.

#### Online Resources to Refer

1. [SWR Basics](https://swr.vercel.app/docs/getting-started)
2. [SWR API Reference](https://swr.vercel.app/docs/api)

---

### Example 2: Optimistic UI Updates with SWR

#### Explanation

Optimistic UI updates allow you to immediately reflect changes in the UI before the data fetching operation completes. SWR provides support for optimistic updates through its mutation API, which can be used to update the local cache and the UI optimistically. This creates a smoother user experience by providing immediate feedback for user actions.

In this example, we will implement optimistic updates for a simple form that adds a new post. We will use SWR's `mutate` function to update the cache and UI optimistically before the actual data fetch completes.

#### Code to Practice

1. Setup optimistic UI updates:

```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import useSWR, { mutate } from 'swr';

const fetcher = (url) => fetch(url).then((res) => res.json());

function DataDisplay() {
  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher);

  if (error) return <Text>Error loading data</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      {data.map((post) => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
}

function AddPost() {
  const [title, setTitle] = useState('');

  const addPost = async () => {
    const newPost = { id: Math.random().toString(), title };
    // Optimistically update the UI
    mutate('https://jsonplaceholder.typicode.com/posts', (posts) => [...posts, newPost], false);

    // Make the API request
    await fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST',
      body: JSON.stringify(newPost),
    });

    // Revalidate the cache
    mutate('https://jsonplaceholder.typicode.com/posts');
    setTitle('');
  };

  return (
    <View>
      <TextInput
        value={title}
        onChangeText={setTitle}
        placeholder="New post title"
      />
      <Button title="Add Post" onPress={addPost} />
    </View>
  );
}

export default function App() {
  return (
    <View>
      <AddPost />
      <DataDisplay />
    </View>
  );
}
```

#### Expected Output

- Displays a list of post titles fetched from the API.
- Immediately adds a new post to the UI optimistically before confirming with the server.

#### Online Resources to Refer

1. [SWR Mutation](https://swr.vercel.app/docs/mutation)
2. [Optimistic UI with SWR](https://swr.vercel.app/docs/optimistic-ui)

---

### Example 3: Error Handling and Revalidation with SWR

#### Explanation

Error handling and revalidation are crucial components of data fetching to ensure the reliability and freshness of your application's data. SWR offers built-in support for handling errors gracefully and revalidating data on various triggers, such as network reconnection or focus events. This ensures that your application always displays the most up-to-date information and can recover gracefully from errors.

In this example, we will implement error handling and automatic revalidation using SWR. We will demonstrate how to handle errors during data fetching and trigger revalidation when the network reconnects or the app gains focus.

#### Code to Practice

1. Setup error handling and revalidation:

```javascript
import React from 'react';
import { View, Text } from 'react-native';
import useSWR from 'swr';

const fetcher = (url) => fetch(url).then((res) => res.json());

function DataDisplay() {
  const { data, error, mutate } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher, {
    onErrorRetry: (error, key, config, revalidate, { retryCount }) => {
      // Retry up to 3 times
      if (retryCount >= 3) return;
      // Retry after 5 seconds
      setTimeout(() => revalidate({ retryCount }), 5000);
    },
  });

  if (error) return <Text>Error loading data. Retrying...</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      {data.map((post) => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <View>
      <DataDisplay />
    </View>
  );
}
```

#### Expected Output

- Displays a list of post titles fetched from the API.
- Shows an error message and retries fetching data if an error occurs.

#### Online Resources to Refer

1. [SWR Error Handling](https://swr.vercel.app/docs/error-handling)
2. [SWR Revalidation](https://swr.vercel.app/docs/revalidation)

---

### Task 7: Study Advanced Networking Techniques for Cross-Platform Development using React Native

#### Explanation of the Topic

**Advanced Networking Techniques**:
Advanced networking techniques in React Native involve optimizing network requests, managing connection states, handling real-time data, and ensuring secure communication. These techniques are crucial for developing robust, responsive, and user-friendly applications. By understanding and implementing advanced networking practices, developers can significantly enhance the performance and reliability of their apps.

Key areas include using WebSockets for real-time updates, implementing retry mechanisms for failed requests, managing offline states and data synchronization, and ensuring secure API communication through token-based authentication and HTTPS. Mastering these techniques ensures that your React Native applications can handle complex networking scenarios efficiently.

#### Online Resources to Refer

1. [React Native Networking](https://reactnative.dev/docs/network)
2. [Advanced Networking in React Native](https://blog.logrocket.com/networking-in-react-native/)

---

### Examples to Practice

1. **Using WebSockets for Real-Time Data**
2. **Implementing Retry Mechanisms for Failed Requests**
3. **Handling Offline States and Data Synchronization**

---

### Example 1: Using WebSockets for Real-Time Data

#### Explanation

WebSockets provide a full-duplex communication channel over a single TCP connection, enabling real-time data transfer between the client and server. This is particularly useful for applications that require live updates, such as chat apps, live sports scores, or financial tickers. By using WebSockets in a React Native application, you can ensure that your app receives updates as soon as they occur, providing a more dynamic user experience.

In this example, we will set up a WebSocket connection in a React Native application to receive real-time updates from a server. We will handle the connection lifecycle, including opening, receiving messages, and closing the connection.

#### Code to Practice

1. Setup WebSocket:

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text } from 'react-native';

function WebSocketComponent() {
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    const ws = new WebSocket('wss://example.com/socket');

    ws.onopen = () => {
      console.log('WebSocket connection opened');
    };

    ws.onmessage = (e) => {
      const newMessage = JSON.parse(e.data);
      setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    ws.onclose = () => {
      console.log('WebSocket connection closed');
    };

    return () => {
      ws.close();
    };
  }, []);

  return (
    <View>
      {messages.map((message, index) => (
        <Text key={index}>{message.content}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <View>
      <WebSocketComponent />
    </View>
  );
}
```

#### Expected Output

- Displays a list of real-time messages received from the WebSocket server.

#### Online Resources to Refer

1. [MDN WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Using WebSockets in React Native](https://reactnative.dev/docs/network#using-other-networking-libraries)

---

### Example 2: Implementing Retry Mechanisms for Failed Requests

#### Explanation

Network requests can fail for various reasons, such as temporary server issues, network instability, or rate limiting. Implementing retry mechanisms ensures that your application can handle transient failures gracefully by retrying the request after a specified interval. This improves the reliability and user experience of your app by reducing the likelihood of failed operations.

In this example, we will implement a retry mechanism for failed network requests in a React Native application using the `axios` library. We will configure axios to retry failed requests a specified number of times with exponential backoff.

#### Code to Practice

1. Install `axios` and `axios-retry`:

```sh
npm install axios axios-retry
```

2. Setup retry mechanism:

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text } from 'react-native';
import axios from 'axios';
import axiosRetry from 'axios-retry';

axiosRetry(axios, { retries: 3, retryDelay: (retryCount) => retryCount * 1000 });

function FetchData() {
  const [data, setData] = useState(null);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const response = await axios.get('https://jsonplaceholder.typicode.com/posts/1');
        setData(response.data);
      } catch (err) {
        setError(err.message);
      }
    };

    fetchData();
  }, []);

  if (error) return <Text>Error: {error}</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      <Text>Title: {data.title}</Text>
      <Text>Body: {data.body}</Text>
    </View>
  );
}

export default function App() {
  return (
    <View>
      <FetchData />
    </View>
  );
}
```

#### Expected Output

- Displays the data fetched from the API.
- Retries the request up to three times if it fails.

#### Online Resources to Refer

1. [axios Documentation](https://github.com/axios/axios)
2. [axios-retry Documentation](https://github.com/softonic/axios-retry)

---

### Example 3: Handling Offline States and Data Synchronization

#### Explanation

Handling offline states and data synchronization is essential for providing a seamless user experience in mobile applications, especially when network connectivity is unreliable. By implementing strategies for offline support and data synchronization, you can ensure that your app remains functional even without an internet connection and that data is synced correctly when the connection is restored.

In this example, we will use `react-native-offline` to manage offline states and synchronize data when the network connection is re-established. This involves detecting network status changes, storing data locally when offline, and syncing it with the server once the connection is available.

#### Code to Practice

1. Install `react-native-offline`:

```sh
npm install @redux-offline/redux-offline @redux-offline/redux-offline/lib/defaults
```

2. Setup offline handling and data synchronization:

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, Button } from 'react-native';
import { createStore, applyMiddleware } from 'redux';
import { Provider, useDispatch, useSelector } from 'react-redux';
import offlineMiddleware, { networkStatusChanged } from '@redux-offline/redux-offline';
import offlineConfig from '@redux-offline/redux-offline/lib/defaults';
import axios from 'axios';

// Actions
const ADD_POST = 'ADD_POST';
const SYNC_POST = 'SYNC_POST';

// Reducer
const initialState = {
  posts: [],
  isConnected: true,
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case ADD_POST:
      return {
        ...state,
        posts: [...state.posts, action.payload],
      };
    case SYNC_POST:
      return {
        ...state,
        posts: state.posts.map((post) =>
          post.id === action.payload.id ? { ...post, synced: true } : post
        ),
      };
    case 'Offline/STATUS_CHANGED':
      return {
        ...state,
        isConnected: action.payload,
      };
    default:
      return state;
  }
};

// Store
const store = createStore(reducer, applyMiddleware(offlineMiddleware(offlineConfig)));

const fetchData = async () => {
  const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
  return response.data;
};

function DataDisplay() {
  const posts = useSelector((state) => state.posts);
  const isConnected = useSelector((state) => state.isConnected);
  const dispatch = useDispatch();

  useEffect(() => {
    const syncData = async () => {
      if (isConnected) {
        for (const post of posts.filter((post) => !post.synced)) {
          await axios.post('https://jsonplaceholder.typicode.com/posts', post);
          dispatch({ type: SYNC_POST, payload: post });
        }
      }
    };
    syncData();
  }, [isConnected]);

  const addPost = () => {
    const newPost = {
      id: Math.random().toString(),
      title: 'New Post',
      body: 'This is a new post.',
      synced: false,
    };
    dispatch({ type: ADD_POST, payload: newPost });
  };

  return (
    <View>
      <Button title="Add Post" onPress={addPost} />
      {posts.map((post) => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
}

export default function App() {
  useEffect(() => {
    const handleConnectivityChange = (isConnected) => {
      store.dispatch(networkStatusChanged(isConnected));
    };

    // Add your connectivity listener here and call handleConnectivityChange when it changes

    return () => {
      // Clean up the connectivity listener
    };
  }, []);

  return (
    <Provider store={store}>
      <DataDisplay />
    </Provider>
  );
}
```

#### Expected Output

- Displays a list of posts.
- Adds new posts locally when offline and syncs them with the server when the connection is restored.

#### Online Resources to Refer

1. [react-native-offline Documentation](https://github.com/rgommezz/react-native-offline)
2. [Managing Offline States in React Native](https://blog.logrocket.com/managing-offline-states-in-react-native/)

---

### Task 8: Optimize Network Requests with GraphQL Batching for Cross-Platform Development using React Native

#### Explanation of the Topic

**GraphQL Batching**:
GraphQL batching is a technique used to optimize network requests by combining multiple GraphQL queries into a single request. This reduces the number of HTTP requests sent to the server, which can significantly improve performance and reduce latency in applications. By batching queries, you can minimize the overhead associated with multiple round-trips to the server, making your app more efficient and responsive.

In a React Native application, implementing GraphQL batching can lead to a more streamlined and performant data fetching strategy. This is particularly useful in scenarios where multiple components need data from the server simultaneously. By leveraging GraphQL batching, you can ensure that your app retrieves all necessary data in a single request, reducing the load on both the client and server.

#### Online Resources to Refer

1. [GraphQL Batching with Apollo Client](https://www.apollographql.com/docs/react/data/batching/)
2. [GraphQL Batching Documentation](https://graphql.org/learn/queries/#batching)

---

### Examples to Practice

1. **Setting Up GraphQL Batching with Apollo Client**
2. **Batching Queries for Multiple Components**
3. **Optimizing Performance with Batch HTTP Link**

---

### Example 1: Setting Up GraphQL Batching with Apollo Client

#### Explanation

Apollo Client provides built-in support for batching GraphQL queries using the `apollo-link-batch-http` package. This allows you to combine multiple queries into a single HTTP request, reducing the number of network requests and improving the overall performance of your application. Setting up batching involves configuring the Apollo Client to use the batch HTTP link instead of the default link.

In this example, we will set up Apollo Client with batch HTTP link and demonstrate how to configure it for batching queries. This setup will enable your React Native application to combine multiple GraphQL queries into a single request.

#### Code to Practice

1. Install necessary packages:

```sh
npm install @apollo/client apollo-link-batch-http graphql
```

2. Setup Apollo Client with batch HTTP link:

```javascript
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { View, Text } from 'react-native';
import { gql, useQuery } from '@apollo/client';

const client = new ApolloClient({
  link: new BatchHttpLink({ uri: 'https://your-graphql-endpoint.com/graphql' }),
  cache: new InMemoryCache(),
});

const GET_DATA = gql`
  query GetData {
    items {
      id
      name
    }
  }
`;

function DataDisplay() {
  const { data, error, loading } = useQuery(GET_DATA);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.items.map((item) => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <ApolloProvider client={client}>
      <DataDisplay />
    </ApolloProvider>
  );
}
```

#### Expected Output

- Displays a list of items fetched from the GraphQL endpoint.
- Combines multiple queries into a single HTTP request for improved performance.

#### Online Resources to Refer

1. [Apollo Client Batch HTTP Link](https://www.apollographql.com/docs/react/data/batching/)
2. [GraphQL Batching Best Practices](https://graphql.org/learn/queries/#batching)

---

### Example 2: Batching Queries for Multiple Components

#### Explanation

In a complex React Native application, different components often need to fetch data from the server simultaneously. Without batching, each component's data fetch results in a separate network request, which can lead to increased latency and reduced performance. By batching these queries, you can combine them into a single request, reducing the number of HTTP requests and improving the application's responsiveness.

In this example, we will create multiple components that each fetch data from the server. We will configure Apollo Client to batch these queries into a single request, demonstrating how to optimize network requests in a multi-component scenario.

#### Code to Practice

1. Setup multiple components with batched queries:

```javascript
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { View, Text } from 'react-native';

const client = new ApolloClient({
  link: new BatchHttpLink({ uri: 'https://your-graphql-endpoint.com/graphql' }),
  cache: new InMemoryCache(),
});

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
    }
  }
`;

const GET_POSTS = gql`
  query GetPosts {
    posts {
      id
      title
    }
  }
`;

function Users() {
  const { data, error, loading } = useQuery(GET_USERS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.users.map((user) => (
        <Text key={user.id}>{user.name}</Text>
      ))}
    </View>
  );
}

function Posts() {
  const { data, error, loading } = useQuery(GET_POSTS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.posts.map((post) => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <ApolloProvider client={client}>
      <Users />
      <Posts />
    </ApolloProvider>
  );
}
```

#### Expected Output

- Displays a list of users and posts fetched from the GraphQL endpoint.
- Combines the queries from both components into a single HTTP request.

#### Online Resources to Refer

1. [Optimizing Network Requests with GraphQL Batching](https://www.apollographql.com/blog/apollo-client/performance/optimizing-network-requests-with-apollo-client-batching/)
2. [Apollo Client Documentation](https://www.apollographql.com/docs/react/)

---

### Example 3: Optimizing Performance with Batch HTTP Link

#### Explanation

Batch HTTP Link in Apollo Client is a powerful tool for optimizing network performance by batching multiple GraphQL operations into a single HTTP request. This can significantly reduce the overhead associated with multiple HTTP requests, especially in applications with high data-fetching demands. By configuring the batch HTTP link with appropriate settings, such as batch interval and maximum batch size, you can fine-tune the performance optimization to match your application's needs.

In this example, we will configure the batch HTTP link with custom settings to control the batch interval and maximum batch size. This demonstrates how to optimize the batching configuration for better performance in a React Native application.

#### Code to Practice

1. Setup custom batch HTTP link configuration:

```javascript
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, gql, useQuery } from '@apollo/client';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { View, Text } from 'react-native';

const batchHttpLink = new BatchHttpLink({
  uri: 'https://your-graphql-endpoint.com/graphql',
  batchInterval: 20, // Batch interval in milliseconds
  maxBatchSize: 5, // Maximum number of operations per batch
});

const client = new ApolloClient({
  link: batchHttpLink,
  cache: new InMemoryCache(),
});

const GET_DATA = gql`
  query GetData {
    items {
      id
      name
    }
  }
`;

function DataDisplay() {
  const { data, error, loading } = useQuery(GET_DATA);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      {data.items.map((item) => (
        <Text key={item.id}>{item.name}</Text>
      ))}
    </View>
  );
}

export default function App() {
  return (
    <ApolloProvider client={client}>
      <DataDisplay />
    </ApolloProvider>
  );
}
```

#### Expected Output

- Displays a list of items fetched from the GraphQL endpoint.
- Uses custom batch HTTP link settings to optimize network request batching.

#### Online Resources to Refer

1. [Apollo Client Batch HTTP Link Configuration](https://www.apollographql.com/docs/react/api/link/apollo-link-batch-http/)
2. [GraphQL Performance Optimization](https://graphql.org/learn/performance/)

---

### Task 9: Study Server-Side Rendering in Next.js for Cross-Platform Development using React Native

#### Explanation of the Topic

**Server-Side Rendering (SSR) in Next.js**:
Server-side rendering (SSR) is a technique where a web page is rendered on the server instead of in the client's browser. This can significantly improve the performance and SEO of web applications by delivering fully rendered HTML to the client. Next.js, a popular React framework, provides built-in support for SSR, enabling developers to create dynamic and performant web applications with ease.

By leveraging SSR in Next.js, you can optimize the initial load time of your React applications and ensure that your content is indexed correctly by search engines. This is especially useful for content-heavy applications and those that rely on dynamic data fetching. Next.js simplifies the implementation of SSR with its intuitive API, making it accessible even to developers new to server-side rendering.

#### Online Resources to Refer

1. [Next.js Documentation on SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Understanding SSR in Next.js](https://www.smashingmagazine.com/2020/03/complete-guide-server-side-rendering-nextjs/)

---

### Examples to Practice

1. **Basic Server-Side Rendering with Next.js**
2. **Fetching Data on the Server Side with getServerSideProps**
3. **Combining SSR with Client-Side Rendering**

---

### Example 1: Basic Server-Side Rendering with Next.js

#### Explanation

Setting up basic server-side rendering in Next.js involves creating pages that are pre-rendered on the server. This means that the HTML is generated on the server for each request and sent to the client, improving the initial load time and SEO of your application. Next.js makes this process straightforward by allowing you to export components as pages, which are automatically server-side rendered.

In this example, we will create a simple Next.js page that demonstrates basic server-side rendering. This will help you understand how to set up SSR in your Next.js application and the benefits it provides.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a basic SSR page:

```javascript
// pages/index.js
import React from 'react';

function HomePage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'Hello from server-side rendering!',
    },
  };
}

export default HomePage;
```

#### Expected Output

- Displays "Hello from server-side rendering!" rendered on the server.

#### Online Resources to Refer

1. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Getting Started with Next.js](https://nextjs.org/learn/basics/getting-started)

---

### Example 2: Fetching Data on the Server Side with getServerSideProps

#### Explanation

`getServerSideProps` is a Next.js function that allows you to fetch data on the server side before rendering a page. This function runs on every request, enabling you to fetch dynamic data and pre-render it on the server. Using `getServerSideProps`, you can ensure that your pages are always up-to-date with the latest data, improving both performance and user experience.

In this example, we will create a Next.js page that fetches data from an API on the server side using `getServerSideProps`. This demonstrates how to integrate data fetching into your server-side rendered pages.

#### Code to Practice

1. Setup a page with data fetching using `getServerSideProps`:

```javascript
// pages/data.js
import React from 'react';

function DataPage({ data }) {
  return (
    <div>
      <h1>Data from API</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
    </div>
  );
}

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const data = await res.json();

  return {
    props: {
      data,
    },
  };
}

export default DataPage;
```

#### Expected Output

- Displays data fetched from the API, rendered on the server.

#### Online Resources to Refer

1. [Data Fetching with Next.js](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [API Routes in Next.js](https://nextjs.org/docs/api-routes/introduction)

---

### Example 3: Combining SSR with Client-Side Rendering

#### Explanation

While server-side rendering can significantly improve performance and SEO, it is often beneficial to combine SSR with client-side rendering for enhanced interactivity and dynamic data fetching. This approach allows you to pre-render the initial HTML on the server while enabling the client to fetch and update data dynamically after the page has loaded.

In this example, we will create a Next.js page that combines SSR with client-side rendering. The page will fetch initial data on the server side and allow the client to fetch additional data interactively.

#### Code to Practice

1. Setup a page that combines SSR with client-side rendering:

```javascript
// pages/combined.js
import React, { useEffect, useState } from 'react';

function CombinedPage({ initialData }) {
  const [data, setData] = useState(initialData);
  const [loading, setLoading] = useState(false);

  const fetchData = async () => {
    setLoading(true);
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const newData = await res.json();
    setData(newData);
    setLoading(false);
  };

  return (
    <div>
      <h1>Initial Data</h1>
      <pre>{JSON.stringify(data, null, 2)}</pre>
      <button onClick={fetchData}>Fetch New Data</button>
      {loading && <p>Loading...</p>}
    </div>
  );
}

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const initialData = await res.json();

  return {
    props: {
      initialData,
    },
  };
}

export default CombinedPage;
```

#### Expected Output

- Displays initial data fetched from the server and allows fetching new data interactively on the client.

#### Online Resources to Refer

1. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)
2. [Combining SSR and CSR in Next.js](https://nextjs.org/docs/basic-features/pages#static-generation-with-client-side-rendering)

---

### Task 10: Implement SSR with Next.js for Mobile Cross-Platform Development using React Native

#### Explanation of the Topic

**Server-Side Rendering (SSR) with Next.js for Mobile**:
Server-Side Rendering (SSR) in Next.js can significantly enhance the performance and SEO of mobile web applications. By rendering the initial HTML content on the server, SSR ensures that the mobile app loads faster and provides a better user experience. This is especially crucial for mobile users who might have slower internet connections and limited processing power compared to desktop users. Next.js offers built-in support for SSR, making it easier to create dynamic and performant applications.

For cross-platform development using React Native, integrating Next.js with SSR can provide a seamless experience across web and mobile platforms. React Native for Web allows you to use React Native components and APIs in web applications. Combining this with Next.js SSR capabilities can create a consistent, high-performance application that runs efficiently on both mobile and web platforms.

#### Online Resources to Refer

1. [Next.js Documentation on SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [React Native for Web Documentation](https://necolas.github.io/react-native-web/docs/)

---

### Examples to Practice

1. **Basic SSR with Next.js for Mobile**
2. **Integrating React Native Components in Next.js with SSR**
3. **Optimizing Performance with SSR and React Native for Web**

---

### Example 1: Basic SSR with Next.js for Mobile

#### Explanation

Setting up basic server-side rendering with Next.js involves creating pages that are pre-rendered on the server. This process generates the HTML content on the server for each request and sends it to the client, ensuring faster initial load times and improved SEO. For mobile applications, this approach ensures that users receive content quickly, even on slower connections.

In this example, we will create a simple Next.js page that demonstrates basic server-side rendering. This will help you understand how to set up SSR in your Next.js application and the benefits it provides for mobile performance.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a basic SSR page:

```javascript
// pages/index.js
import React from 'react';

function HomePage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'Hello from server-side rendering on mobile!',
    },
  };
}

export default HomePage;
```

#### Expected Output

- Displays "Hello from server-side rendering on mobile!" rendered on the server.

#### Online Resources to Refer

1. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Getting Started with Next.js](https://nextjs.org/learn/basics/getting-started)

---

### Example 2: Integrating React Native Components in Next.js with SSR

#### Explanation

React Native for Web allows you to use React Native components in a web application, enabling code sharing between mobile and web platforms. By integrating React Native components with Next.js SSR, you can create a consistent UI and experience across different platforms. This approach ensures that your application benefits from SSR while maintaining the flexibility and familiarity of React Native components.

In this example, we will integrate React Native components into a Next.js application with server-side rendering. This demonstrates how to use React Native for Web to create a cross-platform application that leverages SSR for improved performance.

#### Code to Practice

1. Install `react-native-web`:

```sh
npm install react-native-web
```

2. Setup React Native components in a Next.js page:

```javascript
// pages/index.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
    </View>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'Hello from server-side rendering with React Native components!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default HomePage;
```

#### Expected Output

- Displays "Hello from server-side rendering with React Native components!" using React Native components rendered on the server.

#### Online Resources to Refer

1. [React Native for Web](https://necolas.github.io/react-native-web/docs/)
2. [Using React Native for Web with Next.js](https://dev.to/expo/using-next-js-with-react-native-for-web-38p4)

---

### Example 3: Optimizing Performance with SSR and React Native for Web

#### Explanation

Combining SSR with React Native for Web can significantly improve the performance of your application, especially for mobile users. By pre-rendering content on the server and using React Native components, you can ensure fast initial load times and a consistent experience across platforms. Additionally, optimizing the bundle size and caching strategies can further enhance performance.

In this example, we will optimize the performance of a Next.js application that uses React Native components. This includes setting up SSR, optimizing the bundle size, and implementing caching strategies to ensure a fast and responsive application.

#### Code to Practice

1. Install necessary packages:

```sh
npm install @zeit/next-bundle-analyzer next-compose-plugins
```

2. Setup Next.js with React Native for Web and optimization plugins:

```javascript
// next.config.js
const withPlugins = require('next-compose-plugins');
const withBundleAnalyzer = require('@zeit/next-bundle-analyzer');

module.exports = withPlugins([
  [withBundleAnalyzer, {
    analyzeServer: ['server', 'both'].includes(process.env.BUNDLE_ANALYZE),
    analyzeBrowser: ['browser', 'both'].includes(process.env.BUNDLE_ANALYZE),
    bundleAnalyzerConfig: {
      server: {
        analyzerMode: 'static',
        reportFilename: '../bundles/server.html',
      },
      browser: {
        analyzerMode: 'static',
        reportFilename: '../bundles/client.html',
      },
    },
  }],
  {
    webpack(config) {
      config.resolve.alias = {
        ...(config.resolve.alias || {}),
        'react-native$': 'react-native-web',
      };
      return config;
    },
  }
]);
```

3. Setup a page with optimized SSR:

```javascript
// pages/index.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
    </View>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'Optimized SSR with React Native components!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default HomePage;
```

#### Expected Output

- Displays "Optimized SSR with React Native components!" with optimized performance and bundle size.

#### Online Resources to Refer

1. [Next.js Performance Optimization](https://nextjs.org/docs/advanced-features/measuring-performance)
2. [React Native for Web Performance](https://necolas.github.io/react-native-web/docs/performance/)

---

### Task 11: Study Static Site Generation with Next.js for Cross-Platform Development using React Native

#### Explanation of the Topic

**Static Site Generation (SSG) with Next.js**:
Static Site Generation (SSG) is a method of pre-rendering pages at build time, resulting in static HTML files that can be served quickly to users. This approach is beneficial for performance and SEO, as the pages are already rendered and do not require server-side processing for each request. Next.js offers built-in support for SSG through the `getStaticProps` and `getStaticPaths` functions, making it easy to generate static content.

Using SSG in Next.js, you can build highly performant and scalable applications by leveraging pre-rendered static pages. This is particularly useful for content-heavy sites like blogs, documentation, and marketing websites. Additionally, integrating SSG with React Native for Web allows you to create consistent and fast-loading experiences across both mobile and web platforms.

#### Online Resources to Refer

1. [Next.js Documentation on Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Introduction to Static Site Generation with Next.js](https://www.smashingmagazine.com/2020/10/introduction-static-site-generation-nextjs/)

---

### Examples to Practice

1. **Basic Static Site Generation with Next.js**
2. **Generating Dynamic Routes with getStaticPaths**
3. **Combining SSG with React Native for Web**

---

### Example 1: Basic Static Site Generation with Next.js

#### Explanation

Static Site Generation in Next.js involves pre-rendering pages at build time using the `getStaticProps` function. This function allows you to fetch data during the build process and pass it as props to your page component. The result is a static HTML file that can be served to users instantly, improving performance and SEO.

In this example, we will create a simple Next.js page that demonstrates basic static site generation. We will use `getStaticProps` to fetch data at build time and render it as a static page.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a basic static site generation page:

```javascript
// pages/index.js
import React from 'react';

function HomePage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Hello from static site generation!',
    },
  };
}

export default HomePage;
```

#### Expected Output

- Displays "Hello from static site generation!" as a static HTML page.

#### Online Resources to Refer

1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Tutorial](https://nextjs.org/learn/basics/create-nextjs-app)

---

### Example 2: Generating Dynamic Routes with getStaticPaths

#### Explanation

Generating dynamic routes in a static site involves using the `getStaticPaths` function in Next.js. This function allows you to specify which dynamic routes should be pre-rendered at build time. Combined with `getStaticProps`, you can fetch data for each dynamic route and generate static pages for them, ensuring fast and optimized loading.

In this example, we will create a Next.js page with dynamic routes. We will use `getStaticPaths` to define the routes and `getStaticProps` to fetch data for each route, demonstrating how to generate static pages for dynamic content.

#### Code to Practice

1. Setup a page with dynamic routes and static generation:

```javascript
// pages/posts/[id].js
import React from 'react';

function PostPage({ post }) {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
}

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
}

export default PostPage;
```

#### Expected Output

- Displays a static page for each post with dynamic routes pre-rendered at build time.

#### Online Resources to Refer

1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [Next.js getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)

---

### Example 3: Combining SSG with React Native for Web

#### Explanation

Combining Static Site Generation (SSG) with React Native for Web allows you to use React Native components in a static site generated by Next.js. This approach ensures that your web application benefits from the performance and SEO advantages of SSG while maintaining a consistent UI and codebase across mobile and web platforms.

In this example, we will integrate React Native for Web into a Next.js project and use SSG to generate static pages. This demonstrates how to create a cross-platform application with optimized performance and consistent UI components.

#### Code to Practice

1. Install `react-native-web`:

```sh
npm install react-native-web
```

2. Setup a page with React Native components and static generation:

```javascript
// pages/index.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
    </View>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Static site generation with React Native components!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default HomePage;
```

3. Configure Next.js to use React Native for Web:

```javascript
// next.config.js
const withPlugins = require('next-compose-plugins');
const withTM = require('next-transpile-modules')(['react-native-web']);

module.exports = withPlugins([
  withTM,
  {
    webpack: (config) => {
      config.resolve.alias = {
        ...(config.resolve.alias || {}),
        'react-native$': 'react-native-web',
      };
      return config;
    },
  },
]);
```

#### Expected Output

- Displays "Static site generation with React Native components!" using React Native components in a statically generated page.

#### Online Resources to Refer

1. [React Native for Web](https://necolas.github.io/react-native-web/docs/)
2. [Using React Native for Web with Next.js](https://dev.to/expo/using-next-js-with-react-native-for-web-38p4)

---

### Task 12: Implement SSG with Next.js for Mobile Cross-Platform Development using React Native

#### Explanation of the Topic

**Static Site Generation (SSG) with Next.js for Mobile**:
Static Site Generation (SSG) in Next.js is a technique that pre-renders HTML pages at build time, which can then be served as static files. This method is particularly advantageous for mobile applications because it ensures fast initial load times and improved performance, even on slower networks. SSG also enhances SEO, as search engines can index the pre-rendered content more effectively.

For cross-platform development using React Native, integrating Next.js SSG allows you to maintain a consistent codebase across mobile and web platforms. React Native for Web enables you to use React Native components in web applications, providing a seamless experience. By combining SSG with React Native for Web, you can create performant, SEO-friendly mobile web applications with a consistent UI.

#### Online Resources to Refer

1. [Next.js Documentation on Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [React Native for Web Documentation](https://necolas.github.io/react-native-web/docs/)

---

### Examples to Practice

1. **Basic Static Site Generation with Next.js for Mobile**
2. **Generating Dynamic Routes with getStaticPaths**
3. **Combining SSG with React Native for Web**

---

### Example 1: Basic Static Site Generation with Next.js for Mobile

#### Explanation

Static Site Generation (SSG) in Next.js involves pre-rendering pages at build time using the `getStaticProps` function. This approach generates static HTML files, which are then served to users instantly, improving performance and SEO. For mobile applications, this ensures that users receive content quickly, even on slower connections.

In this example, we will create a simple Next.js page that demonstrates basic static site generation. We will use `getStaticProps` to fetch data at build time and render it as a static page, optimizing the initial load time for mobile users.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a basic static site generation page:

```javascript
// pages/index.js
import React from 'react';

function HomePage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Hello from static site generation for mobile!',
    },
  };
}

export default HomePage;
```

#### Expected Output

- Displays "Hello from static site generation for mobile!" as a static HTML page.

#### Online Resources to Refer

1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Tutorial](https://nextjs.org/learn/basics/create-nextjs-app)

---

### Example 2: Generating Dynamic Routes with getStaticPaths

#### Explanation

Generating dynamic routes in a static site involves using the `getStaticPaths` function in Next.js. This function allows you to specify which dynamic routes should be pre-rendered at build time. Combined with `getStaticProps`, you can fetch data for each dynamic route and generate static pages for them, ensuring fast and optimized loading for mobile users.

In this example, we will create a Next.js page with dynamic routes. We will use `getStaticPaths` to define the routes and `getStaticProps` to fetch data for each route, demonstrating how to generate static pages for dynamic content in a mobile-friendly manner.

#### Code to Practice

1. Setup a page with dynamic routes and static generation:

```javascript
// pages/posts/[id].js
import React from 'react';

function PostPage({ post }) {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
}

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
}

export default PostPage;
```

#### Expected Output

- Displays a static page for each post with dynamic routes pre-rendered at build time, optimized for mobile.

#### Online Resources to Refer

1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [Next.js getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)

---

### Example 3: Combining SSG with React Native for Web

#### Explanation

Combining Static Site Generation (SSG) with React Native for Web allows you to use React Native components in a static site generated by Next.js. This approach ensures that your web application benefits from the performance and SEO advantages of SSG while maintaining a consistent UI and codebase across mobile and web platforms.

In this example, we will integrate React Native for Web into a Next.js project and use SSG to generate static pages. This demonstrates how to create a cross-platform application with optimized performance and consistent UI components.

#### Code to Practice

1. Install `react-native-web`:

```sh
npm install react-native-web
```

2. Setup a page with React Native components and static generation:

```javascript
// pages/index.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
    </View>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Static site generation with React Native components for mobile!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
});

export default HomePage;
```

3. Configure Next.js to use React Native for Web:

```javascript
// next.config.js
const withPlugins = require('next-compose-plugins');
const withTM = require('next-transpile-modules')(['react-native-web']);

module.exports = withPlugins([
  withTM,
  {
    webpack: (config) => {
      config.resolve.alias = {
        ...(config.resolve.alias || {}),
        'react-native$': 'react-native-web',
      };
      return config;
    },
  },
]);
```

#### Expected Output

- Displays "Static site generation with React Native components for mobile!" using React Native components in a statically generated page.

#### Online Resources to Refer

1. [React Native for Web](https://necolas.github.io/react-native-web/docs/)
2. [Using React Native for Web with Next.js](https://dev.to/expo/using-next-js-with-react-native-for-web-38p4)

---

### Task 13: Study Hybrid Rendering with Next.js for Cross-Platform Development using React Native

#### Explanation of the Topic

**Hybrid Rendering with Next.js**:
Hybrid rendering in Next.js refers to the ability to combine different rendering strategies within a single application. Next.js supports Static Site Generation (SSG), Server-Side Rendering (SSR), and Client-Side Rendering (CSR). By leveraging hybrid rendering, developers can choose the best rendering method for each page or component, optimizing performance, SEO, and user experience. This flexibility allows for a more dynamic and efficient application that can cater to different needs and scenarios.

For cross-platform development using React Native, integrating hybrid rendering with Next.js can provide a seamless and performant experience across web and mobile platforms. React Native for Web allows you to use React Native components in web applications, and by combining this with Next.js's hybrid rendering capabilities, you can create a consistent and optimized application for both web and mobile users.

#### Online Resources to Refer

1. [Next.js Hybrid Rendering](https://nextjs.org/docs/advanced-features/static-html-export)
2. [Understanding Hybrid Rendering in Next.js](https://blog.logrocket.com/next-js-hybrid-rendering-complete-guide/)

---

### Examples to Practice

1. **Combining SSG and SSR in Next.js**
2. **Using Client-Side Rendering with Next.js**
3. **Hybrid Rendering with React Native for Web**

---

### Example 1: Combining SSG and SSR in Next.js

#### Explanation

Combining Static Site Generation (SSG) and Server-Side Rendering (SSR) in Next.js allows you to optimize different parts of your application based on their specific needs. SSG is ideal for pages that do not change frequently and need to load quickly, while SSR is better suited for dynamic pages that require up-to-date data on each request. By using both methods, you can ensure that your application is both fast and responsive.

In this example, we will create a Next.js application that uses SSG for a static page and SSR for a dynamic page. This demonstrates how to combine different rendering strategies within a single application.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a static page with SSG:

```javascript
// pages/static.js
import React from 'react';

function StaticPage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'This is a static page generated at build time.',
    },
  };
}

export default StaticPage;
```

3. Setup a dynamic page with SSR:

```javascript
// pages/dynamic.js
import React from 'react';

function DynamicPage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'This is a dynamic page generated at request time.',
    },
  };
}

export default DynamicPage;
```

#### Expected Output

- **StaticPage**: Displays "This is a static page generated at build time."
- **DynamicPage**: Displays "This is a dynamic page generated at request time."

#### Online Resources to Refer

1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)

---

### Example 2: Using Client-Side Rendering with Next.js

#### Explanation

Client-Side Rendering (CSR) in Next.js allows you to render components on the client side, enabling dynamic and interactive user experiences. CSR is useful for parts of the application that need to interact with the user and update frequently without requiring a full page refresh. By combining CSR with SSG and SSR, you can optimize the performance of your application while maintaining interactivity.

In this example, we will create a Next.js page that fetches data on the client side. This demonstrates how to implement CSR in a Next.js application and integrate it with other rendering strategies.

#### Code to Practice

1. Setup a page with client-side rendering:

```javascript
// pages/client-side.js
import React, { useEffect, useState } from 'react';

function ClientSidePage() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(data => setData(data));
  }, []);

  if (!data) return <div>Loading...</div>;

  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.body}</p>
    </div>
  );
}

export default ClientSidePage;
```

#### Expected Output

- Fetches and displays data from an API on the client side after the initial page load.

#### Online Resources to Refer

1. [Client-Side Data Fetching in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)
2. [Next.js Client-Side Rendering](https://nextjs.org/docs/basic-features/data-fetching)

---

### Example 3: Hybrid Rendering with React Native for Web

#### Explanation

Hybrid rendering with React Native for Web and Next.js allows you to create a consistent and optimized application for both web and mobile platforms. By using React Native components and combining SSG, SSR, and CSR, you can ensure that your application is performant, interactive, and SEO-friendly. This approach leverages the strengths of each rendering strategy to create a seamless cross-platform experience.

In this example, we will integrate React Native for Web into a Next.js project and use hybrid rendering strategies. This demonstrates how to create a cross-platform application with optimized performance and consistent UI components.

#### Code to Practice

1. Install `react-native-web`:

```sh
npm install react-native-web
```

2. Setup a page with React Native components and hybrid rendering:

```javascript
// pages/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(data => setData(data));
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
      {data ? (
        <View style={styles.post}>
          <Text style={styles.title}>{data.title}</Text>
          <Text style={styles.body}>{data.body}</Text>
        </View>
      ) : (
        <Text>Loading...</Text>
      )}
    </View>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Hybrid rendering with React Native components!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
  post: {
    marginTop: 20,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  body: {
    fontSize: 16,
  },
});

export default HomePage;
```

3. Configure Next.js to use React Native for Web:

```javascript
// next.config.js
const withPlugins = require('next-compose-plugins');
const withTM = require('next-transpile-modules')(['react-native-web']);

module.exports = withPlugins([
  withTM,
  {
    webpack: (config) => {
      config.resolve.alias = {
        ...(config.resolve.alias || {}),
        'react-native$': 'react-native-web',
      };
      return config;
    },
  },
]);
```

#### Expected Output

- Displays "Hybrid rendering with React Native components!" using React Native components.
- Fetches and displays data from an API on the client side.

#### Online Resources to Refer

1. [React Native for Web](https://necolas.github.io/react-native-web/docs/)
2. [Using React Native for Web with Next.js](https://dev.to/expo/using-next-js-with-react-native-for-web-38p4)

---

### Task 14: Implement Hybrid Rendering with Next.js for Mobile Cross-Platform Development using React Native

#### Explanation of the Topic

**Hybrid Rendering with Next.js**:
Hybrid rendering in Next.js combines different rendering techniques, such as Static Site Generation (SSG), Server-Side Rendering (SSR), and Client-Side Rendering (CSR). This approach allows you to optimize different parts of your application based on their specific needs. SSG generates static HTML at build time, SSR renders pages on the server for each request, and CSR allows for dynamic and interactive experiences by rendering on the client side.

For mobile cross-platform development using React Native, hybrid rendering with Next.js can significantly enhance performance and user experience. By leveraging SSG and SSR, you can ensure fast initial loads and improved SEO. CSR enables interactivity and dynamic data fetching. Integrating React Native for Web with Next.js allows you to use React Native components across web and mobile platforms, maintaining a consistent codebase and UI.

#### Online Resources to Refer

1. [Next.js Hybrid Rendering](https://nextjs.org/docs/advanced-features/static-html-export)
2. [React Native for Web Documentation](https://necolas.github.io/react-native-web/docs/)

---

### Examples to Practice

1. **Combining SSG and SSR in Next.js**
2. **Using Client-Side Rendering with Next.js**
3. **Hybrid Rendering with React Native for Web**

---

### Example 1: Combining SSG and SSR in Next.js

#### Explanation

Combining Static Site Generation (SSG) and Server-Side Rendering (SSR) in Next.js allows you to optimize different parts of your application based on their specific needs. SSG is ideal for pages that do not change frequently and need to load quickly, while SSR is better suited for dynamic pages that require up-to-date data on each request. By using both methods, you can ensure that your application is both fast and responsive.

In this example, we will create a Next.js application that uses SSG for a static page and SSR for a dynamic page. This demonstrates how to combine different rendering strategies within a single application.

#### Code to Practice

1. Create a new Next.js application:

```sh
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

2. Setup a static page with SSG:

```javascript
// pages/static.js
import React from 'react';

function StaticPage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'This is a static page generated at build time.',
    },
  };
}

export default StaticPage;
```

3. Setup a dynamic page with SSR:

```javascript
// pages/dynamic.js
import React from 'react';

function DynamicPage({ message }) {
  return (
    <div>
      <h1>{message}</h1>
    </div>
  );
}

export async function getServerSideProps() {
  return {
    props: {
      message: 'This is a dynamic page generated at request time.',
    },
  };
}

export default DynamicPage;
```

#### Expected Output

- **StaticPage**: Displays "This is a static page generated at build time."
- **DynamicPage**: Displays "This is a dynamic page generated at request time."

#### Online Resources to Refer

1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)

---

### Example 2: Using Client-Side Rendering with Next.js

#### Explanation

Client-Side Rendering (CSR) in Next.js allows you to render components on the client side, enabling dynamic and interactive user experiences. CSR is useful for parts of the application that need to interact with the user and update frequently without requiring a full page refresh. By combining CSR with SSG and SSR, you can optimize the performance of your application while maintaining interactivity.

In this example, we will create a Next.js page that fetches data on the client side. This demonstrates how to implement CSR in a Next.js application and integrate it with other rendering strategies.

#### Code to Practice

1. Setup a page with client-side rendering:

```javascript
// pages/client-side.js
import React, { useEffect, useState } from 'react';

function ClientSidePage() {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(data => setData(data));
  }, []);

  if (!data) return <div>Loading...</div>;

  return (
    <div>
      <h1>{data.title}</h1>
      <p>{data.body}</p>
    </div>
  );
}

export default ClientSidePage;
```

#### Expected Output

- Fetches and displays data from an API on the client side after the initial page load.

#### Online Resources to Refer

1. [Client-Side Data Fetching in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)
2. [Next.js Client-Side Rendering](https://nextjs.org/docs/basic-features/data-fetching)

---

### Example 3: Hybrid Rendering with React Native for Web

#### Explanation

Hybrid rendering with React Native for Web and Next.js allows you to create a consistent and optimized application for both web and mobile platforms. By using React Native components and combining SSG, SSR, and CSR, you can ensure that your application is performant, interactive, and SEO-friendly. This approach leverages the strengths of each rendering strategy to create a seamless cross-platform experience.

In this example, we will integrate React Native for Web into a Next.js project and use hybrid rendering strategies. This demonstrates how to create a cross-platform application with optimized performance and consistent UI components.

#### Code to Practice

1. Install `react-native-web`:

```sh
npm install react-native-web
```

2. Setup a page with React Native components and hybrid rendering:

```javascript
// pages/index.js
import React, { useEffect, useState } from 'react';
import { View, Text, StyleSheet } from 'react-native';

function HomePage({ message }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    fetch('https://jsonplaceholder.typicode.com/posts/1')
      .then(response => response.json())
      .then(data => setData(data));
  }, []);

  return (
    <View style={styles.container}>
      <Text style={styles.text}>{message}</Text>
      {data ? (
        <View style={styles.post}>
          <Text style={styles.title}>{data.title}</Text>
          <Text style={styles.body}>{data.body}</Text>
        </View>
      ) : (
        <Text>Loading...</Text>
      )}
    </View>
  );
}

export async function getStaticProps() {
  return {
    props: {
      message: 'Hybrid rendering with React Native components!',
    },
  };
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
  },
  post: {
    marginTop: 20,
  },
  title: {
    fontSize: 18,
    fontWeight: 'bold',
  },
  body: {
    fontSize: 16,
  },
});

export default HomePage;
```

3. Configure Next.js to use React Native for Web:

```javascript
// next.config.js
const withPlugins = require('next-compose-plugins');
const withTM = require('next-transpile-modules')(['react-native-web']);

module.exports = withPlugins([
  withTM,
  {
    webpack: (config) => {
      config.resolve.alias = {
        ...(config.resolve.alias || {}),
        'react-native$': 'react-native-web',
      };
      return config;
    },
  },
]);
```

#### Expected Output

- Displays "Hybrid rendering with React Native components!" using React Native components.
- Fetches and displays data from an API on the client side.

#### Online Resources to Refer

1. [React Native for Web](https://necolas.github.io/react-native-web/docs/)
2. [Using React Native for Web with Next.js](https://dev.to/expo/using-next-js-with-react-native-for-web-38p4)

---

### Task 15: Study Advanced Data Synchronization Techniques for Cross-Platform Development using React Native

#### Explanation of the Topic

**Advanced Data Synchronization Techniques**:
Data synchronization is the process of ensuring that data remains consistent and up-to-date across multiple devices and platforms. Advanced techniques in data synchronization are crucial for developing robust, cross-platform applications where users expect seamless transitions between online and offline states. Key strategies include conflict resolution, real-time updates, and ensuring data integrity across distributed systems. Implementing these techniques can significantly enhance user experience by providing reliable and consistent data access.

In the context of React Native for cross-platform development, advanced data synchronization techniques ensure that your mobile and web applications stay synchronized with the backend in real-time, regardless of connectivity issues. This involves leveraging technologies like WebSockets, offline-first architecture with local storage, and background data sync. By mastering these techniques, developers can create applications that are both performant and resilient, providing a seamless user experience.

#### Online Resources to Refer

1. [Offline Data Synchronization in React Native](https://medium.com/swlh/offline-data-synchronization-in-react-native-d0b9a4e64402)
2. [Data Synchronization Strategies](https://www.couchbase.com/resources/whitepapers/data-sync-strategies)

---

### Examples to Practice

1. **Using WebSockets for Real-Time Data Synchronization**
2. **Implementing Offline-First Data Synchronization**
3. **Conflict Resolution in Data Synchronization**

---

### Example 1: Using WebSockets for Real-Time Data Synchronization

#### Explanation

WebSockets provide a full-duplex communication channel over a single TCP connection, enabling real-time data synchronization between the client and server. This is particularly useful for applications that require instant updates, such as chat applications, collaborative tools, or live data feeds. By using WebSockets in a React Native application, you can ensure that changes made on one device are immediately reflected on all connected devices.

In this example, we will set up a WebSocket connection in a React Native application to synchronize a list of messages in real-time. This demonstrates how to use WebSockets for real-time data updates and synchronization.

#### Code to Practice

1. Setup WebSocket for real-time data synchronization:

```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';

const WS_URL = 'wss://your-websocket-server.com';

function App() {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');

  useEffect(() => {
    const ws = new WebSocket(WS_URL);

    ws.onopen = () => {
      console.log('WebSocket connection opened');
    };

    ws.onmessage = (event) => {
      const newMessage = JSON.parse(event.data);
      setMessages((prevMessages) => [...prevMessages, newMessage]);
    };

    ws.onclose = () => {
      console.log('WebSocket connection closed');
    };

    return () => {
      ws.close();
    };
  }, []);

  const sendMessage = () => {
    const ws = new WebSocket(WS_URL);
    ws.onopen = () => {
      ws.send(JSON.stringify({ content: message }));
      setMessage('');
    };
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item.content}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
}

export default App;
```

#### Expected Output

- Real-time updates to the list of messages as they are sent and received via WebSocket.

#### Online Resources to Refer

1. [Using WebSockets in React Native](https://reactnative.dev/docs/network#using-websockets)
2. [WebSocket API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)

---

### Example 2: Implementing Offline-First Data Synchronization

#### Explanation

An offline-first approach ensures that an application remains functional even without an internet connection. This involves storing data locally and synchronizing it with the server when the connection is restored. Implementing offline-first data synchronization can be achieved using libraries like `redux-offline`, which handles offline persistence and synchronization seamlessly.

In this example, we will use `redux-offline` to manage offline data synchronization in a React Native application. This demonstrates how to ensure that data remains consistent and the application remains functional during network outages.

#### Code to Practice

1. Install `redux` and `redux-offline`:

```sh
npm install redux redux-offline
```

2. Setup offline-first data synchronization:

```javascript
// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import { createStore, applyMiddleware } from 'redux';
import offlineMiddleware, { networkStatusChanged } from '@redux-offline/redux-offline';
import offlineConfig from '@redux-offline/redux-offline/lib/defaults';
import { View, Text, TextInput, Button, FlatList } from 'react-native';

// Actions
const ADD_MESSAGE = 'ADD_MESSAGE';
const SYNC_MESSAGE = 'SYNC_MESSAGE';

// Reducer
const initialState = {
  messages: [],
  isConnected: true,
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case ADD_MESSAGE:
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case SYNC_MESSAGE:
      return {
        ...state,
        messages: state.messages.map((msg) =>
          msg.id === action.payload.id ? { ...msg, synced: true } : msg
        ),
      };
    case 'Offline/STATUS_CHANGED':
      return {
        ...state,
        isConnected: action.payload,
      };
    default:
      return state;
  }
};

// Store
const store = createStore(reducer, applyMiddleware(offlineMiddleware(offlineConfig)));

function App() {
  const messages = useSelector((state) => state.messages);
  const isConnected = useSelector((state) => state.isConnected);
  const dispatch = useDispatch();
  const [message, setMessage] = useState('');

  const sendMessage = () => {
    const newMessage = { id: Math.random().toString(), content: message, synced: false };
    dispatch({ type: ADD_MESSAGE, payload: newMessage });
    setMessage('');

    if (isConnected) {
      // Simulate server sync
      setTimeout(() => {
        dispatch({ type: SYNC_MESSAGE, payload: newMessage });
      }, 1000);
    }
  };

  return (
    <Provider store={store}>
      <View style={{ padding: 20 }}>
        <FlatList
          data={messages}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item }) => (
            <Text style={{ textDecorationLine: item.synced ? 'none' : 'line-through' }}>
              {item.content}
            </Text>
          )}
        />
        <TextInput
          value={message}
          onChangeText={setMessage}
          placeholder="Type a message"
          style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
        />
        <Button title="Send" onPress={sendMessage} />
      </View>
    </Provider>
  );
}

export default App;
```

#### Expected Output

- Displays messages and handles offline-first data synchronization, indicating unsynced messages with a strikethrough.

#### Online Resources to Refer

1. [Offline Data Synchronization in React Native](https://medium.com/swlh/offline-data-synchronization-in-react-native-d0b9a4e64402)
2. [Redux Offline Documentation](https://redux-offline.gitbook.io/redux-offline/)

---

### Example 3: Conflict Resolution in Data Synchronization

#### Explanation

Conflict resolution is a critical aspect of data synchronization, especially when multiple devices or users are involved. Conflicts occur when concurrent changes are made to the same data. Effective conflict resolution strategies ensure that data remains consistent and accurate across all devices. Common strategies include last-write-wins, merge algorithms, and user-driven conflict resolution.

In this example, we will implement a simple conflict resolution strategy in a React Native application. We will simulate concurrent updates to the same data and resolve conflicts using a last-write-wins approach.

#### Code to Practice

1. Simulate conflict resolution in data synchronization:

```javascript
// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import { createStore, applyMiddleware } from 'redux';
import offlineMiddleware, { networkStatusChanged } from '@redux-offline/redux-offline';
import offlineConfig from '@redux-offline/redux-offline/lib/defaults';
import { View, Text, TextInput, Button, FlatList } from 'react-native';

// Actions
const ADD_MESSAGE = 'ADD_MESSAGE';
const SYNC_MESSAGE = 'SYNC_MESSAGE';
const RESOLVE_CONFLICT = 'RESOLVE_CONFLICT';

// Reducer
const initialState = {
  messages: [],
  isConnected: true,
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case ADD_MESSAGE:
      return {
        ...state,
        messages: [...state.messages, action.payload],
      };
    case

 SYNC_MESSAGE:
      return {
        ...state,
        messages: state.messages.map((msg) =>
          msg.id === action.payload.id ? { ...msg, synced: true } : msg
        ),
      };
    case RESOLVE_CONFLICT:
      return {
        ...state,
        messages: state.messages.map((msg) =>
          msg.id === action.payload.id ? action.payload : msg
        ),
      };
    case 'Offline/STATUS_CHANGED':
      return {
        ...state,
        isConnected: action.payload,
      };
    default:
      return state;
  }
};

// Store
const store = createStore(reducer, applyMiddleware(offlineMiddleware(offlineConfig)));

function App() {
  const messages = useSelector((state) => state.messages);
  const isConnected = useSelector((state) => state.isConnected);
  const dispatch = useDispatch();
  const [message, setMessage] = useState('');

  const sendMessage = () => {
    const newMessage = { id: Math.random().toString(), content: message, synced: false };
    dispatch({ type: ADD_MESSAGE, payload: newMessage });
    setMessage('');

    if (isConnected) {
      // Simulate server sync
      setTimeout(() => {
        dispatch({ type: SYNC_MESSAGE, payload: newMessage });
      }, 1000);
    }
  };

  const resolveConflict = (messageId, newContent) => {
    const resolvedMessage = { id: messageId, content: newContent, synced: true };
    dispatch({ type: RESOLVE_CONFLICT, payload: resolvedMessage });
  };

  return (
    <Provider store={store}>
      <View style={{ padding: 20 }}>
        <FlatList
          data={messages}
          keyExtractor={(item, index) => index.toString()}
          renderItem={({ item }) => (
            <View>
              <Text style={{ textDecorationLine: item.synced ? 'none' : 'line-through' }}>
                {item.content}
              </Text>
              {!item.synced && (
                <Button
                  title="Resolve Conflict"
                  onPress={() => resolveConflict(item.id, 'Resolved content')}
                />
              )}
            </View>
          )}
        />
        <TextInput
          value={message}
          onChangeText={setMessage}
          placeholder="Type a message"
          style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
        />
        <Button title="Send" onPress={sendMessage} />
      </View>
    </Provider>
  );
}

export default App;
```

#### Expected Output

- Displays messages and handles conflict resolution by allowing the user to resolve unsynced messages.

#### Online Resources to Refer

1. [Data Synchronization Strategies](https://www.couchbase.com/resources/whitepapers/data-sync-strategies)
2. [Handling Conflicts in Data Synchronization](https://firebase.google.com/docs/firestore/manage-data/enable-offline#handling_concurrent_updates)

---

### Task 16: Implement Data Sync with Firestore for Cross-Platform Development using React Native

#### Explanation of the Topic

**Data Synchronization with Firestore**:
Firestore is a NoSQL cloud database from Firebase that enables developers to build rich, scalable applications quickly. It provides powerful tools for data synchronization across multiple devices, making it ideal for cross-platform applications developed with React Native. Firestore handles real-time updates and offline data persistence out-of-the-box, ensuring a seamless user experience regardless of network connectivity.

Data synchronization with Firestore involves setting up listeners to track real-time changes in the database, ensuring that all connected clients receive updates as soon as they occur. Additionally, Firestore supports offline capabilities, allowing applications to cache data locally and synchronize changes once the device goes back online. This feature is particularly useful for mobile applications, where connectivity can be intermittent.

#### Online Resources to Refer

1. [Firestore Documentation](https://firebase.google.com/docs/firestore)
2. [React Native Firebase Documentation](https://rnfirebase.io/firestore/usage)

---

### Examples to Practice

1. **Setting Up Firestore in a React Native Application**
2. **Real-Time Data Synchronization with Firestore**
3. **Handling Offline Data with Firestore**

---

### Example 1: Setting Up Firestore in a React Native Application

#### Explanation

Setting up Firestore in a React Native application involves configuring Firebase in your project and initializing Firestore. This step is essential to enable data synchronization and real-time updates. Firestore's integration with React Native allows you to use its powerful features, such as real-time listeners and offline data persistence, to build robust cross-platform applications.

In this example, we will set up Firebase and Firestore in a React Native application. This involves installing the necessary dependencies, configuring Firebase, and initializing Firestore.

#### Code to Practice

1. Install Firebase and React Native Firebase dependencies:

```sh
npm install @react-native-firebase/app @react-native-firebase/firestore
```

2. Configure Firebase in your React Native project:

```javascript
// firebaseConfig.js
import firebase from '@react-native-firebase/app';
import firestore from '@react-native-firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

export { firebase, firestore };
```

3. Initialize Firestore in your application:

```javascript
// App.js
import React from 'react';
import { View, Text } from 'react-native';
import { firebase, firestore } from './firebaseConfig';

function App() {
  return (
    <View>
      <Text>Firestore is set up!</Text>
    </View>
  );
}

export default App;
```

#### Expected Output

- Displays "Firestore is set up!" indicating that Firestore has been successfully configured.

#### Online Resources to Refer

1. [Firestore Setup](https://firebase.google.com/docs/firestore/quickstart)
2. [React Native Firebase Setup](https://rnfirebase.io/)

---

### Example 2: Real-Time Data Synchronization with Firestore

#### Explanation

Real-time data synchronization in Firestore involves setting up listeners that track changes to the data in the database. These listeners ensure that any updates to the data are immediately reflected in the application, providing a seamless user experience. This is particularly useful for applications that require real-time updates, such as chat apps or collaborative tools.

In this example, we will set up a Firestore listener in a React Native application to synchronize a list of messages in real-time. This demonstrates how to use Firestore's real-time capabilities to keep the application data up-to-date.

#### Code to Practice

1. Setup real-time data synchronization:

```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { firestore } from './firebaseConfig';

function App() {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');

  useEffect(() => {
    const unsubscribe = firestore()
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .onSnapshot((snapshot) => {
        const messages = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setMessages(messages);
      });

    return () => unsubscribe();
  }, []);

  const sendMessage = async () => {
    if (message.trim()) {
      await firestore().collection('messages').add({
        content: message,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      });
      setMessage('');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <Text>{item.content}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
}

export default App;
```

#### Expected Output

- Displays a real-time updated list of messages as they are added to the Firestore collection.

#### Online Resources to Refer

1. [Firestore Real-Time Updates](https://firebase.google.com/docs/firestore/query-data/listen)
2. [React Native Firebase Firestore](https://rnfirebase.io/firestore/usage)

---

### Example 3: Handling Offline Data with Firestore

#### Explanation

Firestore's offline capabilities allow your application to function seamlessly even when there is no network connection. Firestore caches data locally, enabling users to read and write data while offline. Once the connection is restored, Firestore automatically synchronizes any changes made while offline with the server, ensuring data consistency.

In this example, we will demonstrate how to handle offline data with Firestore in a React Native application. This includes enabling offline persistence and ensuring that data changes are synchronized once the device goes back online.

#### Code to Practice

1. Enable offline persistence and handle offline data:

```javascript
// firebaseConfig.js
import firebase from '@react-native-firebase/app';
import firestore from '@react-native-firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

firestore().settings({
  persistence: true,
});

export { firebase, firestore };
```

2. Setup offline data handling in your application:

```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import { firestore } from './firebaseConfig';

function App() {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');

  useEffect(() => {
    const unsubscribe = firestore()
      .collection('messages')
      .orderBy('createdAt', 'desc')
      .onSnapshot((snapshot) => {
        const messages = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setMessages(messages);
      });

    return () => unsubscribe();
  }, []);

  const sendMessage = async () => {
    if (message.trim()) {
      await firestore().collection('messages').add({
        content: message,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      });
      setMessage('');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <Text>{item.content}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
}

export default App;
```

#### Expected Output

- Displays a list of messages that can be updated offline and synchronized with Firestore once the connection is restored.

#### Online Resources to Refer

1. [Firestore Offline Persistence](https://firebase.google.com/docs/firestore/manage-data/enable-offline)
2. [Handling Offline Data in Firestore](https://rnfirebase.io/firestore/usage#offline-data)

---

### Task 17: Study Secure Storage Solutions for Cross-Platform Development using React Native

#### Explanation of the Topic

**Secure Storage Solutions**:
Secure storage solutions are critical in mobile applications to protect sensitive data such as user credentials, tokens, and personal information. In React Native, secure storage can be achieved using libraries that leverage the underlying platform's secure storage mechanisms, such as Keychain on iOS and Keystore on Android. These libraries ensure that data is encrypted and protected from unauthorized access, even if the device is compromised.

Implementing secure storage solutions involves choosing the right library, integrating it into your React Native application, and following best practices to ensure data security. This includes encrypting data before storage, using strong encryption algorithms, and managing encryption keys securely. By mastering these techniques, developers can build applications that safeguard user data and comply with security regulations.

#### Online Resources to Refer

1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Secure Storage Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)

---

### Examples to Practice

1. **Storing and Retrieving Data with React Native Keychain**
2. **Using Secure Storage for Authentication Tokens**
3. **Encrypting Data before Secure Storage**

---

### Example 1: Storing and Retrieving Data with React Native Keychain

#### Explanation

React Native Keychain is a library that provides an abstraction for storing and retrieving sensitive data securely using the Keychain on iOS and the Keystore on Android. It allows developers to store credentials, tokens, and other sensitive information securely. Integrating React Native Keychain into your application ensures that sensitive data is encrypted and protected from unauthorized access.

In this example, we will use React Native Keychain to store and retrieve user credentials securely. This demonstrates how to integrate secure storage into your React Native application to protect sensitive data.

#### Code to Practice

1. Install React Native Keychain:

```sh
npm install react-native-keychain
npx pod-install
```

2. Setup secure storage for storing and retrieving credentials:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

function App() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [storedUsername, setStoredUsername] = useState('');
  const [storedPassword, setStoredPassword] = useState('');

  const storeCredentials = async () => {
    await Keychain.setGenericPassword(username, password);
    Alert.alert('Credentials saved securely!');
  };

  const retrieveCredentials = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials) {
      setStoredUsername(credentials.username);
      setStoredPassword(credentials.password);
    } else {
      Alert.alert('No credentials stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Credentials" onPress={storeCredentials} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} />
      {storedUsername && (
        <View>
          <Text>Stored Username: {storedUsername}</Text>
          <Text>Stored Password: {storedPassword}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Stores user credentials securely and retrieves them when needed.

#### Online Resources to Refer

1. [React Native Keychain](https://github.com/oblador/react-native-keychain)
2. [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)

---

### Example 2: Using Secure Storage for Authentication Tokens

#### Explanation

Authentication tokens are critical for maintaining user sessions and securing API requests. Storing these tokens securely ensures that they cannot be easily intercepted or stolen. React Native Keychain provides a secure way to store authentication tokens, protecting them with encryption and platform-specific secure storage mechanisms.

In this example, we will use React Native Keychain to store and retrieve an authentication token. This demonstrates how to manage authentication tokens securely in a React Native application, ensuring that user sessions are protected.

#### Code to Practice

1. Store and retrieve authentication tokens securely:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

function App() {
  const [token, setToken] = useState('');
  const [storedToken, setStoredToken] = useState('');

  const storeToken = async () => {
    await Keychain.setGenericPassword('authToken', token);
    Alert.alert('Token saved securely!');
  };

  const retrieveToken = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials && credentials.username === 'authToken') {
      setStoredToken(credentials.password);
    } else {
      Alert.alert('No token stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Authentication Token"
        value={token}
        onChangeText={setToken}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Token" onPress={storeToken} />
      <Button title="Retrieve Token" onPress={retrieveToken} />
      {storedToken && (
        <View>
          <Text>Stored Token: {storedToken}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Stores an authentication token securely and retrieves it when needed.

#### Online Resources to Refer

1. [Secure Storage for Authentication Tokens](https://auth0.com/docs/security/store-tokens)
2. [React Native Keychain](https://github.com/oblador/react-native-keychain)

---

### Example 3: Encrypting Data before Secure Storage

#### Explanation

While secure storage solutions like React Native Keychain provide encryption, adding an additional layer of encryption before storing sensitive data can enhance security. This involves encrypting data using a strong encryption algorithm before storing it securely. This approach ensures that even if the storage mechanism is compromised, the data remains protected.

In this example, we will use the `crypto-js` library to encrypt data before storing it securely with React Native Keychain. This demonstrates how to implement an additional layer of encryption to enhance the security of sensitive data in a React Native application.

#### Code to Practice

1. Install `crypto-js` for data encryption:

```sh
npm install crypto-js
```

2. Encrypt data before storing it securely:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = 'YOUR_ENCRYPTION_KEY';

function App() {
  const [data, setData] = useState('');
  const [storedData, setStoredData] = useState('');

  const encryptData = (data) => {
    return CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();
  };

  const decryptData = (encryptedData) => {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  };

  const storeData = async () => {
    const encryptedData = encryptData(data);
    await Keychain.setGenericPassword('secureData', encryptedData);
    Alert.alert('Data saved securely!');
  };

  const retrieveData = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials && credentials.username === 'secureData') {
      const decryptedData = decryptData(credentials.password);
      setStoredData(decryptedData);
    } else {
      Alert.alert('No data stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter sensitive data"
        value={data}
        onChangeText={setData}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} />
      {storedData && (
        <View>
          <Text>Stored Data: {storedData}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts data before storing it securely and decrypts it when retrieved.

#### Online Resources to Refer

1. [Using CryptoJS for Encryption](https://cryptojs.gitbook.io/docs/)
2. [React Native Keychain](https://github.com/oblador/react-native-keychain)

---

### Task 18: Implement Secure Storage with React Native Keychain for Cross-Platform Development using React Native

#### Explanation of the Topic

**Secure Storage with React Native Keychain**:
React Native Keychain is a library that provides an easy way to securely store sensitive information such as user credentials, tokens, and other confidential data. It leverages the underlying secure storage mechanisms provided by the operating system, such as the Keychain on iOS and the Keystore on Android. This ensures that the data is encrypted and protected from unauthorized access, even if the device is compromised.

Using React Native Keychain in your application helps to enhance security by storing sensitive data in a way that is difficult for malicious actors to access. It provides an abstraction layer over platform-specific secure storage APIs, making it easy to integrate into a React Native project. By following best practices for secure storage, you can protect user data and meet compliance requirements for security standards.

#### Online Resources to Refer

1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Secure Storage Best Practices](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)

---

### Examples to Practice

1. **Storing and Retrieving User Credentials**
2. **Using Secure Storage for Authentication Tokens**
3. **Encrypting Data before Secure Storage**

---

### Example 1: Storing and Retrieving User Credentials

#### Explanation

Storing and retrieving user credentials securely is essential for protecting user data and ensuring that the application remains secure. React Native Keychain allows you to store user credentials, such as usernames and passwords, in a secure and encrypted manner. This helps prevent unauthorized access and ensures that sensitive information is protected.

In this example, we will use React Native Keychain to store and retrieve user credentials. We will create a simple interface to input and store the credentials securely, and then retrieve and display them when needed.

#### Code to Practice

1. Install React Native Keychain:

```sh
npm install react-native-keychain
npx pod-install
```

2. Store and retrieve user credentials:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

function App() {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [storedUsername, setStoredUsername] = useState('');
  const [storedPassword, setStoredPassword] = useState('');

  const storeCredentials = async () => {
    await Keychain.setGenericPassword(username, password);
    Alert.alert('Credentials saved securely!');
  };

  const retrieveCredentials = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials) {
      setStoredUsername(credentials.username);
      setStoredPassword(credentials.password);
    } else {
      Alert.alert('No credentials stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Credentials" onPress={storeCredentials} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} />
      {storedUsername && (
        <View>
          <Text>Stored Username: {storedUsername}</Text>
          <Text>Stored Password: {storedPassword}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Stores user credentials securely and retrieves them when needed.

#### Online Resources to Refer

1. [React Native Keychain](https://github.com/oblador/react-native-keychain)
2. [Key Management Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/Key_Management_Cheat_Sheet.html)

---

### Example 2: Using Secure Storage for Authentication Tokens

#### Explanation

Authentication tokens are critical for maintaining user sessions and securing API requests. Storing these tokens securely ensures that they cannot be easily intercepted or stolen. React Native Keychain provides a secure way to store authentication tokens, protecting them with encryption and platform-specific secure storage mechanisms.

In this example, we will use React Native Keychain to store and retrieve an authentication token. This demonstrates how to manage authentication tokens securely in a React Native application, ensuring that user sessions are protected.

#### Code to Practice

1. Store and retrieve authentication tokens securely:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

function App() {
  const [token, setToken] = useState('');
  const [storedToken, setStoredToken] = useState('');

  const storeToken = async () => {
    await Keychain.setGenericPassword('authToken', token);
    Alert.alert('Token saved securely!');
  };

  const retrieveToken = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials && credentials.username === 'authToken') {
      setStoredToken(credentials.password);
    } else {
      Alert.alert('No token stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Authentication Token"
        value={token}
        onChangeText={setToken}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Token" onPress={storeToken} />
      <Button title="Retrieve Token" onPress={retrieveToken} />
      {storedToken && (
        <View>
          <Text>Stored Token: {storedToken}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Stores an authentication token securely and retrieves it when needed.

#### Online Resources to Refer

1. [Secure Storage for Authentication Tokens](https://auth0.com/docs/security/store-tokens)
2. [React Native Keychain](https://github.com/oblador/react-native-keychain)

---

### Example 3: Encrypting Data before Secure Storage

#### Explanation

While secure storage solutions like React Native Keychain provide encryption, adding an additional layer of encryption before storing sensitive data can enhance security. This involves encrypting data using a strong encryption algorithm before storing it securely. This approach ensures that even if the storage mechanism is compromised, the data remains protected.

In this example, we will use the `crypto-js` library to encrypt data before storing it securely with React Native Keychain. This demonstrates how to implement an additional layer of encryption to enhance the security of sensitive data in a React Native application.

#### Code to Practice

1. Install `crypto-js` for data encryption:

```sh
npm install crypto-js
```

2. Encrypt data before storing it securely:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = 'YOUR_ENCRYPTION_KEY';

function App() {
  const [data, setData] = useState('');
  const [storedData, setStoredData] = useState('');

  const encryptData = (data) => {
    return CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();
  };

  const decryptData = (encryptedData) => {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  };

  const storeData = async () => {
    const encryptedData = encryptData(data);
    await Keychain.setGenericPassword('secureData', encryptedData);
    Alert.alert('Data saved securely!');
  };

  const retrieveData = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials && credentials.username === 'secureData') {
      const decryptedData = decryptData(credentials.password);
      setStoredData(decryptedData);
    } else {
      Alert.alert('No data stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter sensitive data"
        value={data}
        onChangeText={setData}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} />
      {storedData && (
        <View>
          <Text>Stored Data: {storedData}</Text>
        </View>
      )}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts data before storing it securely and decrypts it when retrieved.

#### Online Resources to Refer

1. [Using CryptoJS for Encryption](https://cryptojs.gitbook.io/docs/)
2. [React Native Keychain](https://github.com/oblador/react-native-keychain)

---

### Task 19: Study Data Encryption Techniques for Cross-Platform Development using React Native

#### Explanation of the Topic

**Data Encryption Techniques**:
Data encryption is a critical component of securing sensitive information in mobile applications. It involves transforming readable data into an encoded format that can only be decoded with a specific key. This ensures that even if data is intercepted or accessed by unauthorized parties, it cannot be read without the decryption key. In the context of React Native applications, implementing data encryption helps protect user data such as personal information, credentials, and other sensitive details from being compromised.

There are several encryption algorithms available, including symmetric encryption (e.g., AES) and asymmetric encryption (e.g., RSA). Symmetric encryption uses the same key for both encryption and decryption, making it fast and efficient for large amounts of data. Asymmetric encryption uses a pair of keys (public and private) and is typically used for securing small amounts of data or for key exchange. Understanding and implementing these encryption techniques in your React Native applications can significantly enhance security.

#### Online Resources to Refer

1. [Understanding Encryption in React Native](https://www.reactnative.guide/10-security-and-testing/10.1-encryption.html)
2. [CryptoJS Documentation](https://cryptojs.gitbook.io/docs/)

---

### Examples to Practice

1. **Using CryptoJS for Symmetric Encryption (AES)**
2. **Implementing Asymmetric Encryption (RSA)**
3. **Encrypting and Decrypting Sensitive Data**

---

### Example 1: Using CryptoJS for Symmetric Encryption (AES)

#### Explanation

AES (Advanced Encryption Standard) is a widely used symmetric encryption algorithm that is efficient and secure for encrypting large amounts of data. Using AES in a React Native application involves encrypting data with a secret key and then decrypting it using the same key. This ensures that the data remains confidential and protected from unauthorized access.

In this example, we will use the `crypto-js` library to perform AES encryption and decryption in a React Native application. This demonstrates how to securely encrypt and decrypt data using a symmetric encryption algorithm.

#### Code to Practice

1. Install `crypto-js` for AES encryption:

```sh
npm install crypto-js
```

2. Implement AES encryption and decryption:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import CryptoJS from 'crypto-js';

const ENCRYPTION_KEY = 'YOUR_ENCRYPTION_KEY';

function App() {
  const [data, setData] = useState('');
  const [encryptedData, setEncryptedData] = useState('');
  const [decryptedData, setDecryptedData] = useState('');

  const encryptData = (data) => {
    return CryptoJS.AES.encrypt(data, ENCRYPTION_KEY).toString();
  };

  const decryptData = (encryptedData) => {
    const bytes = CryptoJS.AES.decrypt(encryptedData, ENCRYPTION_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  };

  const handleEncrypt = () => {
    const encrypted = encryptData(data);
    setEncryptedData(encrypted);
    Alert.alert('Data encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decrypted = decryptData(encryptedData);
    setDecryptedData(decrypted);
    Alert.alert('Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter data to encrypt"
        value={data}
        onChangeText={setData}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Data" onPress={handleEncrypt} />
      {encryptedData && <Text>Encrypted Data: {encryptedData}</Text>}
      <Button title="Decrypt Data" onPress={handleDecrypt} />
      {decryptedData && <Text>Decrypted Data: {decryptedData}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts data using AES and displays the encrypted data.
- Decrypts the encrypted data and displays the original data.

#### Online Resources to Refer

1. [AES Encryption](https://www.geeksforgeeks.org/advanced-encryption-standard-aes/)
2. [CryptoJS Documentation](https://cryptojs.gitbook.io/docs/)

---

### Example 2: Implementing Asymmetric Encryption (RSA)

#### Explanation

RSA (Rivest-Shamir-Adleman) is a widely used asymmetric encryption algorithm that uses a pair of keys (public and private) for encryption and decryption. It is commonly used for securing sensitive data and for key exchange. In a React Native application, implementing RSA encryption ensures that data can be securely transmitted between clients and servers.

In this example, we will use the `node-rsa` library to perform RSA encryption and decryption in a React Native application. This demonstrates how to securely encrypt and decrypt data using an asymmetric encryption algorithm.

#### Code to Practice

1. Install `node-rsa` for RSA encryption:

```sh
npm install node-rsa
```

2. Implement RSA encryption and decryption:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import NodeRSA from 'node-rsa';

const key = new NodeRSA({ b: 512 });

function App() {
  const [data, setData] = useState('');
  const [encryptedData, setEncryptedData] = useState('');
  const [decryptedData, setDecryptedData] = useState('');

  const handleEncrypt = () => {
    const encrypted = key.encrypt(data, 'base64');
    setEncryptedData(encrypted);
    Alert.alert('Data encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decrypted = key.decrypt(encryptedData, 'utf8');
    setDecryptedData(decrypted);
    Alert.alert('Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter data to encrypt"
        value={data}
        onChangeText={setData}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Data" onPress={handleEncrypt} />
      {encryptedData && <Text>Encrypted Data: {encryptedData}</Text>}
      <Button title="Decrypt Data" onPress={handleDecrypt} />
      {decryptedData && <Text>Decrypted Data: {decryptedData}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts data using RSA and displays the encrypted data.
- Decrypts the encrypted data and displays the original data.

#### Online Resources to Refer

1. [RSA Encryption](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
2. [NodeRSA Documentation](https://www.npmjs.com/package/node-rsa)

---

### Example 3: Encrypting and Decrypting Sensitive Data

#### Explanation

Encrypting sensitive data before storing or transmitting it is crucial for ensuring data security. By encrypting data, you protect it from unauthorized access, even if the data is intercepted or compromised. This example combines both symmetric (AES) and asymmetric (RSA) encryption techniques to demonstrate how to securely encrypt and decrypt sensitive data in a React Native application.

In this example, we will use both `crypto-js` for AES encryption and `node-rsa` for RSA encryption. This demonstrates how to encrypt sensitive data with AES and then use RSA to securely share the AES encryption key.

#### Code to Practice

1. Combine AES and RSA for secure data encryption:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import CryptoJS from 'crypto-js';
import NodeRSA from 'node-rsa';

const rsaKey = new NodeRSA({ b: 512 });
const AES_KEY = 'AES_SECRET_KEY';

function App() {
  const [data, setData] = useState('');
  const [encryptedData, setEncryptedData] = useState('');
  const [decryptedData, setDecryptedData] = useState('');
  const [encryptedAESKey, setEncryptedAESKey] = useState('');

  const encryptData = (data) => {
    return CryptoJS.AES.encrypt(data, AES_KEY).toString();
  };

  const decryptData = (encryptedData) => {
    const bytes = CryptoJS.AES.decrypt(encryptedData, AES_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  };

  const handleEncrypt = () => {
    const encrypted = encryptData(data);
    const encryptedKey = rsaKey.encrypt(AES_KEY, 'base64');
    setEncryptedData(encrypted);
    setEncryptedAESKey(encryptedKey);
    Alert.alert('Data and AES key encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decryptedKey = rsaKey.decrypt(encryptedAESKey, 'utf8');
    const decrypted = decryptData(encryptedData);
    setDecryptedData(decrypted);
    Alert.alert('Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter data to encrypt"
        value={data}
        onChangeText={setData}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Data" onPress={handleEncrypt} />
      {encryptedData && <Text>Encrypted Data: {encryptedData}</Text>}


      {encryptedAESKey && <Text>Encrypted AES Key: {encryptedAESKey}</Text>}
      <Button title="Decrypt Data" onPress={handleDecrypt} />
      {decryptedData && <Text>Decrypted Data: {decryptedData}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts data using AES and encrypts the AES key using RSA.
- Decrypts the AES key using RSA and then decrypts the data using AES.

#### Online Resources to Refer

1. [Hybrid Encryption](https://crypto.stackexchange.com/questions/16705/why-not-use-rsa-encryption-instead-of-aes)
2. [AES Encryption with CryptoJS](https://cryptojs.gitbook.io/docs/)

---

### Task 20: Implement End-to-End Encryption with Crypto Libraries for Cross-Platform Development using React Native

#### Explanation of the Topic

**End-to-End Encryption (E2EE)**:
End-to-end encryption (E2EE) is a method of securing data communication in such a way that only the communicating users can read the messages. In E2EE, data is encrypted on the sender’s device and only decrypted on the recipient’s device. This ensures that no intermediaries, including service providers, can access the transmitted data. Implementing E2EE is crucial for maintaining privacy and security in applications that handle sensitive information, such as messaging apps or financial services.

Using crypto libraries in React Native, developers can implement E2EE to secure data transmission between clients. These libraries provide robust encryption algorithms and tools to ensure that data is encrypted before it leaves the sender's device and remains protected until it reaches the recipient. By mastering E2EE, developers can enhance the security and trustworthiness of their cross-platform applications.

#### Online Resources to Refer

1. [Understanding End-to-End Encryption](https://en.wikipedia.org/wiki/End-to-end_encryption)
2. [NodeRSA Documentation](https://www.npmjs.com/package/node-rsa)

---

### Examples to Practice

1. **Implementing E2EE with RSA**
2. **Combining RSA and AES for Hybrid Encryption**
3. **Securing Message Exchange with E2EE**

---

### Example 1: Implementing E2EE with RSA

#### Explanation

RSA (Rivest-Shamir-Adleman) is an asymmetric encryption algorithm that uses a pair of keys: a public key for encryption and a private key for decryption. Implementing E2EE with RSA involves encrypting data with the recipient's public key and decrypting it with the recipient's private key. This ensures that only the intended recipient can decrypt and read the data.

In this example, we will use the `node-rsa` library to perform RSA encryption and decryption in a React Native application. This demonstrates how to securely transmit data between two devices using RSA for end-to-end encryption.

#### Code to Practice

1. Install `node-rsa` for RSA encryption:

```sh
npm install node-rsa
```

2. Implement RSA-based E2EE:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import NodeRSA from 'node-rsa';

const senderKey = new NodeRSA({ b: 512 });
const recipientKey = new NodeRSA({ b: 512 });

function App() {
  const [message, setMessage] = useState('');
  const [encryptedMessage, setEncryptedMessage] = useState('');
  const [decryptedMessage, setDecryptedMessage] = useState('');

  const handleEncrypt = () => {
    const encrypted = recipientKey.encrypt(message, 'base64');
    setEncryptedMessage(encrypted);
    Alert.alert('Message encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decrypted = recipientKey.decrypt(encryptedMessage, 'utf8');
    setDecryptedMessage(decrypted);
    Alert.alert('Message decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter message to encrypt"
        value={message}
        onChangeText={setMessage}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Message" onPress={handleEncrypt} />
      {encryptedMessage && <Text>Encrypted Message: {encryptedMessage}</Text>}
      <Button title="Decrypt Message" onPress={handleDecrypt} />
      {decryptedMessage && <Text>Decrypted Message: {decryptedMessage}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts a message using the recipient's public key and decrypts it using the recipient's private key, demonstrating RSA-based E2EE.

#### Online Resources to Refer

1. [RSA Encryption](https://en.wikipedia.org/wiki/RSA_(cryptosystem))
2. [NodeRSA Documentation](https://www.npmjs.com/package/node-rsa)

---

### Example 2: Combining RSA and AES for Hybrid Encryption

#### Explanation

Hybrid encryption combines the strengths of both symmetric and asymmetric encryption. RSA is used to encrypt a symmetric AES key, which is then used to encrypt the actual data. This approach leverages the efficiency of AES for large data encryption and the security of RSA for key exchange. Hybrid encryption ensures that data is encrypted securely and can only be decrypted by the intended recipient.

In this example, we will use both `node-rsa` for RSA encryption and `crypto-js` for AES encryption. This demonstrates how to encrypt data with AES and securely share the AES key using RSA, implementing a robust hybrid encryption system for end-to-end security.

#### Code to Practice

1. Install `crypto-js` and `node-rsa` for hybrid encryption:

```sh
npm install crypto-js node-rsa
```

2. Implement hybrid encryption with RSA and AES:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import CryptoJS from 'crypto-js';
import NodeRSA from 'node-rsa';

const rsaKey = new NodeRSA({ b: 512 });
const AES_KEY = CryptoJS.lib.WordArray.random(16).toString();

function App() {
  const [message, setMessage] = useState('');
  const [encryptedMessage, setEncryptedMessage] = useState('');
  const [decryptedMessage, setDecryptedMessage] = useState('');
  const [encryptedAESKey, setEncryptedAESKey] = useState('');

  const encryptData = (data) => {
    return CryptoJS.AES.encrypt(data, AES_KEY).toString();
  };

  const decryptData = (encryptedData) => {
    const bytes = CryptoJS.AES.decrypt(encryptedData, AES_KEY);
    return bytes.toString(CryptoJS.enc.Utf8);
  };

  const handleEncrypt = () => {
    const encrypted = encryptData(message);
    const encryptedKey = rsaKey.encrypt(AES_KEY, 'base64');
    setEncryptedMessage(encrypted);
    setEncryptedAESKey(encryptedKey);
    Alert.alert('Data and AES key encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decryptedKey = rsaKey.decrypt(encryptedAESKey, 'utf8');
    const decrypted = decryptData(encryptedMessage);
    setDecryptedMessage(decrypted);
    Alert.alert('Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter message to encrypt"
        value={message}
        onChangeText={setMessage}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Message" onPress={handleEncrypt} />
      {encryptedMessage && <Text>Encrypted Message: {encryptedMessage}</Text>}
      {encryptedAESKey && <Text>Encrypted AES Key: {encryptedAESKey}</Text>}
      <Button title="Decrypt Message" onPress={handleDecrypt} />
      {decryptedMessage && <Text>Decrypted Message: {decryptedMessage}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Encrypts a message using AES and secures the AES key with RSA, demonstrating hybrid encryption for end-to-end security.

#### Online Resources to Refer

1. [Hybrid Encryption](https://en.wikipedia.org/wiki/Hybrid_cryptosystem)
2. [CryptoJS Documentation](https://cryptojs.gitbook.io/docs/)

---

### Example 3: Securing Message Exchange with E2EE

#### Explanation

Securing message exchange with E2EE ensures that only the intended recipients can read the messages. This involves encrypting the message on the sender's device and decrypting it only on the recipient's device. Implementing E2EE for message exchange enhances privacy and security, making it suitable for secure communication applications.

In this example, we will create a simple message exchange system using E2EE with RSA. This demonstrates how to securely send and receive messages between two parties, ensuring that the messages remain private and protected from unauthorized access.

#### Code to Practice

1. Implement E2EE for secure message exchange:

```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import NodeRSA from 'node-rsa';

const senderKey = new NodeRSA({ b: 512 });
const recipientKey = new NodeRSA({ b: 512 });

function App() {
  const [message, setMessage] = useState('');
  const [encryptedMessage, setEncryptedMessage] = useState('');
  const [decryptedMessage, setDecryptedMessage] = useState('');

  const handleEncrypt = () => {
    const encrypted = recipientKey.encrypt(message, 'base64');
    setEncryptedMessage(encrypted);
    Alert.alert('Message encrypted successfully!');
  };

  const handleDecrypt = () => {
    const decrypted = recipientKey.decrypt(encryptedMessage, 'utf8');
    setDecryptedMessage(decrypted);
    Alert.alert('Message decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        placeholder="Enter message to encrypt"
        value={message}
        onChangeText={setMessage}
        style={{ borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
      />
      <Button title="Encrypt Message" onPress={handleEncrypt} />
      {encryptedMessage

 && <Text>Encrypted Message: {encryptedMessage}</Text>}
      <Button title="Decrypt Message" onPress={handleDecrypt} />
      {decryptedMessage && <Text>Decrypted Message: {decryptedMessage}</Text>}
    </View>
  );
}

export default App;
```

#### Expected Output

- Securely encrypts a message with the recipient's public key and decrypts it with the recipient's private key, demonstrating end-to-end encrypted message exchange.

#### Online Resources to Refer

1. [End-to-End Encryption](https://en.wikipedia.org/wiki/End-to-end_encryption)
2. [NodeRSA Documentation](https://www.npmjs.com/package/node-rsa)

---

