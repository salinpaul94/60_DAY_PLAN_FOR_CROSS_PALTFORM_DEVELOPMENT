for day 9, tasks listed between
"""
Study state management libraries (Redux).
Set up Redux in a React Native project.
Understand Redux architecture.
Create actions and reducers.
Use `useDispatch` and `useSelector` hooks.
Integrate Redux with React Navigation.
Learn about Redux middleware.
Use Redux Thunk for async actions.
Study Redux Toolkit.
Implement state management with Redux Toolkit.
Learn about Context API in React Native.
Implement global state with Context API.
Study local storage solutions.
Use AsyncStorage for data persistence.
Learn about secure storage.
Use SecureStore for sensitive data.
Study push notifications.
Implement push notifications with Firebase.
Learn about deep linking.
Implement deep linking in the app.
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

---
### Task 1: Study state management libraries (Redux)

**Explanation:**
Redux is a popular state management library for JavaScript applications, including React Native. It provides a centralized store for managing the application's state and allows for predictable state updates through actions and reducers. Redux follows a unidirectional data flow, where the state is updated in a controlled manner, making the application easier to debug and maintain.

Redux is particularly useful for large applications with complex state interactions. By separating the state management logic from the UI components, Redux helps keep the application organized and scalable. It also enables advanced features like time-travel debugging and state persistence.

**Resources:**
- [Redux Official Documentation](https://redux.js.org/)
- [Redux in React Native](https://reactnative.dev/docs/redux)

**Example 1:**
```javascript
import { createStore } from 'redux';

// Initial state
const initialState = {
  count: 0
};

// Reducer
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Create store
const store = createStore(counterReducer);

// Dispatch actions
store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'DECREMENT' });

console.log(store.getState());
```

**Example Explanation:**
This example demonstrates a simple Redux setup with a counter reducer. The `counterReducer` handles `INCREMENT` and `DECREMENT` actions to update the state. The store is created using `createStore`, and actions are dispatched to update the state. The final state is logged to the console.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { Provider, useDispatch, useSelector } from 'react-redux';
import { createStore } from 'redux';

// Initial state
const initialState = {
  count: 0
};

// Reducer
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Create store
const store = createStore(counterReducer);

function Counter() {
  const dispatch = useDispatch();
  const count = useSelector(state => state.count);

  return (
    <View style={styles.container}>
      <Text style={styles.count}>{count}</Text>
      <Button title="Increment" onPress={() => dispatch({ type: 'INCREMENT' })} />
      <Button title="Decrement" onPress={() => dispatch({ type: 'DECREMENT' })} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  count: {
    fontSize: 32,
    marginBottom: 20,
  },
});

export default function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

**Example Explanation:**
This example demonstrates integrating Redux with a React Native component. The `Counter` component uses `useDispatch` to dispatch actions and `useSelector` to select the state from the store. The `Provider` component wraps the app to provide the Redux store to all components.

**Resources:**
- [W3Schools: Redux in React Native](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Introduction to Redux in React Native](https://www.freecodecamp.org/news/learn-redux-react-native/)

**Expected Output:**
For Example 1:
```
Logs the state after dispatching INCREMENT and DECREMENT actions.
```
For Example 2:
```
Displays a counter with buttons to increment and decrement the count using Redux.
```

---

### Task 2: Set up Redux in a React Native project

**Explanation:**
Setting up Redux in a React Native project involves installing the necessary packages, creating a Redux store, defining actions and reducers, and integrating the store with the React Native application using the `Provider` component. This setup allows you to manage the state of your application in a centralized and predictable manner.

Redux helps in managing state more efficiently, especially in large applications with complex state interactions. By setting up Redux, you ensure that the state changes are predictable and can be easily debugged. It also makes it easier to manage the state across different components of your application.

**Resources:**
- [Redux Official Documentation: Getting Started](https://redux.js.org/introduction/getting-started)
- [React Native Documentation: Using Redux](https://reactnative.dev/docs/redux)

**Example 1:**
```bash
# Install Redux and React-Redux
npm install redux react-redux
```

```javascript
// store.js
import { createStore } from 'redux';

// Initial state
const initialState = {
  count: 0
};

// Reducer
function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}

// Create store
const store = createStore(counterReducer);

export default store;
```

**Example Explanation:**
This example demonstrates installing Redux and creating a Redux store. The `counterReducer` handles `INCREMENT` and `DECREMENT` actions, and the store is created using `createStore`. The store is then exported for use in the application.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';

function Counter() {
  const dispatch = useDispatch();
  const count = useSelector(state => state.count);

  return (
    <View style={styles.container}>
      <Text style={styles.count}>{count}</Text>
      <Button title="Increment" onPress={() => dispatch({ type: 'INCREMENT' })} />
      <Button title="Decrement" onPress={() => dispatch({ type: 'DECREMENT' })} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  count: {
    fontSize: 32,
    marginBottom: 20,
  },
});

export default function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

**Example Explanation:**
This example demonstrates integrating the Redux store with a React Native component. The `Counter` component uses `useDispatch` to dispatch actions and `useSelector` to select the state from the store. The `Provider` component wraps the app to provide the Redux store to all components.

**Resources:**
- [W3Schools: Setting Up Redux in React Native](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Setting Up Redux in React Native](https://www.freecodecamp.org/news/learn-redux-react-native/)

**Expected Output:**
For Example 1:
```
A Redux store is created and exported.
```
For Example 2:
```
A counter with buttons to increment and decrement the count using Redux.
```

---

### Task 3: Understand Redux architecture

**Explanation:**
Redux architecture is based on the principles of a unidirectional data flow, which ensures that the state changes in a predictable and controlled manner. The key components of Redux architecture are the store, actions, reducers, and middleware. The store holds the application state, actions describe changes to the state, reducers handle the state changes based on actions, and middleware allows for side effects like logging or asynchronous operations.

Understanding Redux architecture is crucial for effectively managing state in your application. It helps in structuring your application in a way that makes state changes predictable, easier to debug, and scalable. The separation of concerns provided by Redux architecture makes the code more maintainable.

**Resources:**
- [Redux Official Documentation: Core Concepts](https://redux.js.org/introduction/core-concepts)
- [Redux Official Documentation: Three Principles](https://redux.js.org/introduction/three-principles)

**Example 1:**
```javascript
// actions.js
export const increment = () => ({ type: 'INCREMENT' });
export const decrement = () => ({ type: 'DECREMENT' });
```

```javascript
// reducers.js
const initialState = { count: 0 };

export function counterReducer(state = initialState, action) {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
}
```

**Example Explanation:**
This example demonstrates defining actions and reducers in Redux. The `increment` and `decrement` actions describe changes to the state, and the `counterReducer` handles these actions to update the state accordingly.

**Example 2:**
```javascript
import { createStore, applyMiddleware } from 'redux';
import { counterReducer } from './reducers';
import { createLogger } from 'redux-logger';

const logger = createLogger

();
const store = createStore(counterReducer, applyMiddleware(logger));

store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'DECREMENT' });

console.log(store.getState());
```

**Example Explanation:**
This example demonstrates creating a Redux store with middleware. The `createLogger` middleware logs actions and state changes to the console. The `store` is created using `createStore` with the `counterReducer` and `logger` middleware. Actions are dispatched to update the state, and the final state is logged to the console.

**Resources:**
- [W3Schools: Understanding Redux Architecture](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Redux Architecture Explained](https://www.freecodecamp.org/news/learn-redux-architecture/)

**Expected Output:**
For Example 1:
```
Defines increment and decrement actions and a counter reducer.
```
For Example 2:
```
Logs state changes to the console using the Redux logger middleware.
```

---

### Task 4: Create actions and reducers

**Explanation:**
Actions and reducers are fundamental concepts in Redux. Actions are plain JavaScript objects that describe changes to the state. They must have a `type` property and can optionally include a `payload` that carries additional information. Reducers are functions that take the current state and an action as arguments, and return a new state based on the action type.

Creating actions and reducers is essential for managing state changes in a Redux application. Actions provide a way to describe state changes in a standardized format, while reducers define how the state should be updated in response to these actions. This separation of concerns makes the state management logic more organized and maintainable.

**Resources:**
- [Redux Official Documentation: Actions](https://redux.js.org/basics/actions)
- [Redux Official Documentation: Reducers](https://redux.js.org/basics/reducers)

**Example 1:**
```javascript
// actions.js
export const addTodo = (text) => ({
  type: 'ADD_TODO',
  payload: text,
});

export const toggleTodo = (id) => ({
  type: 'TOGGLE_TODO',
  payload: id,
});
```

**Example Explanation:**
This example demonstrates defining actions for a todo application. The `addTodo` action includes a `text` payload to add a new todo, while the `toggleTodo` action includes an `id` payload to toggle the completion status of a todo.

**Example 2:**
```javascript
// reducers.js
const initialState = {
  todos: [],
};

export function todosReducer(state = initialState, action) {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, { id: state.todos.length, text: action.payload, completed: false }],
      };
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload ? { ...todo, completed: !todo.completed } : todo
        ),
      };
    default:
      return state;
  }
}
```

**Example Explanation:**
This example demonstrates defining a reducer for a todo application. The `todosReducer` handles `ADD_TODO` and `TOGGLE_TODO` actions to update the state. For `ADD_TODO`, a new todo is added to the state, and for `TOGGLE_TODO`, the completion status of the specified todo is toggled.

**Resources:**
- [W3Schools: Redux Actions and Reducers](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Creating Actions and Reducers in Redux](https://www.freecodecamp.org/news/redux-actions-and-reducers/)

**Expected Output:**
For Example 1:
```
Defines actions to add and toggle todos in a Redux application.
```
For Example 2:
```
Defines a reducer to handle adding and toggling todos in the state.
```

---

### Task 5: Use `useDispatch` and `useSelector` hooks

**Explanation:**
The `useDispatch` and `useSelector` hooks are provided by `react-redux` to interact with the Redux store in functional components. `useDispatch` returns the `dispatch` function, allowing you to dispatch actions to the store. `useSelector` selects a portion of the state from the Redux store, allowing you to access and use it in your component.

Using `useDispatch` and `useSelector` hooks is essential for integrating Redux with React functional components. These hooks provide a simple and convenient way to interact with the Redux store, making it easy to dispatch actions and select state without the need for higher-order components or context.

**Resources:**
- [React-Redux Documentation: Hooks](https://react-redux.js.org/api/hooks)
- [JavaScript.info: React-Redux Hooks](https://javascript.info/react-redux/hooks)

**Example 1:**
```javascript
import React from 'react';
import { useDispatch } from 'react-redux';
import { addTodo } from './actions';

function AddTodo() {
  const dispatch = useDispatch();

  const handleAddTodo = () => {
    dispatch(addTodo('New Todo'));
  };

  return (
    <button onClick={handleAddTodo}>Add Todo</button>
  );
}

export default AddTodo;
```

**Example Explanation:**
This example demonstrates using the `useDispatch` hook to dispatch an action. The `AddTodo` component defines a `handleAddTodo` function that dispatches the `addTodo` action when the button is clicked.

**Example 2:**
```javascript
import React from 'react';
import { useSelector } from 'react-redux';

function TodoList() {
  const todos = useSelector(state => state.todos);

  return (
    <ul>
      {todos.map(todo => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
}

export default TodoList;
```

**Example Explanation:**
This example demonstrates using the `useSelector` hook to select a portion of the state. The `TodoList` component uses `useSelector` to access the `todos` state from the Redux store and renders a list of todos.

**Resources:**
- [W3Schools: Using React-Redux Hooks](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Using useDispatch and useSelector Hooks in Redux](https://www.freecodecamp.org/news/learn-react-redux-hooks/)

**Expected Output:**
For Example 1:
```
Displays a button that dispatches an action to add a todo when clicked.
```
For Example 2:
```
Displays a list of todos from the Redux store using the useSelector hook.
```

---

### Task 6: Integrate Redux with React Navigation

**Explanation:**
Integrating Redux with React Navigation allows you to manage navigation state alongside your application's state. This integration ensures that the navigation state is kept in sync with the Redux store, providing a single source of truth for both navigation and application state. This approach is useful for scenarios where navigation actions need to affect the application state or vice versa.

Integrating Redux with React Navigation is essential for building complex applications where the navigation state interacts with other parts of the application. It provides a consistent way to manage state across different aspects of the application, making it easier to handle state changes and navigation actions.

**Resources:**
- [React Navigation Documentation: Redux Integration](https://reactnavigation.org/docs/redux-integration)
- [Redux Official Documentation: Using Redux with React Navigation](https://redux.js.org/recipes/usage-with-react-navigation)

**Example 1:**
```javascript
import { createStore, combineReducers } from 'redux';
import { Provider } from 'react-redux';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createReduxContainer, createNavigationReducer } from 'react-navigation-redux-helpers';

const Stack = createStackNavigator();
const navReducer = createNavigationReducer(Stack);

const rootReducer = combineReducers({
  nav: navReducer,
  // other reducers
});

const store = createStore(rootReducer);

const AppNavigator = createReduxContainer(Stack);

function App() {
  return (
    <Provider store={store}>
      <NavigationContainer>
        <AppNavigator />
      </NavigationContainer>
    </Provider>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates integrating Redux with React Navigation. The `navReducer` is created using `createNavigationReducer`, and the root reducer combines the navigation reducer with other reducers. The `AppNavigator` is created using `createReduxContainer` and rendered within the `NavigationContainer` and `Provider`.

**Example 2:**
```javascript
import { useDispatch } from 'react-redux';
import { NavigationActions } from 'react-navigation';

function navigateToScreen(screen) {
  return NavigationActions.navigate({ routeName: screen });
}

function MyComponent() {
  const dispatch = useDispatch();

  const handleNavigation = () => {
    dispatch(navigateToScreen('Home'));
  };

  return (
    <button onClick={handleNavigation}>Go to Home</button>
  );
}

export default MyComponent;
```

**Example Explanation:**
This example demonstrates dispatching navigation actions from a component. The `navigateToScreen` function creates a navigation action, and the `handleNavigation` function dispatches this action using the `useDispatch` hook when the button is clicked.

**Resources:**
- [W3Schools: Integrating Redux with React Navigation](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Using Redux with React Navigation](https://www.freecodecamp.org/news/react-navigation-redux-integration/)

**Expected Output:

**
For Example 1:
```
Integrates Redux with React Navigation, creating a navigation container and combining navigation state with application state.
```
For Example 2:
```
Dispatches navigation actions from a component using the useDispatch hook.
```

---

### Task 7: Learn about Redux middleware

**Explanation:**
Redux middleware is a way to extend the functionality of Redux by intercepting actions before they reach the reducers. Middleware can be used for various purposes, such as logging, performing asynchronous operations, handling side effects, and more. Commonly used middleware includes `redux-thunk` for handling asynchronous actions and `redux-logger` for logging actions and state changes.

Learning about Redux middleware is essential for handling complex state management scenarios. Middleware allows you to add additional logic to the action dispatching process, making it easier to manage side effects and perform asynchronous operations in a predictable manner.

**Resources:**
- [Redux Official Documentation: Middleware](https://redux.js.org/advanced/middleware)
- [JavaScript.info: Redux Middleware](https://javascript.info/redux/middleware)

**Example 1:**
```javascript
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';
import { counterReducer } from './reducers';

const store = createStore(counterReducer, applyMiddleware(thunk));

store.dispatch((dispatch) => {
  setTimeout(() => {
    dispatch({ type: 'INCREMENT' });
  }, 1000);
});
```

**Example Explanation:**
This example demonstrates using `redux-thunk` middleware to handle an asynchronous action. The store is created with `applyMiddleware(thunk)`, and an asynchronous action is dispatched to increment the counter after a delay.

**Example 2:**
```javascript
import { createStore, applyMiddleware } from 'redux';
import { createLogger } from 'redux-logger';
import { counterReducer } from './reducers';

const logger = createLogger();
const store = createStore(counterReducer, applyMiddleware(logger));

store.dispatch({ type: 'INCREMENT' });
store.dispatch({ type: 'DECREMENT' });

console.log(store.getState());
```

**Example Explanation:**
This example demonstrates using `redux-logger` middleware to log actions and state changes. The store is created with `applyMiddleware(logger)`, and actions are dispatched to increment and decrement the counter. The state changes are logged to the console.

**Resources:**
- [W3Schools: Redux Middleware](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Understanding Redux Middleware](https://www.freecodecamp.org/news/redux-middleware/)

**Expected Output:**
For Example 1:
```
Uses redux-thunk to handle an asynchronous action that increments the counter after a delay.
```
For Example 2:
```
Uses redux-logger to log actions and state changes to the console.
```

---

### Task 8: Use Redux Thunk for async actions

**Explanation:**
Redux Thunk is a middleware that allows you to write action creators that return a function instead of an action. This function can perform asynchronous operations, such as fetching data from an API, and then dispatch actions to update the state based on the results. Redux Thunk is commonly used for handling complex asynchronous logic in Redux applications.

Using Redux Thunk for async actions is essential for managing asynchronous operations in a predictable manner. It allows you to handle side effects, such as data fetching, within the Redux flow, ensuring that the state updates are coordinated and traceable.

**Resources:**
- [Redux Thunk Documentation](https://github.com/reduxjs/redux-thunk)
- [Redux Official Documentation: Asynchronous Actions](https://redux.js.org/advanced/async-actions)

**Example 1:**
```javascript
// actions.js
export const fetchData = () => {
  return async (dispatch) => {
    dispatch({ type: 'FETCH_DATA_REQUEST' });
    try {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
      const data = await response.json();
      dispatch({ type: 'FETCH_DATA_SUCCESS', payload: data });
    } catch (error) {
      dispatch({ type: 'FETCH_DATA_FAILURE', error });
    }
  };
};
```

**Example Explanation:**
This example demonstrates an action creator using Redux Thunk to fetch data from an API. The `fetchData` function dispatches a request action, performs the asynchronous operation, and then dispatches either a success or failure action based on the result.

**Example 2:**
```javascript
// reducers.js
const initialState = {
  data: null,
  loading: false,
  error: null,
};

export function dataReducer(state = initialState, action) {
  switch (action.type) {
    case 'FETCH_DATA_REQUEST':
      return { ...state, loading: true, error: null };
    case 'FETCH_DATA_SUCCESS':
      return { ...state, loading: false, data: action.payload };
    case 'FETCH_DATA_FAILURE':
      return { ...state, loading: false, error: action.error };
    default:
      return state;
  }
}
```

**Example Explanation:**
This example demonstrates a reducer handling the actions dispatched by the `fetchData` action creator. The `dataReducer` updates the state based on the `FETCH_DATA_REQUEST`, `FETCH_DATA_SUCCESS`, and `FETCH_DATA_FAILURE` actions.

**Resources:**
- [W3Schools: Using Redux Thunk](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Handling Asynchronous Actions with Redux Thunk](https://www.freecodecamp.org/news/redux-thunk-async-actions/)

**Expected Output:**
For Example 1:
```
Defines an action creator using Redux Thunk to fetch data from an API.
```
For Example 2:
```
Defines a reducer to handle the actions dispatched by the async action creator.
```

---

### Task 9: Study Redux Toolkit

**Explanation:**
Redux Toolkit is a set of tools and best practices for efficient Redux development. It simplifies the setup and use of Redux by providing a standardized way to write Redux logic. Redux Toolkit includes utilities for creating slices of state, configuring the store, and managing middleware. It also includes a createAsyncThunk function for handling asynchronous actions.

Studying Redux Toolkit is essential for modern Redux development. It reduces boilerplate code, enforces best practices, and provides a more streamlined API for managing state. By using Redux Toolkit, developers can write more concise and maintainable Redux code.

**Resources:**
- [Redux Toolkit Documentation](https://redux-toolkit.js.org/)
- [Redux Official Documentation: Redux Toolkit](https://redux.js.org/introduction/why-rtk-is-redux-today)

**Example 1:**
```javascript
import { configureStore, createSlice } from '@reduxjs/toolkit';

// Create a slice of state
const counterSlice = createSlice({
  name: 'counter',
  initialState: { count: 0 },
  reducers: {
    increment: (state) => { state.count += 1; },
    decrement: (state) => { state.count -= 1; },
  },
});

// Export actions and reducer
export const { increment, decrement } = counterSlice.actions;
export const counterReducer = counterSlice.reducer;

// Configure store
const store = configureStore({ reducer: counterReducer });

export default store;
```

**Example Explanation:**
This example demonstrates creating a slice of state using Redux Toolkit. The `createSlice` function defines the state, reducers, and actions. The `configureStore` function creates a Redux store with the slice's reducer.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store, { increment, decrement } from './store';

function Counter() {
  const dispatch = useDispatch();
  const count = useSelector(state => state.count);

  return (
    <View style={styles.container}>
      <Text style={styles.count}>{count}</Text>
      <Button title="Increment" onPress={() => dispatch(increment())} />
      <Button title="Decrement" onPress={() => dispatch(decrement())} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  count: {
    fontSize: 32,
    marginBottom: 20,
  },
});

export default function App() {
  return (
    <Provider store={store}>
      <Counter />
    </Provider>
  );
}
```

**Example Explanation:**
This example demonstrates integrating a Redux Toolkit slice with a React Native component. The `Counter` component uses `useDispatch` to dispatch actions and `useSelector` to select the state from the store. The `Provider` component wraps the app to provide the Redux store to all components.

**Resources:**
- [W3Schools: Using Redux Toolkit](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: Introduction to Redux Toolkit](https://www.freecodecamp.org/news/redux-toolkit-introduction/)

**Expected Output:**
For Example 1:
```
Creates a slice of state with actions and reducer using Redux Toolkit and configures the store.
```
For Example 2:
```
Displays a counter with buttons to increment and decrement the count using Redux Toolkit.
```

---

### Task 10: Implement state management with Redux Toolkit

**Explanation:**
Implementing state management with Redux Toolkit involves using its utilities to create slices of state, configure the store, and manage asynchronous actions. Redux Toolkit simplifies the Redux setup process by providing a standardized way to write Redux logic, reducing boilerplate code and enforcing best practices.



Implementing state management with Redux Toolkit is essential for modern Redux development. It allows developers to write more concise and maintainable Redux code, making it easier to manage state in complex applications.

**Resources:**
- [Redux Toolkit Documentation](https://redux-toolkit.js.org/)
- [Redux Official Documentation: Using Redux Toolkit](https://redux.js.org/introduction/why-rtk-is-redux-today)

**Example 1:**
```javascript
import { configureStore, createSlice } from '@reduxjs/toolkit';

// Create a slice of state
const todosSlice = createSlice({
  name: 'todos',
  initialState: { todos: [] },
  reducers: {
    addTodo: (state, action) => {
      state.todos.push({ id: state.todos.length, text: action.payload, completed: false });
    },
    toggleTodo: (state, action) => {
      const todo = state.todos.find(todo => todo.id === action.payload);
      if (todo) {
        todo.completed = !todo.completed;
      }
    },
  },
});

// Export actions and reducer
export const { addTodo, toggleTodo } = todosSlice.actions;
export const todosReducer = todosSlice.reducer;

// Configure store
const store = configureStore({ reducer: todosReducer });

export default store;
```

**Example Explanation:**
This example demonstrates creating a slice of state for a todo application using Redux Toolkit. The `createSlice` function defines the state, reducers, and actions. The `configureStore` function creates a Redux store with the slice's reducer.

**Example 2:**
```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store, { addTodo, toggleTodo } from './store';

function TodoApp() {
  const [text, setText] = useState('');
  const dispatch = useDispatch();
  const todos = useSelector(state => state.todos);

  const handleAddTodo = () => {
    dispatch(addTodo(text));
    setText('');
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={text}
        onChangeText={setText}
        placeholder="Add a todo"
      />
      <Button title="Add Todo" onPress={handleAddTodo} />
      {todos.map(todo => (
        <Text
          key={todo.id}
          style={{ textDecorationLine: todo.completed ? 'line-through' : 'none' }}
          onPress={() => dispatch(toggleTodo(todo.id))}
        >
          {todo.text}
        </Text>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginBottom: 20,
    width: '80%',
  },
});

export default function App() {
  return (
    <Provider store={store}>
      <TodoApp />
    </Provider>
  );
}
```

**Example Explanation:**
This example demonstrates integrating a Redux Toolkit slice with a React Native component for a todo application. The `TodoApp` component uses `useDispatch` to dispatch actions and `useSelector` to select the state from the store. The `Provider` component wraps the app to provide the Redux store to all components.

**Resources:**
- [W3Schools: Using Redux Toolkit](https://www.w3schools.com/react/react_redux.asp)
- [FreeCodeCamp: State Management with Redux Toolkit](https://www.freecodecamp.org/news/redux-toolkit-state-management/)

**Expected Output:**
For Example 1:
```
Creates a slice of state with actions and reducer for a todo application using Redux Toolkit and configures the store.
```
For Example 2:
```
Displays a todo list with the ability to add and toggle todos using Redux Toolkit.
```

---

### Task 11: Learn about Context API in React Native

**Explanation:**
The Context API in React Native provides a way to pass data through the component tree without having to pass props down manually at every level. It is particularly useful for global state management, such as theme settings or user authentication, where the state needs to be accessible by many components.

Learning about the Context API is essential for managing global state in a React Native application. It simplifies the state management process by eliminating the need for prop drilling and provides a more efficient way to share state across multiple components.

**Resources:**
- [React Official Documentation: Context](https://reactjs.org/docs/context.html)
- [JavaScript.info: React Context](https://javascript.info/react/context)

**Example 1:**
```javascript
import React, { createContext, useState } from 'react';

// Create a context
const ThemeContext = createContext();

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
}

export { ThemeContext, ThemeProvider };
```

**Example Explanation:**
This example demonstrates creating a context for managing theme settings. The `ThemeProvider` component uses the `useState` hook to manage the theme state and provides it to the component tree through the `ThemeContext.Provider`.

**Example 2:**
```javascript
import React, { useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { ThemeContext, ThemeProvider } from './theme-context';

function ThemeSwitcher() {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <View style={[styles.container, { backgroundColor: theme === 'light' ? '#fff' : '#333' }]}>
      <Text style={{ color: theme === 'light' ? '#000' : '#fff' }}>Current Theme: {theme}</Text>
      <Button
        title="Toggle Theme"
        onPress={() => setTheme(theme === 'light' ? 'dark' : 'light')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default function App() {
  return (
    <ThemeProvider>
      <ThemeSwitcher />
    </ThemeProvider>
  );
}
```

**Example Explanation:**
This example demonstrates using the `ThemeContext` in a component. The `ThemeSwitcher` component uses the `useContext` hook to access the theme state and toggle the theme between light and dark modes. The `ThemeProvider` wraps the app to provide the theme state to all components.

**Resources:**
- [W3Schools: React Context API](https://www.w3schools.com/react/react_context.asp)
- [FreeCodeCamp: Using Context API in React Native](https://www.freecodecamp.org/news/react-native-context-api/)

**Expected Output:**
For Example 1:
```
Creates a context and provider component for managing theme settings.
```
For Example 2:
```
Displays a component that toggles between light and dark themes using the Context API.
```

---

### Task 12: Implement global state with Context API

**Explanation:**
Implementing global state with the Context API involves creating context objects to hold the global state and provider components to supply the state to the component tree. The `useContext` hook is used to consume the context values in functional components. This approach is useful for managing global state such as user authentication, theme settings, and application configuration.

Implementing global state with the Context API is essential for avoiding prop drilling and making the state accessible to multiple components. It simplifies the state management process and provides a more efficient way to share state across the application.

**Resources:**
- [React Official Documentation: Context](https://reactjs.org/docs/context.html)
- [JavaScript.info: Using Context API for Global State](https://javascript.info/react/context)

**Example 1:**
```javascript
import React, { createContext, useState } from 'react';

// Create a context
const AuthContext = createContext();

function AuthProvider({ children }) {
  const [user, setUser] = useState(null);

  return (
    <AuthContext.Provider value={{ user, setUser }}>
      {children}
    </AuthContext.Provider>
  );
}

export { AuthContext, AuthProvider };
```

**Example Explanation:**
This example demonstrates creating a context for managing user authentication. The `AuthProvider` component uses the `useState` hook to manage the user state and provides it to the component tree through the `AuthContext.Provider`.

**Example 2:**
```javascript
import React, { useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import { AuthContext, AuthProvider } from './auth-context';

function UserProfile() {
  const { user, setUser } = useContext(AuthContext);

  return (
    <View style={styles.container}>
      {user ? (
        <Text>Welcome, {user.name}</Text>
      ) : (
        <Button title="Login" onPress={() => setUser({ name: 'John Doe' })} />
      )}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default function App() {
  return (
    <AuthProvider>
      <UserProfile />
    </AuthProvider>
  );
}
```

**Example Explanation:**
This example demonstrates using

 the `AuthContext` in a component. The `UserProfile` component uses the `useContext` hook to access the user state and display a welcome message or a login button based on the user's authentication status. The `AuthProvider` wraps the app to provide the user state to all components.

**Resources:**
- [W3Schools: Global State with Context API](https://www.w3schools.com/react/react_context.asp)
- [FreeCodeCamp: Implementing Global State with Context API in React Native](https://www.freecodecamp.org/news/react-native-global-state-context-api/)

**Expected Output:**
For Example 1:
```
Creates a context and provider component for managing user authentication.
```
For Example 2:
```
Displays a component that shows a welcome message or login button based on the user's authentication status using the Context API.
```

---

### Task 13: Study local storage solutions

**Explanation:**
Local storage solutions in React Native allow you to persist data on the device, providing a way to store information that needs to be retained across app sessions. Common local storage options include `AsyncStorage`, which provides a simple key-value storage system, and more advanced options like `redux-persist` for persisting Redux state.

Studying local storage solutions is essential for building applications that require data persistence. It allows you to save user preferences, cache data, and manage state across app sessions, enhancing the overall user experience.

**Resources:**
- [React Native Official Documentation: AsyncStorage](https://reactnative.dev/docs/asyncstorage)
- [Redux-Persist Documentation](https://github.com/rt2zz/redux-persist)

**Example 1:**
```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

// Store data
const storeData = async (key, value) => {
  try {
    await AsyncStorage.setItem(key, value);
  } catch (e) {
    console.error('Failed to save data', e);
  }
};

// Retrieve data
const getData = async (key) => {
  try {
    const value = await AsyncStorage.getItem(key);
    if (value !== null) {
      return value;
    }
  } catch (e) {
    console.error('Failed to fetch data', e);
  }
};
```

**Example Explanation:**
This example demonstrates storing and retrieving data using `AsyncStorage`. The `storeData` function saves a key-value pair to local storage, and the `getData` function retrieves the value for a given key.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

function App() {
  useEffect(() => {
    const loadData = async () => {
      const value = await AsyncStorage.getItem('exampleKey');
      if (value !== null) {
        console.log('Retrieved value:', value);
      }
    };

    loadData();
  }, []);

  const saveData = async () => {
    await AsyncStorage.setItem('exampleKey', 'exampleValue');
    console.log('Data saved');
  };

  return (
    <View style={styles.container}>
      <Button title="Save Data" onPress={saveData} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates saving and retrieving data using `AsyncStorage` in a React Native component. The `saveData` function saves a key-value pair to local storage, and the `useEffect` hook retrieves the value when the component mounts.

**Resources:**
- [W3Schools: React Native Local Storage](https://www.w3schools.com/react/react_native_localstorage.asp)
- [FreeCodeCamp: Local Storage in React Native](https://www.freecodecamp.org/news/react-native-local-storage/)

**Expected Output:**
For Example 1:
```
Demonstrates storing and retrieving data using AsyncStorage.
```
For Example 2:
```
Demonstrates saving and retrieving data using AsyncStorage in a React Native component.
```

---

### Task 14: Use AsyncStorage for data persistence

**Explanation:**
AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the app. It is used to persist data across app reboots, making it useful for storing user preferences, session data, and other small pieces of state. AsyncStorage is easy to use and integrates well with React Native.

Using AsyncStorage for data persistence is essential for building applications that need to retain data across sessions. It allows you to save user settings, cache data, and manage state in a way that enhances the user experience by providing consistency across app restarts.

**Resources:**
- [React Native Official Documentation: AsyncStorage](https://reactnative.dev/docs/asyncstorage)
- [JavaScript.info: AsyncStorage in React Native](https://javascript.info/react-native/asyncstorage)

**Example 1:**
```javascript
import AsyncStorage from '@react-native-async-storage/async-storage';

// Store data
const storeData = async (key, value) => {
  try {
    await AsyncStorage.setItem(key, value);
  } catch (e) {
    console.error('Failed to save data', e);
  }
};

// Retrieve data
const getData = async (key) => {
  try {
    const value = await AsyncStorage.getItem(key);
    if (value !== null) {
      return value;
    }
  } catch (e) {
    console.error('Failed to fetch data', e);
  }
};
```

**Example Explanation:**
This example demonstrates storing and retrieving data using AsyncStorage. The `storeData` function saves a key-value pair to local storage, and the `getData` function retrieves the value for a given key.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

function App() {
  useEffect(() => {
    const loadData = async () => {
      const value = await AsyncStorage.getItem('exampleKey');
      if (value !== null) {
        console.log('Retrieved value:', value);
      }
    };

    loadData();
  }, []);

  const saveData = async () => {
    await AsyncStorage.setItem('exampleKey', 'exampleValue');
    console.log('Data saved');
  };

  return (
    <View style={styles.container}>
      <Button title="Save Data" onPress={saveData} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates saving and retrieving data using AsyncStorage in a React Native component. The `saveData` function saves a key-value pair to local storage, and the `useEffect` hook retrieves the value when the component mounts.

**Resources:**
- [W3Schools: React Native AsyncStorage](https://www.w3schools.com/react/react_native_asyncstorage.asp)
- [FreeCodeCamp: Using AsyncStorage in React Native](https://www.freecodecamp.org/news/react-native-asyncstorage/)

**Expected Output:**
For Example 1:
```
Demonstrates storing and retrieving data using AsyncStorage.
```
For Example 2:
```
Demonstrates saving and retrieving data using AsyncStorage in a React Native component.
```

---

### Task 15: Learn about secure storage

**Explanation:**
Secure storage in React Native involves storing sensitive data, such as authentication tokens or user credentials, in a secure and encrypted manner. Libraries like `react-native-keychain` and `SecureStore` provide mechanisms for securely storing sensitive information on the device. Secure storage ensures that sensitive data is protected from unauthorized access.

Learning about secure storage is essential for building secure applications that handle sensitive data. It allows you to implement best practices for data security and protect user information from potential threats.

**Resources:**
- [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
- [Expo SecureStore Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)

**Example 1:**
```javascript
import * as Keychain from 'react-native-keychain';

// Store credentials
const storeCredentials = async (username, password) => {
  try {
    await Keychain.setGenericPassword(username, password);
    console.log('Credentials stored successfully');
  } catch (error) {
    console.error('Failed to store credentials', error);
  }
};

// Retrieve credentials
const getCredentials = async () => {
  try {
    const credentials = await Keychain.getGenericPassword();
    if (credentials) {
      console.log('Credentials retrieved:', credentials);
    } else {
      console.log('No credentials stored');
    }
  } catch (error) {
    console.error('Failed to retrieve credentials', error);
  }
};
```

**Example Explanation:**
This example demonstrates storing and retrieving credentials using `react-native-keychain`. The `storeCredentials` function saves the username and password securely, and the `getCredentials` function retrieves the stored credentials.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as SecureStore from 'expo-secure-store';

function App() {
  useEffect(() => {
    const loadData = async ()

 => {
      const value = await SecureStore.getItemAsync('secureKey');
      if (value) {
        console.log('Retrieved value:', value);
      }
    };

    loadData();
  }, []);

  const saveData = async () => {
    await SecureStore.setItemAsync('secureKey', 'secureValue');
    console.log('Data saved securely');
  };

  return (
    <View style={styles.container}>
      <Button title="Save Data" onPress={saveData} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates saving and retrieving data securely using `SecureStore` from Expo. The `saveData` function saves a key-value pair securely, and the `useEffect` hook retrieves the value when the component mounts.

**Resources:**
- [W3Schools: Secure Storage in React Native](https://www.w3schools.com/react/react_native_securestorage.asp)
- [FreeCodeCamp: Implementing Secure Storage in React Native](https://www.freecodecamp.org/news/react-native-secure-storage/)

**Expected Output:**
For Example 1:
```
Demonstrates storing and retrieving credentials securely using react-native-keychain.
```
For Example 2:
```
Demonstrates saving and retrieving data securely using SecureStore from Expo.
```

---

### Task 16: Use SecureStore for sensitive data

**Explanation:**
SecureStore is a secure storage solution provided by Expo that allows you to store sensitive data, such as authentication tokens and user credentials, securely on the device. It uses encryption to protect the data from unauthorized access and ensures that sensitive information is stored safely.

Using SecureStore for sensitive data is essential for building secure applications that handle sensitive information. It provides a secure and reliable way to store data, ensuring that user information is protected from potential threats.

**Resources:**
- [Expo SecureStore Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
- [JavaScript.info: Secure Storage in React Native](https://javascript.info/react-native/securestorage)

**Example 1:**
```javascript
import * as SecureStore from 'expo-secure-store';

// Store data securely
const storeSecureData = async (key, value) => {
  try {
    await SecureStore.setItemAsync(key, value);
    console.log('Data stored securely');
  } catch (error) {
    console.error('Failed to store data', error);
  }
};

// Retrieve data securely
const getSecureData = async (key) => {
  try {
    const value = await SecureStore.getItemAsync(key);
    if (value) {
      console.log('Retrieved value:', value);
    } else {
      console.log('No data stored');
    }
  } catch (error) {
    console.error('Failed to retrieve data', error);
  }
};
```

**Example Explanation:**
This example demonstrates storing and retrieving data securely using SecureStore from Expo. The `storeSecureData` function saves a key-value pair securely, and the `getSecureData` function retrieves the value for a given key.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as SecureStore from 'expo-secure-store';

function App() {
  useEffect(() => {
    const loadData = async () => {
      const value = await SecureStore.getItemAsync('secureKey');
      if (value) {
        console.log('Retrieved value:', value);
      }
    };

    loadData();
  }, []);

  const saveData = async () => {
    await SecureStore.setItemAsync('secureKey', 'secureValue');
    console.log('Data saved securely');
  };

  return (
    <View style={styles.container}>
      <Button title="Save Data" onPress={saveData} />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates saving and retrieving data securely using SecureStore from Expo. The `saveData` function saves a key-value pair securely, and the `useEffect` hook retrieves the value when the component mounts.

**Resources:**
- [W3Schools: Using SecureStore in React Native](https://www.w3schools.com/react/react_native_securestorage.asp)
- [FreeCodeCamp: Secure Data Storage in React Native](https://www.freecodecamp.org/news/react-native-secure-storage/)

**Expected Output:**
For Example 1:
```
Demonstrates storing and retrieving data securely using SecureStore from Expo.
```
For Example 2:
```
Demonstrates saving and retrieving data securely using SecureStore from Expo in a React Native component.
```

---

### Task 17: Study push notifications

**Explanation:**
Push notifications are messages sent from a server to a mobile application, even when the app is not actively running. They are used to engage users by delivering timely and relevant information. Implementing push notifications in React Native typically involves using services like Firebase Cloud Messaging (FCM) or Expo Push Notifications.

Studying push notifications is essential for building applications that require user engagement and real-time updates. It allows you to notify users about important events, updates, or actions, improving user retention and interaction with your app.

**Resources:**
- [Firebase Cloud Messaging Documentation](https://firebase.google.com/docs/cloud-messaging)
- [Expo Push Notifications Documentation](https://docs.expo.dev/push-notifications/overview/)

**Example 1:**
```javascript
// Install Firebase dependencies
// npm install @react-native-firebase/app @react-native-firebase/messaging

import messaging from '@react-native-firebase/messaging';

// Request permission to send notifications
async function requestUserPermission() {
  const authStatus = await messaging().requestPermission();
  const enabled =
    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
    authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }
}

// Get FCM token
async function getToken() {
  const token = await messaging().getToken();
  console.log('FCM Token:', token);
}

// Handle incoming messages
messaging().onMessage(async remoteMessage => {
  console.log('A new FCM message arrived!', remoteMessage);
});
```

**Example Explanation:**
This example demonstrates setting up Firebase Cloud Messaging (FCM) in a React Native application. It requests permission to send notifications, retrieves the FCM token, and handles incoming messages.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Notifications from 'expo-notifications';
import * as Permissions from 'expo-permissions';

async function registerForPushNotificationsAsync() {
  const { status } = await Permissions.getAsync(Permissions.NOTIFICATIONS);
  if (status !== 'granted') {
    const { status } = await Permissions.askAsync(Permissions.NOTIFICATIONS);
    if (status !== 'granted') {
      alert('Failed to get push token for push notification!');
      return;
    }
  }
  const token = (await Notifications.getExpoPushTokenAsync()).data;
  console.log('Expo Push Token:', token);
}

function App() {
  useEffect(() => {
    registerForPushNotificationsAsync();

    Notifications.addNotificationReceivedListener(notification => {
      console.log('Notification received:', notification);
    });

    Notifications.addNotificationResponseReceivedListener(response => {
      console.log('Notification response received:', response);
    });
  }, []);

  return (
    <View style={styles.container}>
      <Text>Push Notifications Example</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates setting up Expo Push Notifications in a React Native application. It requests permission to send notifications, retrieves the Expo push token, and handles incoming notifications and responses.

**Resources:**
- [W3Schools: Push Notifications in React Native](https://www.w3schools.com/react/react_native_push_notifications.asp)
- [FreeCodeCamp: Push Notifications in React Native](https://www.freecodecamp.org/news/react-native-push-notifications/)

**Expected Output:**
For Example 1:
```
Requests permission to send notifications, retrieves FCM token, and handles incoming messages using Firebase Cloud Messaging.
```
For Example 2:
```
Requests permission to send notifications, retrieves Expo push token, and handles incoming notifications using Expo Push Notifications.
```

---

### Task 18: Implement push notifications with Firebase

**Explanation:**
Implementing push notifications with Firebase involves using Firebase Cloud Messaging (FCM) to send notifications to your React Native application. FCM provides a reliable and scalable way to send messages to users, even when the app is not running. It requires setting up Firebase in your project, requesting user permission, retrieving the FCM token, and handling incoming messages.

Implementing push notifications with Firebase is essential for engaging users with timely and relevant information. It allows you to notify users about important events, updates, or actions, improving user retention and interaction with your app.

**Resources:**
- [Firebase Cloud Messaging Documentation](https://firebase.google.com/docs/cloud-messaging)
- [React Native Firebase Documentation](https://rnfirebase.io/messaging/usage)

**Example 1:**
```javascript
// Install Firebase dependencies


// npm install @react-native-firebase/app @react-native-firebase/messaging

import messaging from '@react-native-firebase/messaging';

// Request permission to send notifications
async function requestUserPermission() {
  const authStatus = await messaging().requestPermission();
  const enabled =
    authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
    authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }
}

// Get FCM token
async function getToken() {
  const token = await messaging().getToken();
  console.log('FCM Token:', token);
}

// Handle incoming messages
messaging().onMessage(async remoteMessage => {
  console.log('A new FCM message arrived!', remoteMessage);
});
```

**Example Explanation:**
This example demonstrates setting up Firebase Cloud Messaging (FCM) in a React Native application. It requests permission to send notifications, retrieves the FCM token, and handles incoming messages.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, StyleSheet } from 'react-native';
import messaging from '@react-native-firebase/messaging';

function App() {
  useEffect(() => {
    const requestUserPermission = async () => {
      const authStatus = await messaging().requestPermission();
      const enabled =
        authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
        authStatus === messaging.AuthorizationStatus.PROVISIONAL;

      if (enabled) {
        console.log('Authorization status:', authStatus);
      }
    };

    const getToken = async () => {
      const token = await messaging().getToken();
      console.log('FCM Token:', token);
    };

    requestUserPermission();
    getToken();

    const unsubscribe = messaging().onMessage(async remoteMessage => {
      console.log('A new FCM message arrived!', remoteMessage);
    });

    return unsubscribe;
  }, []);

  return (
    <View style={styles.container}>
      <Text>Push Notifications with Firebase</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates setting up Firebase Cloud Messaging (FCM) in a React Native component. It requests permission to send notifications, retrieves the FCM token, and handles incoming messages using the `useEffect` hook.

**Resources:**
- [W3Schools: Firebase Push Notifications in React Native](https://www.w3schools.com/react/react_native_push_notifications.asp)
- [FreeCodeCamp: Implementing Push Notifications with Firebase in React Native](https://www.freecodecamp.org/news/react-native-push-notifications-firebase/)

**Expected Output:**
For Example 1:
```
Requests permission to send notifications, retrieves FCM token, and handles incoming messages using Firebase Cloud Messaging.
```
For Example 2:
```
Requests permission to send notifications, retrieves FCM token, and handles incoming messages using Firebase Cloud Messaging in a React Native component.
```

---

### Task 19: Learn about deep linking

**Explanation:**
Deep linking is a technique used to link directly to specific content within an app. In React Native, deep linking allows you to navigate to specific screens or pass parameters when the app is opened from a URL. This can be useful for features like sharing content, email invitations, or integrating with other apps.

Learning about deep linking is essential for building applications that provide a seamless user experience. It allows users to navigate directly to the content they are interested in, improving engagement and usability.

**Resources:**
- [React Native Official Documentation: Linking](https://reactnative.dev/docs/linking)
- [React Navigation Documentation: Deep Linking](https://reactnavigation.org/docs/deep-linking)

**Example 1:**
```javascript
import { Linking } from 'react-native';

// Handle deep linking
const handleOpenURL = (event) => {
  console.log('Deep link URL:', event.url);
};

// Add event listener
Linking.addEventListener('url', handleOpenURL);

// Remove event listener
Linking.removeEventListener('url', handleOpenURL);
```

**Example Explanation:**
This example demonstrates handling deep linking in a React Native application. The `handleOpenURL` function logs the deep link URL, and event listeners are added and removed using `Linking.addEventListener` and `Linking.removeEventListener`.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet, Linking } from 'react-native';

function App() {
  useEffect(() => {
    const handleOpenURL = (event) => {
      console.log('Deep link URL:', event.url);
    };

    Linking.addEventListener('url', handleOpenURL);

    return () => {
      Linking.removeEventListener('url', handleOpenURL);
    };
  }, []);

  return (
    <View style={styles.container}>
      <Button title="Open URL" onPress={() => Linking.openURL('myapp://example')} />
      <Text>Deep Linking Example</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates handling deep linking in a React Native component. The `useEffect` hook sets up and cleans up the event listener for handling deep links, and a button is provided to open a URL that triggers the deep link handler.

**Resources:**
- [W3Schools: Deep Linking in React Native](https://www.w3schools.com/react/react_native_deep_linking.asp)
- [FreeCodeCamp: Implementing Deep Linking in React Native](https://www.freecodecamp.org/news/react-native-deep-linking/)

**Expected Output:**
For Example 1:
```
Logs the deep link URL when the app is opened from a deep link.
```
For Example 2:
```
Handles deep linking in a React Native component and logs the deep link URL.
```

---

### Task 20: Implement deep linking in the app

**Explanation:**
Implementing deep linking in a React Native app involves setting up URL schemes, handling incoming URLs, and navigating to specific screens based on the URL. This allows users to open the app from a URL and navigate directly to specific content. Deep linking is useful for features like sharing content, email invitations, and integrating with other apps.

Implementing deep linking in the app is essential for providing a seamless user experience. It allows users to navigate directly to the content they are interested in, improving engagement and usability.

**Resources:**
- [React Native Official Documentation: Linking](https://reactnative.dev/docs/linking)
- [React Navigation Documentation: Deep Linking](https://reactnavigation.org/docs/deep-linking)

**Example 1:**
```javascript
import { Linking } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

const linking = {
  prefixes: ['myapp://'],
  config: {
    screens: {
      Home: 'home',
      Profile: 'profile/:id',
    },
  },
};

function App() {
  return (
    <NavigationContainer linking={linking}>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates setting up deep linking with React Navigation. The `linking` configuration defines URL prefixes and screen paths, and the `NavigationContainer` is configured with the `linking` prop to handle deep links.

**Example 2:**
```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet, Linking } from 'react-native';

function HomeScreen() {
  return (
    <View style={styles.container}>
      <Text>Home Screen</Text>
    </View>
  );
}

function ProfileScreen({ route }) {
  return (
    <View style={styles.container}>
      <Text>Profile Screen</Text>
      <Text>ID: {route.params.id}</Text>
    </View>
  );
}

function App() {
  useEffect(() => {
    const handleOpenURL = (event) => {
      console.log('Deep link URL:', event.url);
    };

    Linking.addEventListener('url', handleOpenURL);

    return () => {
      Linking.removeEventListener('url', handleOpenURL);
    };
  }, []);

  return (
    <View style={styles.container}>
      <Button title="Open Profile" onPress={() => Linking.openURL('myapp://profile/123')} />
      <Text>Deep Linking Example</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Example Explanation:**
This example demonstrates handling deep linking in a React Native component and navigating to a specific screen based on the URL. The `ProfileScreen` component displays the profile ID passed through the deep link.

**Resources:**
- [W3Schools: Deep Linking in React Native](https://www.w3schools.com/react/react_native_deep_linking.asp)
- [FreeCodeCamp: Deep Linking in React Native](https://www.freecodecamp.org/news/react-native-deep-linking/)

**Expected Output:**
For Example 1:
```
Sets up deep

 linking with React Navigation and handles deep links to specific screens.
```
For Example 2:
```
Handles deep linking in a React Native component and navigates to specific screens based on the URL.
```
---
