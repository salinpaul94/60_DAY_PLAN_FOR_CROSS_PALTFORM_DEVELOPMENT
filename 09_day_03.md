# prompt
## split day 3 studying to 20 tasks to complete, for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Day 3 Study Plan: JavaScript Advanced Topics

#### Task 1: JavaScript ES6 Features
**Explanation:**
ES6, also known as ECMAScript 2015, introduced several new features to JavaScript that enhance its capabilities and make coding more efficient. Key features include `let` and `const` for block-scoped variable declarations, arrow functions for concise function syntax, template literals for string interpolation, and destructuring for extracting values from arrays and objects.

Understanding ES6 features is essential for modern JavaScript development, as they simplify the code and improve readability. These features also introduce new ways to handle asynchronous operations, such as Promises, and add syntactic sugar for classes, making object-oriented programming in JavaScript more accessible.

**Online Resources:**
1. [ES6 Features - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
2. [Introduction to ES6](https://www.w3schools.com/js/js_es6.asp)

**Example 1: Let and Const**
1. **Let Declaration:** Use `let` to declare block-scoped variables.
2. **Const Declaration:** Use `const` to declare constants.

**Explanation for Example 1:**
`let` allows you to declare variables that are limited in scope to the block, statement, or expression in which they are used, preventing issues with variable hoisting. `const` is used to declare variables that cannot be reassigned, ensuring that their values remain constant throughout the program.

**Example 2: Arrow Functions**
1. **Basic Arrow Function:** Use an arrow function to write a simple function.
2. **Arrow Function with Parameters:** Use an arrow function with parameters and a concise body.

**Explanation for Example 2:**
Arrow functions provide a shorter syntax for writing functions, making the code cleaner and more concise. They also lexically bind the `this` value, which can simplify handling the `this` context in nested functions or callbacks.

**Online Resources:**
1. [Let and Const](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let)
2. [Arrow Functions](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions)

**Code and Expected Output:**
```js
// Let and Const
let name = 'Alice';
const age = 30;
name = 'Bob';
// age = 25; // This will throw an error

console.log(name); // Expected Output: Bob
console.log(age); // Expected Output: 30
```

```js
// Arrow Functions
const add = (a, b) => a + b;
const greet = name => `Hello, ${name}!`;

console.log(add(2, 3)); // Expected Output: 5
console.log(greet('Alice')); // Expected Output: Hello, Alice!
```

#### Task 2: JavaScript Promises
**Explanation:**
Promises in JavaScript represent the eventual completion (or failure) of an asynchronous operation and its resulting value. A Promise is an object that may produce a single value some time in the future: either a resolved value or a reason that it’s not resolved (e.g., a network error). Promises simplify handling asynchronous code, avoiding the need for deeply nested callbacks (callback hell).

Promises have three states: pending, fulfilled, and rejected. The `then()` method is used to handle the fulfillment, while `catch()` handles any errors that occur. Understanding how to use Promises is essential for managing asynchronous operations effectively in JavaScript.

**Online Resources:**
1. [JavaScript Promises - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
2. [JavaScript Promise Tutorial](https://www.w3schools.com/js/js_promise.asp)

**Example 1: Creating and Using Promises**
1. **Creating a Promise:** Create a Promise that resolves after a delay.
2. **Using .then():** Use the `.then()` method to handle the resolved value.

**Explanation for Example 1:**
Creating a Promise involves defining an executor function that takes `resolve` and `reject` as arguments. The `.then()` method allows you to specify what to do when the Promise is resolved, enabling you to chain asynchronous operations in a clean and readable way.

**Example 2: Handling Errors with .catch()**
1. **Rejecting a Promise:** Create a Promise that rejects with an error.
2. **Using .catch():** Use the `.catch()` method to handle the rejection.

**Explanation for Example 2:**
Rejecting a Promise involves calling the `reject` function with an error message. The `.catch()` method allows you to specify what to do when the Promise is rejected, enabling you to handle errors gracefully in your asynchronous code.

**Online Resources:**
1. [Using Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
2. [JavaScript Promises Tutorial](https://javascript.info/promise-basics)

**Code and Expected Output:**
```js
// Creating and Using Promises
const delay = ms => new Promise(resolve => setTimeout(resolve, ms));

delay(1000).then(() => console.log('Resolved after 1 second'));
// Expected Output: Resolved after 1 second (after 1 second delay)
```

```js
// Handling Errors with .catch()
const willReject = new Promise((resolve, reject) => {
    setTimeout(() => reject(new Error('Promise rejected!')), 1000);
});

willReject.then(() => console.log('This will not run'))
    .catch(error => console.error(error.message));
// Expected Output: Promise rejected! (after 1 second delay)
```

#### Task 3: JavaScript Async/Await
**Explanation:**
Async/Await is syntactic sugar built on top of Promises, introduced in ES8, making asynchronous code easier to write and read. The `async` keyword before a function declaration indicates that the function will return a Promise. The `await` keyword pauses the execution of an `async` function until the Promise is resolved, simplifying the chaining of asynchronous operations.

Using Async/Await, you can write asynchronous code that looks and behaves more like synchronous code, avoiding the callback hell and improving readability. This is particularly useful when dealing with multiple asynchronous operations that depend on each other.

**Online Resources:**
1. [Async/Await - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/async_function)
2. [Async/Await Tutorial](https://javascript.info/async-await)

**Example 1: Basic Async/Await**
1. **Async Function:** Declare an async function that returns a resolved Promise.
2. **Awaiting a Promise:** Use `await` to wait for the Promise to resolve before continuing execution.

**Explanation for Example 1:**
The `async` keyword makes a function return a Promise, and `await` pauses the function execution until the Promise is resolved. This allows you to write asynchronous code in a more linear and readable fashion.

**Example 2: Handling Errors with Async/Await**
1. **Try/Catch Block:** Use a `try/catch` block to handle errors in an async function.
2. **Awaiting a Rejected Promise:** Handle a rejected Promise using a `try/catch` block.

**Explanation for Example 2:**
Using a `try/catch` block within an async function allows you to handle errors gracefully. If the awaited Promise is rejected, the `catch` block will execute, enabling you to manage exceptions and continue execution.

**Online Resources:**
1. [Understanding Async/Await](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Async_await)
2. [Async/Await in JavaScript](https://www.w3schools.com/js/js_async.asp)

**Code and Expected Output:**
```js
// Basic Async/Await
async function fetchData() {
    return 'Data fetched';
}

async function displayData() {
    const data = await fetchData();
    console.log(data);
}

displayData(); // Expected Output: Data fetched
```

```js
// Handling Errors with Async/Await
async function fetchWithError() {
    throw new Error('Fetch failed');
}

async function displayWithErrorHandling() {
    try {
        const data = await fetchWithError();
        console.log(data);
    } catch (error) {
        console.error(error.message);
    }
}

displayWithErrorHandling(); // Expected Output: Fetch failed
```

#### Task 4: JavaScript Classes
**Explanation:**
JavaScript classes, introduced in ES6, provide a more intuitive syntax for creating objects and working with inheritance. A class is a blueprint for creating objects with predefined properties and methods. The `class` keyword is used to define a class, and the `constructor` method initializes the object's properties. Methods are defined within the class body, and inheritance is achieved using the `extends` keyword.

Classes in JavaScript enhance code organization and reuse, making it easier to implement object-oriented programming concepts. Understanding how to use classes and inheritance allows you to create modular, maintainable, and scalable code.

**Online Resources:**
1. [JavaScript Classes - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes)
2. [JavaScript Classes Tutorial](https://www.w3schools.com/js/js_classes.asp)

**Example 1: Creating a Class**
1. **Basic Class:** Define a class with a constructor and a method.
2. **Creating an Instance:** Create an instance of the class and call its method.

**Explanation for Example 1:**
A class definition includes a constructor method for initializing properties and other methods for defining behavior. Creating an

 instance of the class and calling its methods demonstrates how to use the class to create objects and interact with them.

**Example 2: Class Inheritance**
1. **Subclass:** Define a subclass that extends a base class.
2. **Overriding Methods:** Override a method in the subclass and call the superclass method.

**Explanation for Example 2:**
Inheritance allows you to create a new class that extends the functionality of an existing class. The `super` keyword is used to call the constructor and methods of the superclass, enabling code reuse and polymorphism.

**Online Resources:**
1. [Class Inheritance](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends)
2. [JavaScript Class Syntax](https://javascript.info/class)

**Code and Expected Output:**
```js
// Creating a Class
class Person {
    constructor(name, age) {
        this.name = name;
        this.age = age;
    }

    greet() {
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
    }
}

const alice = new Person('Alice', 30);
alice.greet(); // Expected Output: Hello, my name is Alice and I am 30 years old.
```

```js
// Class Inheritance
class Animal {
    constructor(name) {
        this.name = name;
    }

    makeSound() {
        console.log(`${this.name} makes a sound.`);
    }
}

class Dog extends Animal {
    makeSound() {
        super.makeSound();
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.makeSound();
// Expected Output:
// Rex makes a sound.
// Rex barks.
```

#### Task 5: JavaScript Modules
**Explanation:**
JavaScript modules allow you to organize and reuse code by breaking it into separate files, each exporting specific functionalities. The `export` keyword is used to export functions, objects, or primitives from a module, and the `import` keyword is used to bring them into another module. Modules provide a way to manage dependencies and encapsulate code, promoting code reuse and maintainability.

Using modules, you can avoid polluting the global namespace and keep related code together. This makes it easier to manage large codebases and collaborate with other developers, as each module can be developed and tested independently.

**Online Resources:**
1. [JavaScript Modules - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)
2. [JavaScript ES6 Modules](https://www.w3schools.com/js/js_modules.asp)

**Example 1: Exporting and Importing Modules**
1. **Exporting a Function:** Export a function from one module.
2. **Importing a Function:** Import and use the function in another module.

**Explanation for Example 1:**
Exporting functions from a module allows them to be reused in other parts of the application. Importing these functions into other modules demonstrates how to share functionality across different files, promoting code reuse.

**Example 2: Named and Default Exports**
1. **Named Exports:** Use named exports to export multiple values from a module.
2. **Default Export:** Use default export to export a single value from a module.

**Explanation for Example 2:**
Named exports allow you to export multiple values from a module, each identified by name. Default export allows you to export a single value from a module, which can be imported without specifying a name. This provides flexibility in how modules are structured and used.

**Online Resources:**
1. [JavaScript Import/Export](https://javascript.info/import-export)
2. [Using JavaScript Modules](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules)

**Code and Expected Output:**
```js
// Exporting and Importing Modules (file1.js)
export function greet(name) {
    return `Hello, ${name}!`;
}

// Importing and Using Modules (file2.js)
import { greet } from './file1.js';

console.log(greet('Alice')); // Expected Output: Hello, Alice!
```

```js
// Named and Default Exports (file3.js)
export const name = 'Alice';
export const age = 30;

const person = {
    name: 'Alice',
    age: 30
};
export default person;

// Importing Named and Default Exports (file4.js)
import person, { name, age } from './file3.js';

console.log(name); // Expected Output: Alice
console.log(age); // Expected Output: 30
console.log(person); // Expected Output: { name: 'Alice', age: 30 }
```

#### Task 6: JavaScript Error Handling
**Explanation:**
Error handling in JavaScript involves using `try`, `catch`, and `finally` blocks to handle exceptions and ensure that code can gracefully recover from errors. The `try` block contains code that might throw an error, while the `catch` block handles the error if it occurs. The `finally` block contains code that will always execute, regardless of whether an error was thrown or not.

Proper error handling is crucial for building robust and reliable applications. By catching and handling errors, you can prevent the application from crashing and provide meaningful feedback to the user or take corrective actions.

**Online Resources:**
1. [JavaScript Error Handling - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling)
2. [JavaScript Try Catch Tutorial](https://www.w3schools.com/js/js_errors.asp)

**Example 1: Basic Error Handling**
1. **Try/Catch Block:** Use a `try/catch` block to handle errors in code.
2. **Throwing an Error:** Explicitly throw an error within the `try` block.

**Explanation for Example 1:**
The `try/catch` block allows you to catch and handle errors that occur in the `try` block. Throwing an error explicitly demonstrates how to create and handle custom errors, providing more control over error management.

**Example 2: Finally Block**
1. **Using Finally:** Add a `finally` block to execute code regardless of whether an error occurred.
2. **Cleaning Up Resources:** Use the `finally` block to clean up resources, such as closing files or network connections.

**Explanation for Example 2:**
The `finally` block ensures that certain code will always run, regardless of whether an error occurred. This is useful for cleaning up resources or performing any final actions that must be executed, ensuring the program's stability and reliability.

**Online Resources:**
1. [JavaScript Try/Catch/Finally](https://javascript.info/try-catch)
2. [Error Handling in JavaScript](https://www.tutorialrepublic.com/javascript-tutorial/javascript-error-handling.php)

**Code and Expected Output:**
```js
// Basic Error Handling
try {
    let result = 10 / 0;
    if (!isFinite(result)) {
        throw new Error('Division by zero');
    }
    console.log(result);
} catch (error) {
    console.error(error.message);
}
// Expected Output: Division by zero
```

```js
// Finally Block
try {
    let result = 10 / 0;
    if (!isFinite(result)) {
        throw new Error('Division by zero');
    }
    console.log(result);
} catch (error) {
    console.error(error.message);
} finally {
    console.log('Execution completed');
}
// Expected Output:
// Division by zero
// Execution completed
```

#### Task 7: JavaScript DOM Manipulation
**Explanation:**
The Document Object Model (DOM) is a programming interface for web documents. It represents the structure of a document as a tree of objects, allowing JavaScript to interact with and manipulate the HTML. DOM manipulation involves selecting elements, changing their content, and modifying their styles.

Understanding how to manipulate the DOM is essential for creating dynamic and interactive web applications. Common methods for DOM manipulation include `getElementById`, `querySelector`, `innerHTML`, and `style`. These methods allow you to update the content and appearance of web pages in response to user interactions or other events.

**Online Resources:**
1. [JavaScript DOM Manipulation - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/Document_Object_Model/Introduction)
2. [JavaScript HTML DOM](https://www.w3schools.com/js/js_htmldom.asp)

**Example 1: Selecting and Modifying Elements**
1. **Selecting an Element:** Use `document.getElementById` to select an element by its ID.
2. **Modifying Content:** Use `innerHTML` to change the content of the selected element.

**Explanation for Example 1:**
Selecting an element by its ID allows you to target specific elements on the web page. Changing the content of an element using `innerHTML` allows you to dynamically update the page's content based on user interactions or other events.

**Example 2: Changing Styles**
1. **Modifying Styles:** Use the `style` property to change the CSS styles of an element.
2. **Adding and Removing Classes:** Use `classList` to add or remove CSS classes.

**Explanation for Example 2:**
Modifying styles directly allows you to change the appearance of elements dynamically. Using `classList` to add or remove CSS classes provides a flexible way to apply predefined styles based on user interactions or other conditions.

**Online Resources:**
1. [JavaScript HTML DOM Methods](https://www.w3schools.com/js/js_htmldom_methods.asp)
2. [DOM Manipulation with JavaScript](https://www.digitalocean.com/community/tutorials/introduction-to-the-dom)

**Code and Expected Output:**
```html


<!-- Selecting and Modifying Elements -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Manipulation</title>
</head>
<body>
    <h1 id="title">Original Title</h1>
    <button onclick="changeTitle()">Change Title</button>

    <script>
        function changeTitle() {
            document.getElementById('title').innerHTML = 'New Title';
        }
    </script>
</body>
</html>
```
**Expected Output:** A webpage with a heading "Original Title" and a button. Clicking the button changes the heading to "New Title."

```html
<!-- Changing Styles -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DOM Manipulation</title>
    <style>
        .highlight {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <p id="text">This is a paragraph.</p>
    <button onclick="highlightText()">Highlight Text</button>

    <script>
        function highlightText() {
            document.getElementById('text').classList.add('highlight');
        }
    </script>
</body>
</html>
```
**Expected Output:** A webpage with a paragraph and a button. Clicking the button changes the paragraph's style to red and bold.

#### Task 8: JavaScript Events
**Explanation:**
Events in JavaScript are actions that occur in the browser, such as clicks, key presses, or mouse movements. Event handling involves writing code that executes in response to these events. Event listeners are used to listen for specific events on elements and execute a callback function when the event occurs.

Understanding events and how to handle them is crucial for creating interactive web applications. Common events include `click`, `mouseover`, `keydown`, and `submit`. By handling these events, you can make your web pages more responsive and user-friendly.

**Online Resources:**
1. [JavaScript Events - W3Schools](https://www.w3schools.com/js/js_events.asp)
2. [MDN Web Docs - Event Reference](https://developer.mozilla.org/en-US/docs/Web/Events)

**Example 1: Click Event**
1. **Adding an Event Listener:** Use `addEventListener` to listen for a click event on a button.
2. **Callback Function:** Define a callback function to execute when the button is clicked.

**Explanation for Example 1:**
Adding an event listener to a button allows you to execute code when the button is clicked. The callback function defines what happens when the event occurs, such as changing the content of an element or displaying an alert.

**Example 2: Mouseover Event**
1. **Mouseover Listener:** Use `addEventListener` to listen for a mouseover event on an element.
2. **Changing Styles:** Change the styles of the element when the mouseover event occurs.

**Explanation for Example 2:**
A mouseover event occurs when the user moves the mouse pointer over an element. By handling this event, you can change the element's styles, such as highlighting it or displaying additional information, enhancing the user experience.

**Online Resources:**
1. [JavaScript Event Handling](https://developer.mozilla.org/en-US/docs/Web/Events/Event_handlers)
2. [JavaScript Event Listeners](https://www.w3schools.com/js/js_htmldom_eventlistener.asp)

**Code and Expected Output:**
```html
<!-- Click Event -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click Event</title>
</head>
<body>
    <button id="clickButton">Click Me</button>
    <p id="message"></p>

    <script>
        document.getElementById('clickButton').addEventListener('click', function() {
            document.getElementById('message').innerHTML = 'Button Clicked!';
        });
    </script>
</body>
</html>
```
**Expected Output:** A webpage with a button and a paragraph. Clicking the button changes the paragraph's content to "Button Clicked!"

```html
<!-- Mouseover Event -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mouseover Event</title>
    <style>
        .highlight {
            color: red;
            font-weight: bold;
        }
    </style>
</head>
<body>
    <p id="hoverText">Hover over this text.</p>

    <script>
        document.getElementById('hoverText').addEventListener('mouseover', function() {
            this.classList.add('highlight');
        });
    </script>
</body>
</html>
```
**Expected Output:** A webpage with a paragraph. Moving the mouse over the paragraph changes its style to red and bold.

#### Task 9: JavaScript Timers
**Explanation:**
JavaScript timers allow you to execute code at specified intervals or after a certain delay. The `setTimeout` function executes code after a specified delay, while `setInterval` repeatedly executes code at specified intervals. Timers are useful for creating animations, updating content periodically, or delaying code execution.

Understanding how to use `setTimeout` and `setInterval` is essential for managing timed events in JavaScript. These functions enable you to create dynamic and interactive web applications that respond to time-based events.

**Online Resources:**
1. [JavaScript Timers - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setTimeout)
2. [JavaScript Timing Events](https://www.w3schools.com/js/js_timing.asp)

**Example 1: Using setTimeout**
1. **Delay Execution:** Use `setTimeout` to execute code after a delay.
2. **Clearing Timeout:** Use `clearTimeout` to cancel a timeout before it executes.

**Explanation for Example 1:**
The `setTimeout` function allows you to delay code execution, which can be useful for creating animations or showing messages after a delay. The `clearTimeout` function cancels a timeout, preventing the code from executing if certain conditions are met.

**Example 2: Using setInterval**
1. **Periodic Execution:** Use `setInterval` to execute code at regular intervals.
2. **Clearing Interval:** Use `clearInterval` to stop the interval execution.

**Explanation for Example 2:**
The `setInterval` function repeatedly executes code at specified intervals, which can be useful for updating content periodically or creating repeated animations. The `clearInterval` function stops the interval execution, preventing the code from running further.

**Online Resources:**
1. [JavaScript setTimeout](https://javascript.info/settimeout-setinterval)
2. [JavaScript setInterval](https://developer.mozilla.org/en-US/docs/Web/API/WindowOrWorkerGlobalScope/setInterval)

**Code and Expected Output:**
```js
// Using setTimeout
const timeoutId = setTimeout(() => {
    console.log('Executed after 2 seconds');
}, 2000);

// Clearing Timeout
clearTimeout(timeoutId); // Expected Output: Nothing, as the timeout is cleared
```

```js
// Using setInterval
const intervalId = setInterval(() => {
    console.log('Executed every 1 second');
}, 1000);

// Clearing Interval
setTimeout(() => {
    clearInterval(intervalId);
    console.log('Interval cleared');
}, 5000);
// Expected Output:
// Executed every 1 second (repeats 4 times)
// Interval cleared (after 5 seconds)
```

#### Task 10: JavaScript Closures
**Explanation:**
Closures in JavaScript are functions that have access to the outer (enclosing) function’s variables, even after the outer function has returned. A closure is created when a function is defined inside another function, and the inner function retains access to the variables of the outer function. Closures are a powerful feature that enable functions to have private variables and persistent state.

Closures are used in various scenarios, such as data encapsulation, function factories, and callback functions. Understanding closures is essential for mastering JavaScript, as they form the foundation of many advanced programming techniques.

**Online Resources:**
1. [JavaScript Closures - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Closures)
2. [Understanding JavaScript Closures](https://javascript.info/closure)

**Example 1: Basic Closure**
1. **Creating a Closure:** Define a function inside another function and access the outer function’s variables.
2. **Persistent State:** Demonstrate how closures maintain state across function calls.

**Explanation for Example 1:**
A closure allows the inner function to access and retain the variables of the outer function, even after the outer function has executed. This enables the inner function to maintain state and create private variables that are not accessible from outside.

**Example 2: Function Factory**
1. **Creating Functions Dynamically:** Use closures to create functions dynamically with different behaviors.
2. **Customizing Functions:** Demonstrate how closures can customize functions based on different parameters.

**Explanation for Example 2:**
Function factories use closures to create multiple functions with different behaviors based on parameters passed to the outer function. This technique allows for dynamic function creation and customization, providing flexibility and reusability.

**Online Resources:**
1. [Closures Tutorial

](https://www.w3schools.com/js/js_function_closures.asp)
2. [JavaScript Closure Examples](https://www.digitalocean.com/community/tutorials/understanding-closures-in-javascript)

**Code and Expected Output:**
```js
// Basic Closure
function outerFunction() {
    let outerVariable = 'I am an outer variable';

    function innerFunction() {
        console.log(outerVariable);
    }

    return innerFunction;
}

const closure = outerFunction();
closure(); // Expected Output: I am an outer variable
```

```js
// Function Factory
function createGreeting(greeting) {
    return function(name) {
        console.log(`${greeting}, ${name}!`);
    };
}

const sayHello = createGreeting('Hello');
const sayHi = createGreeting('Hi');

sayHello('Alice'); // Expected Output: Hello, Alice!
sayHi('Bob'); // Expected Output: Hi, Bob!
```

#### Task 11: JavaScript Higher-Order Functions
**Explanation:**
Higher-order functions are functions that operate on other functions, either by taking them as arguments or by returning them. In JavaScript, functions are first-class citizens, meaning they can be passed as arguments, returned from other functions, and assigned to variables. Higher-order functions enable functional programming techniques, allowing you to write more modular, reusable, and concise code.

Common examples of higher-order functions in JavaScript include `map`, `filter`, and `reduce`. These functions operate on arrays, transforming, filtering, or reducing their elements based on a provided callback function. Understanding higher-order functions is essential for writing functional and declarative JavaScript code.

**Online Resources:**
1. [Higher-Order Functions - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Higher_order_functions)
2. [JavaScript Higher-Order Functions](https://javascript.info/funciton#higher-order-functions)

**Example 1: Array Map Function**
1. **Using Map:** Use the `map` function to transform an array by applying a callback function to each element.
2. **Doubling Values:** Demonstrate how to use `map` to double the values in an array.

**Explanation for Example 1:**
The `map` function creates a new array by applying a provided function to each element of the original array. This allows you to transform the array's elements in a concise and functional manner.

**Example 2: Array Filter Function**
1. **Using Filter:** Use the `filter` function to create a new array with elements that pass a test provided by a callback function.
2. **Filtering Even Numbers:** Demonstrate how to use `filter` to extract even numbers from an array.

**Explanation for Example 2:**
The `filter` function creates a new array with elements that meet the criteria defined by the callback function. This allows you to filter out unwanted elements and retain only the ones that match the specified condition.

**Online Resources:**
1. [Array Map Method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
2. [Array Filter Method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter)

**Code and Expected Output:**
```js
// Array Map Function
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);

console.log(doubled); // Expected Output: [2, 4, 6, 8, 10]
```

```js
// Array Filter Function
const numbers = [1, 2, 3, 4, 5];
const evenNumbers = numbers.filter(num => num % 2 === 0);

console.log(evenNumbers); // Expected Output: [2, 4]
```

#### Task 12: JavaScript Prototypes and Inheritance
**Explanation:**
Prototypes are a fundamental feature in JavaScript, providing a mechanism for inheritance. Every JavaScript object has a prototype, which is another object that provides shared properties and methods. When you access a property or method on an object, JavaScript first looks for it on the object itself, and if not found, it searches the object's prototype chain.

Prototypal inheritance allows objects to inherit properties and methods from other objects. This provides a flexible and efficient way to share functionality and create object hierarchies. Understanding prototypes and inheritance is essential for mastering JavaScript's object-oriented programming capabilities.

**Online Resources:**
1. [JavaScript Prototypes - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object_prototypes)
2. [JavaScript Inheritance](https://javascript.info/prototype-inheritance)

**Example 1: Prototype Chain**
1. **Creating a Prototype:** Define a prototype and create an object that inherits from it.
2. **Accessing Properties:** Access properties and methods from the prototype chain.

**Explanation for Example 1:**
Defining a prototype and creating objects that inherit from it demonstrates how prototypal inheritance works. Accessing properties and methods through the prototype chain shows how objects can share functionality.

**Example 2: Constructor Functions and Prototypes**
1. **Using Constructor Functions:** Create a constructor function and define properties and methods on its prototype.
2. **Inheriting Properties:** Create instances using the constructor function and access inherited properties and methods.

**Explanation for Example 2:**
Using constructor functions to create objects and define shared properties and methods on the prototype allows for efficient inheritance. Creating instances and accessing inherited properties demonstrates how objects can inherit functionality from their prototypes.

**Online Resources:**
1. [JavaScript Prototype Inheritance](https://www.w3schools.com/js/js_object_prototypes.asp)
2. [Understanding Prototypes](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Inheritance_and_the_prototype_chain)

**Code and Expected Output:**
```js
// Prototype Chain
const animal = {
    species: 'Animal',
    speak() {
        console.log(`This ${this.species} speaks.`);
    }
};

const dog = Object.create(animal);
dog.species = 'Dog';
dog.speak(); // Expected Output: This Dog speaks.
```

```js
// Constructor Functions and Prototypes
function Person(name, age) {
    this.name = name;
    this.age = age;
}

Person.prototype.greet = function() {
    console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);
};

const alice = new Person('Alice', 30);
alice.greet(); // Expected Output: Hello, my name is Alice and I am 30 years old.
```

#### Task 13: JavaScript Object-Oriented Programming
**Explanation:**
Object-Oriented Programming (OOP) in JavaScript involves organizing code into objects, each containing properties and methods that define their behavior. OOP principles such as encapsulation, inheritance, and polymorphism help create modular, reusable, and maintainable code. JavaScript supports OOP through its prototypal inheritance and ES6 class syntax.

Encapsulation involves bundling data (properties) and functions (methods) that operate on the data into a single unit (object). Inheritance allows objects to inherit properties and methods from other objects, enabling code reuse. Polymorphism allows objects to be treated as instances of their parent class, enabling flexibility in code design.

**Online Resources:**
1. [JavaScript OOP - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Objects/Object-oriented_JS)
2. [JavaScript Object-Oriented Programming](https://javascript.info/class)

**Example 1: Encapsulation**
1. **Creating an Object:** Define an object with properties and methods to encapsulate data and behavior.
2. **Accessing Methods:** Access the object's methods to interact with its data.

**Explanation for Example 1:**
Encapsulation involves defining an object with properties and methods that operate on the data. Accessing the object's methods demonstrates how encapsulation organizes code and provides a clear interface for interacting with the object's data.

**Example 2: Inheritance and Polymorphism**
1. **Subclassing:** Define a subclass that inherits properties and methods from a parent class.
2. **Overriding Methods:** Override a method in the subclass to demonstrate polymorphism.

**Explanation for Example 2:**
Inheritance allows a subclass to inherit properties and methods from a parent class, promoting code reuse. Overriding a method in the subclass and calling the parent class's method demonstrates polymorphism, enabling flexible and dynamic behavior.

**Online Resources:**
1. [Object-Oriented JavaScript](https://www.w3schools.com/js/js_object_oriented.asp)
2. [JavaScript Classes and Objects](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Working_with_Objects)

**Code and Expected Output:**
```js
// Encapsulation
const car = {
    make: 'Toyota',
    model: 'Camry',
    year: 2020,
    getDetails() {
        return `${this.year} ${this.make} ${this.model}`;
    }
};

console.log(car.getDetails()); // Expected Output: 2020 Toyota Camry
```

```js
// Inheritance and Polymorphism
class Animal {
    constructor(name) {
        this.name = name;
    }

    speak() {
        console.log(`${this.name} makes a sound.`);
    }
}

class Dog extends Animal {
    speak() {
        console.log(`${this.name} barks.`);
    }
}

const dog = new Dog('Rex');
dog.speak(); // Expected Output: Rex barks.
```

#### Task 14: JavaScript Array Methods
**Explanation:**
JavaScript provides several built-in methods for working with arrays

, enabling you to perform various operations such as transforming, filtering, and reducing arrays. Common array methods include `map`, `filter`, `reduce`, `forEach`, and `find`. These methods help you write concise, functional, and readable code for array manipulation.

Understanding array methods is essential for working with collections of data in JavaScript. These methods allow you to perform complex operations on arrays with ease, making your code more efficient and expressive.

**Online Resources:**
1. [JavaScript Array Methods - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
2. [JavaScript Array Methods Tutorial](https://www.w3schools.com/js/js_array_methods.asp)

**Example 1: Array Map and Filter**
1. **Using Map:** Use the `map` method to transform an array by applying a function to each element.
2. **Using Filter:** Use the `filter` method to create a new array with elements that pass a test.

**Explanation for Example 1:**
The `map` method creates a new array by applying a provided function to each element, enabling transformation of the array's elements. The `filter` method creates a new array with elements that meet the criteria defined by the callback function, allowing you to filter out unwanted elements.

**Example 2: Array Reduce and Find**
1. **Using Reduce:** Use the `reduce` method to accumulate values from an array into a single result.
2. **Using Find:** Use the `find` method to locate the first element that satisfies a condition.

**Explanation for Example 2:**
The `reduce` method applies a function to each element of the array, accumulating the result into a single value, useful for summing or combining array elements. The `find` method returns the first element that satisfies a specified condition, providing a way to search for elements within an array.

**Online Resources:**
1. [Array Map Method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map)
2. [Array Reduce Method](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce)

**Code and Expected Output:**
```js
// Array Map and Filter
const numbers = [1, 2, 3, 4, 5];
const doubled = numbers.map(num => num * 2);
const evens = numbers.filter(num => num % 2 === 0);

console.log(doubled); // Expected Output: [2, 4, 6, 8, 10]
console.log(evens); // Expected Output: [2, 4]
```

```js
// Array Reduce and Find
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce((total, num) => total + num, 0);
const firstEven = numbers.find(num => num % 2 === 0);

console.log(sum); // Expected Output: 15
console.log(firstEven); // Expected Output: 2
```

#### Task 15: JavaScript Asynchronous Programming
**Explanation:**
Asynchronous programming in JavaScript allows you to perform long-running tasks, such as network requests or file operations, without blocking the main thread. Asynchronous operations are handled using callbacks, Promises, and Async/Await. These techniques enable you to write non-blocking code that improves the performance and responsiveness of your applications.

Understanding asynchronous programming is essential for working with web APIs, handling user interactions, and performing tasks in the background. By mastering asynchronous techniques, you can create efficient and responsive applications that provide a better user experience.

**Online Resources:**
1. [Asynchronous JavaScript - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous)
2. [JavaScript Asynchronous Programming](https://javascript.info/async)

**Example 1: Callbacks**
1. **Using Callbacks:** Define a callback function to handle the result of an asynchronous operation.
2. **Executing Callbacks:** Pass the callback function to an asynchronous function.

**Explanation for Example 1:**
Callbacks are functions passed as arguments to other functions, which are called when the asynchronous operation completes. This allows you to handle the result or error of the operation, providing a way to manage asynchronous tasks.

**Example 2: Promises**
1. **Creating a Promise:** Create a Promise to handle an asynchronous operation.
2. **Chaining Promises:** Use `.then()` and `.catch()` to handle the resolved value or error.

**Explanation for Example 2:**
Promises provide a cleaner way to handle asynchronous operations compared to callbacks. They represent the eventual completion (or failure) of an asynchronous operation, allowing you to chain operations and handle errors more gracefully.

**Online Resources:**
1. [JavaScript Callbacks](https://www.w3schools.com/js/js_callback.asp)
2. [JavaScript Promises](https://javascript.info/promise-basics)

**Code and Expected Output:**
```js
// Using Callbacks
function fetchData(callback) {
    setTimeout(() => {
        const data = 'Data fetched';
        callback(data);
    }, 1000);
}

function handleData(data) {
    console.log(data);
}

fetchData(handleData); // Expected Output: Data fetched (after 1 second)
```

```js
// Creating and Using Promises
const fetchData = new Promise((resolve, reject) => {
    setTimeout(() => {
        const data = 'Data fetched';
        resolve(data);
    }, 1000);
});

fetchData.then(data => {
    console.log(data); // Expected Output: Data fetched (after 1 second)
}).catch(error => {
    console.error(error);
});
```

#### Task 16: JavaScript AJAX and Fetch API
**Explanation:**
AJAX (Asynchronous JavaScript and XML) is a technique for creating dynamic web applications by sending and receiving data asynchronously from a server without reloading the entire page. The `XMLHttpRequest` object is used to make HTTP requests and handle responses. The Fetch API, introduced in ES6, provides a modern, promise-based interface for making HTTP requests.

Understanding AJAX and the Fetch API is essential for building interactive web applications that communicate with servers, fetch data, and update the UI dynamically. These techniques enable you to create seamless and responsive user experiences.

**Online Resources:**
1. [AJAX - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/Guide/AJAX)
2. [Fetch API - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)

**Example 1: Using XMLHttpRequest**
1. **Creating a Request:** Use `XMLHttpRequest` to send an HTTP GET request.
2. **Handling the Response:** Handle the response and update the DOM with the received data.

**Explanation for Example 1:**
The `XMLHttpRequest` object allows you to make HTTP requests and handle responses asynchronously. By sending a GET request to a server and processing the response, you can update the DOM dynamically with the received data.

**Example 2: Using Fetch API**
1. **Making a Fetch Request:** Use the Fetch API to send an HTTP GET request.
2. **Handling the Response:** Handle the response using Promises and update the DOM with the received data.

**Explanation for Example 2:**
The Fetch API provides a modern, promise-based interface for making HTTP requests. By sending a GET request and handling the response with Promises, you can easily fetch data from a server and update the DOM dynamically.

**Online Resources:**
1. [Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)
2. [XMLHttpRequest Tutorial](https://www.w3schools.com/xml/xml_http.asp)

**Code and Expected Output:**
```js
// Using XMLHttpRequest
const xhr = new XMLHttpRequest();
xhr.open('GET', 'https://jsonplaceholder.typicode.com/posts/1', true);
xhr.onload = function() {
    if (xhr.status === 200) {
        const response = JSON.parse(xhr.responseText);
        console.log(response);
    }
};
xhr.send();
// Expected Output: { userId: 1, id: 1, title: '...', body: '...' } (sample response)
```

```js
// Using Fetch API
fetch('https://jsonplaceholder.typicode.com/posts/1')
    .then(response => response.json())
    .then(data => console.log(data))
    .catch(error => console.error('Error:', error));
// Expected Output: { userId: 1, id: 1, title: '...', body: '...' } (sample response)
```

#### Task 17: JavaScript Regular Expressions
**Explanation:**
Regular expressions (regex) are patterns used to match character combinations in strings. In JavaScript, regex is implemented using the `RegExp` object and the `RegExp` literal notation. Regular expressions are powerful tools for searching, replacing, and validating strings, enabling you to perform complex text processing tasks.

Understanding regular expressions is essential for tasks such as form validation, text parsing, and data extraction. Mastering regex allows you to write efficient and concise code for handling various string operations.

**Online Resources:**
1. [JavaScript Regular Expressions - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions)
2. [JavaScript Regex Tutorial](https://www.w3schools.com/js/js_regexp.asp)

**Example 1: Basic Regular Expressions**
1. **Creating a Regex:** Use literal notation to create a regular expression for matching a pattern.
2. **Testing a String:** Use the `test` method to check if the string matches the pattern.

**Explanation for

 Example 1:**
Creating a regular expression using literal notation allows you to define patterns for matching strings. The `test` method checks if a string matches the pattern, returning `true` or `false` based on the result.

**Example 2: Regex with String Methods**
1. **Using exec Method:** Use the `exec` method to search for a match in a string and return details of the match.
2. **Using match Method:** Use the `match` method to find matches in a string and return an array of results.

**Explanation for Example 2:**
The `exec` method searches for a match in a string and returns an array containing the match details. The `match` method finds all matches in a string and returns an array of results, enabling you to extract matching substrings efficiently.

**Online Resources:**
1. [Regex Methods](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp)
2. [Regular Expressions in JavaScript](https://javascript.info/regular-expressions)

**Code and Expected Output:**
```js
// Basic Regular Expressions
const regex = /hello/i;
const str = 'Hello, world!';
const result = regex.test(str);

console.log(result); // Expected Output: true
```

```js
// Regex with String Methods
const regex = /\d+/g;
const str = 'There are 123 apples and 456 oranges.';
const result = str.match(regex);

console.log(result); // Expected Output: ['123', '456']
```

#### Task 18: JavaScript Data Structures
**Explanation:**
JavaScript provides various built-in data structures for storing and manipulating data, including arrays, objects, maps, and sets. Arrays are ordered collections of elements, while objects are collections of key-value pairs. Maps are similar to objects but allow any value as a key, and sets are collections of unique values.

Understanding JavaScript data structures is essential for efficiently organizing and processing data in your applications. Each data structure has its own use cases and performance characteristics, making it important to choose the right one for your needs.

**Online Resources:**
1. [JavaScript Data Structures - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures)
2. [JavaScript Data Structures Tutorial](https://www.w3schools.com/js/js_data_structures.asp)

**Example 1: Arrays and Objects**
1. **Using Arrays:** Create and manipulate arrays using built-in methods.
2. **Using Objects:** Create and manipulate objects with key-value pairs.

**Explanation for Example 1:**
Arrays provide an ordered collection of elements that can be manipulated using methods such as `push`, `pop`, `shift`, `unshift`, `splice`, and `slice`. Objects allow you to store data as key-value pairs, providing a flexible way to represent complex data structures.

**Example 2: Maps and Sets**
1. **Using Maps:** Create a map and perform operations such as setting and getting values.
2. **Using Sets:** Create a set and perform operations such as adding and checking values.

**Explanation for Example 2:**
Maps provide a way to store key-value pairs where keys can be any value, allowing more flexibility than objects. Sets store unique values, providing a way to manage collections of unique elements and perform operations such as union, intersection, and difference.

**Online Resources:**
1. [JavaScript Arrays](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array)
2. [JavaScript Maps and Sets](https://javascript.info/map-set)

**Code and Expected Output:**
```js
// Arrays and Objects
const numbers = [1, 2, 3, 4, 5];
numbers.push(6);
numbers.splice(2, 1);
console.log(numbers); // Expected Output: [1, 2, 4, 5, 6]

const person = { name: 'Alice', age: 30 };
person.location = 'New York';
delete person.age;
console.log(person); // Expected Output: { name: 'Alice', location: 'New York' }
```

```js
// Maps and Sets
const map = new Map();
map.set('name', 'Alice');
map.set('age', 30);
console.log(map.get('name')); // Expected Output: Alice
console.log(map.size); // Expected Output: 2

const set = new Set([1, 2, 3, 4, 5]);
set.add(6);
set.delete(3);
console.log(set.has(3)); // Expected Output: false
console.log(set.size); // Expected Output: 5
```

#### Task 19: JavaScript Event Loop
**Explanation:**
The JavaScript event loop is a mechanism that allows the execution of multiple pieces of code over time, handling asynchronous operations and ensuring non-blocking execution. The event loop continuously checks the call stack and the task queue, executing tasks in the call stack and processing messages in the task queue.

Understanding the event loop is essential for managing asynchronous operations and ensuring smooth performance in JavaScript applications. It explains how JavaScript handles tasks such as event handling, timers, and promises, allowing you to write more efficient and responsive code.

**Online Resources:**
1. [JavaScript Event Loop - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
2. [Understanding the Event Loop](https://javascript.info/event-loop)

**Example 1: Event Loop with setTimeout**
1. **Using setTimeout:** Demonstrate how `setTimeout` interacts with the event loop.
2. **Call Stack and Task Queue:** Explain the interaction between the call stack and the task queue.

**Explanation for Example 1:**
`setTimeout` schedules a task to be added to the task queue after a specified delay. The event loop ensures that the task is executed only when the call stack is empty, demonstrating how asynchronous operations are managed in JavaScript.

**Example 2: Event Loop with Promises**
1. **Using Promises:** Demonstrate how promises interact with the event loop.
2. **Microtask Queue:** Explain the microtask queue and its priority over the task queue.

**Explanation for Example 2:**
Promises are added to the microtask queue, which has a higher priority than the task queue. This means that promise callbacks are executed before tasks in the task queue, demonstrating the event loop's prioritization of microtasks.

**Online Resources:**
1. [Event Loop Explained](https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop)
2. [JavaScript Concurrency Model](https://javascript.info/event-loop)

**Code and Expected Output:**
```js
// Event Loop with setTimeout
console.log('Start');

setTimeout(() => {
    console.log('Timeout');
}, 0);

console.log('End');

// Expected Output:
// Start
// End
// Timeout
```

```js
// Event Loop with Promises
console.log('Start');

Promise.resolve().then(() => {
    console.log('Promise');
});

console.log('End');

// Expected Output:
// Start
// End
// Promise
```

#### Task 20: JavaScript Best Practices
**Explanation:**
JavaScript best practices involve writing clean, maintainable, and efficient code that follows established conventions and standards. Key best practices include using meaningful variable and function names, avoiding global variables, following consistent code style, using comments and documentation, and handling errors gracefully.

Adopting best practices helps improve code readability, maintainability, and performance. It also facilitates collaboration with other developers and ensures that your codebase remains robust and scalable.

**Online Resources:**
1. [JavaScript Best Practices - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Best_practices)
2. [JavaScript Best Practices Tutorial](https://www.w3schools.com/js/js_best_practices.asp)

**Example 1: Code Style and Naming Conventions**
1. **Consistent Code Style:** Follow a consistent code style for indentation, spacing, and brackets.
2. **Meaningful Names:** Use meaningful variable and function names that describe their purpose.

**Explanation for Example 1:**
Following a consistent code style improves readability and maintainability. Using meaningful names for variables and functions helps convey their purpose, making the code easier to understand and maintain.

**Example 2: Avoiding Globals and Handling Errors**
1. **Avoiding Global Variables:** Minimize the use of global variables to prevent conflicts and unintended side effects.
2. **Error Handling:** Implement proper error handling to manage exceptions and provide meaningful feedback.

**Explanation for Example 2:**
Avoiding global variables reduces the risk of conflicts and unintended side effects, promoting modular and encapsulated code. Proper error handling ensures that your application can recover gracefully from errors and provide meaningful feedback to the user.

**Online Resources:**
1. [JavaScript Coding Standards](https://www.w3schools.com/js/js_conventions.asp)
2. [JavaScript Error Handling Best Practices](https://www.toptal.com/javascript/10-most-common-javascript-mistakes)

**Code and Expected Output:**
```js
// Code Style and Naming Conventions
function calculateArea(radius) {
    const pi = 3.14159;
    return pi * radius * radius;
}

const area = calculateArea(5);
console.log(`The area is ${area}`); // Expected Output: The area is 78.53975
```

```js
// Avoiding Globals and Handling Errors
function fetchData(url) {
    return fetch(url)
        .then(response => {
            if (!response.ok) {
                throw new Error('Network response was not ok');
            }
            return response.json();
        })
        .catch(error => {
            console.error('Fetch error:', error);


        });
}

fetchData('https://jsonplaceholder.typicode.com/posts/1')
    .then(data => {
        if (data) {
            console.log(data);
        }
    });
// Expected Output: { userId: 1, id: 1, title: '...', body: '...' } (sample response)
```

By completing these 20 tasks, you will gain a deeper understanding of advanced JavaScript concepts and techniques, enabling you to write more efficient, maintainable, and robust code. Each task builds on the previous ones, gradually enhancing your skills and knowledge.
