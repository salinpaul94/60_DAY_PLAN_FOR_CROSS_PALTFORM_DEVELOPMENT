### Day 5 Study Plan: Advanced React Topics

#### Task 1: Context API Advanced Usage
**Explanation:**
The React Context API provides a way to share data between components without passing props down manually at every level. Advanced usage involves understanding context nesting, default values, and optimizing performance when using context. Nesting contexts can help you manage multiple pieces of state independently, while default values ensure that components have sensible fallbacks when no context is provided.

Optimizing performance with the Context API involves avoiding unnecessary re-renders. This can be achieved by memoizing context values and splitting context to isolate state updates. Properly managing the Context API can lead to more efficient and maintainable applications.

**Online Resources:**
1. [React Context API](https://reactjs.org/docs/context.html)
2. [Advanced React Context Patterns](https://kentcdodds.com/blog/how-to-use-react-context-effectively)

**Example 1: Nesting Contexts**
1. **Define Multiple Contexts:** Create and nest multiple contexts to manage different pieces of state.
2. **Consume Nested Contexts:** Access values from nested contexts in child components.

**Explanation for Example 1:**
Nesting contexts allows you to manage multiple pieces of state independently, enabling more complex state management patterns. By consuming nested contexts, components can access and use multiple pieces of context data efficiently.

**Example 2: Optimizing Context Performance**
1. **Memoizing Context Values:** Memoize context values to avoid unnecessary re-renders.
2. **Splitting Context:** Split context to isolate state updates and improve performance.

**Explanation for Example 2:**
Memoizing context values ensures that components only re-render when context values change, improving performance. Splitting context allows you to isolate state updates, preventing unrelated parts of the component tree from re-rendering.

**Online Resources:**
1. [Using Context API Effectively](https://kentcdodds.com/blog/how-to-use-react-context-effectively)
2. [Optimizing Performance with Context](https://medium.com/@levunguyen/react-advanced-pattern-context-performance-optimization-fd46f1d6c416)

**Code and Expected Output:**
```jsx
// Nesting Contexts
import React, { createContext, useContext } from 'react';
import ReactDOM from 'react-dom';

const UserContext = createContext();
const ThemeContext = createContext();

function App() {
    return (
        <UserContext.Provider value={{ name: 'Alice' }}>
            <ThemeContext.Provider value={{ color: 'blue' }}>
                <NestedComponent />
            </ThemeContext.Provider>
        </UserContext.Provider>
    );
}

function NestedComponent() {
    const user = useContext(UserContext);
    const theme = useContext(ThemeContext);
    return (
        <div>
            <p>User: {user.name}</p>
            <p>Theme color: {theme.color}</p>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: User: Alice and Theme color: blue displayed on the page.
```

```jsx
// Optimizing Context Performance
import React, { createContext, useContext, useState, useMemo } from 'react';
import ReactDOM from 'react-dom';

const CountContext = createContext();

function App() {
    const [count, setCount] = useState(0);

    const value = useMemo(() => ({ count, increment: () => setCount(c => c + 1) }), [count]);

    return (
        <CountContext.Provider value={value}>
            <Counter />
        </CountContext.Provider>
    );
}

function Counter() {
    const { count, increment } = useContext(CountContext);
    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={increment}>Increment</button>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: Count value incrementing by 1 each time the button is clicked, with optimized performance.
```

#### Task 2: React Hooks Advanced Usage
**Explanation:**
Advanced usage of React Hooks involves understanding custom hooks, optimizing hooks for performance, and managing complex state. Custom hooks allow you to extract and reuse logic across multiple components, promoting code reuse and reducing duplication. Hooks such as `useReducer` and `useMemo` can help manage more complex state and performance optimizations.

Managing complex state with `useReducer` provides a predictable way to handle state transitions, especially in complex applications. Using `useMemo` and `useCallback` can optimize performance by memoizing expensive calculations and functions, ensuring they are only recomputed when necessary.

**Online Resources:**
1. [React Hooks API](https://reactjs.org/docs/hooks-reference.html)
2. [Custom Hooks in React](https://reactjs.org/docs/hooks-custom.html)

**Example 1: Creating Custom Hooks**
1. **Define a Custom Hook:** Create a custom hook to encapsulate reusable logic.
2. **Using the Custom Hook:** Use the custom hook in a component to manage state or side effects.

**Explanation for Example 1:**
Custom hooks allow you to encapsulate reusable logic, making your code more modular and easier to maintain. Using custom hooks in components enables you to manage state and side effects consistently across different parts of your application.

**Example 2: Using useReducer for Complex State**
1. **Define a Reducer:** Define a reducer function to handle state transitions.
2. **Using useReducer Hook:** Use the `useReducer` hook to manage complex state in a component.

**Explanation for Example 2:**
The `useReducer` hook provides a predictable way to manage complex state transitions based on actions. Defining a reducer function allows you to handle state updates in a centralized and organized manner, making it easier to maintain and debug.

**Online Resources:**
1. [React useReducer Hook](https://reactjs.org/docs/hooks-reference.html#usereducer)
2. [Creating Custom Hooks](https://www.tutorialspoint.com/reactjs/reactjs_hooks.htm)

**Code and Expected Output:**
```jsx
// Creating Custom Hooks
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

function useFetch(url) {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);

    useEffect(() => {
        fetch(url)
            .then(response => response.json())
            .then(data => {
                setData(data);
                setLoading(false);
            });
    }, [url]);

    return { data, loading };
}

function DataDisplay({ url }) {
    const { data, loading } = useFetch(url);

    if (loading) {
        return <p>Loading...</p>;
    }

    return <pre>{JSON.stringify(data, null, 2)}</pre>;
}

ReactDOM.render(<DataDisplay url="https://jsonplaceholder.typicode.com/posts/1" />, document.getElementById('root'));
// Expected Output: JSON data fetched from the provided URL displayed in a preformatted text block.
```

```jsx
// Using useReducer for Complex State
import React, { useReducer } from 'react';
import ReactDOM from 'react-dom';

const initialState = { count: 0 };

function reducer(state, action) {
    switch (action.type) {
        case 'increment':
            return { count: state.count + 1 };
        case 'decrement':
            return { count: state.count - 1 };
        default:
            throw new Error();
    }
}

function Counter() {
    const [state, dispatch] = useReducer(reducer, initialState);

    return (
        <div>
            <p>Count: {state.count}</p>
            <button onClick={() => dispatch({ type: 'increment' })}>Increment</button>
            <button onClick={() => dispatch({ type: 'decrement' })}>Decrement</button>
        </div>
    );
}

ReactDOM.render(<Counter />, document.getElementById('root'));
// Expected Output: A counter that increments or decrements the count based on button clicks.
```

#### Task 3: React Suspense for Data Fetching
**Explanation:**
React Suspense is a feature that allows you to handle asynchronous operations like data fetching in a declarative way. It enables you to show a fallback UI while waiting for data to load, making it easier to manage loading states and improve user experience. Suspense works with concurrent mode to provide smoother transitions and responsiveness.

Using Suspense for data fetching involves wrapping components with `React.Suspense` and using a library like `react-fetch` or `relay` to handle asynchronous operations. This approach simplifies data management and ensures that the UI remains responsive and user-friendly during loading periods.

**Online Resources:**
1. [React Suspense](https://reactjs.org/docs/concurrent-mode-suspense.html)
2. [Using Suspense for Data Fetching](https://blog.logrocket.com/react-suspense-for-data-fetching/)

**Example 1: Basic Suspense Usage**
1. **Defining a Suspense Component:** Wrap a component with `React.Suspense` and provide a fallback UI.
2. **Simulating Data Fetching:** Use a simulated data fetching function to demonstrate Suspense.

**Explanation for Example 1:**
Wrapping a component with `React.Suspense` allows you to show a fallback UI while waiting for data to load. Using a simulated data fetching function demonstrates how Suspense handles asynchronous operations and manages loading states.

**Example 2: Using Suspense with Concurrent Mode**
1. **Enabling Concurrent Mode:** Enable concurrent mode to use Suspense effectively.
2. **Fetching Data with Suspense:** Fetch data using Suspense and display the results in a component.

**

Explanation for Example 2:**
Enabling concurrent mode allows you to use Suspense effectively, providing smoother transitions and improved responsiveness. Fetching data with Suspense ensures that the UI remains user-friendly and responsive during loading periods.

**Online Resources:**
1. [React Concurrent Mode](https://reactjs.org/docs/concurrent-mode-intro.html)
2. [Suspense for Data Fetching Examples](https://codesandbox.io/s/github/reactjs/react-suspense/tree/main/examples/fetching)

**Code and Expected Output:**
```jsx
// Basic Suspense Usage
import React, { Suspense } from 'react';
import ReactDOM from 'react-dom';

function fetchData() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve('Data fetched!');
        }, 2000);
    });
}

const DataComponent = React.lazy(() => fetchData().then(data => ({ default: () => <div>{data}</div> })));

function App() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <DataComponent />
        </Suspense>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: "Loading..." displayed initially, followed by "Data fetched!" after 2 seconds.
```

```jsx
// Using Suspense with Concurrent Mode
import React, { Suspense } from 'react';
import ReactDOM from 'react-dom';
import { unstable_createRoot as createRoot } from 'react-dom';

function fetchData() {
    return new Promise(resolve => {
        setTimeout(() => {
            resolve('Data fetched!');
        }, 2000);
    });
}

const DataComponent = React.lazy(() => fetchData().then(data => ({ default: () => <div>{data}</div> })));

function App() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <DataComponent />
        </Suspense>
    );
}

createRoot(document.getElementById('root')).render(<App />);
// Expected Output: "Loading..." displayed initially, followed by "Data fetched!" after 2 seconds.
```

#### Task 4: React Performance Optimization Techniques
**Explanation:**
React performance optimization techniques involve strategies and tools to improve the efficiency and speed of your application. Common techniques include memoization, code splitting, lazy loading, and optimizing rendering. Tools like `React.memo`, `useMemo`, `useCallback`, and the React Developer Tools can help identify and address performance issues.

Memoization with `React.memo`, `useMemo`, and `useCallback` helps avoid unnecessary re-renders by caching results and functions. Code splitting and lazy loading reduce the initial bundle size, improving load times. Properly managing state and avoiding performance bottlenecks ensures a smooth and responsive user experience.

**Online Resources:**
1. [Optimizing Performance - React](https://reactjs.org/docs/optimizing-performance.html)
2. [React Performance Optimization](https://www.w3schools.com/react/react_performance.asp)

**Example 1: Memoization with useMemo**
1. **Using useMemo:** Use `useMemo` to memoize expensive calculations and avoid unnecessary recomputations.
2. **Improving Performance:** Improve performance by ensuring that expensive calculations are only recomputed when necessary.

**Explanation for Example 1:**
Using `useMemo` allows you to memoize expensive calculations, ensuring they are only recomputed when their dependencies change. This optimization helps improve performance by reducing unnecessary recomputations.

**Example 2: Optimizing Rendering with React.memo**
1. **Using React.memo:** Use `React.memo` to memoize functional components and prevent unnecessary re-renders.
2. **Enhancing Performance:** Enhance performance by ensuring that components only re-render when their props change.

**Explanation for Example 2:**
Using `React.memo` allows you to memoize functional components, ensuring they only re-render when their props change. This optimization helps improve performance by reducing unnecessary re-renders and improving efficiency.

**Online Resources:**
1. [React.memo Documentation](https://reactjs.org/docs/react-api.html#reactmemo)
2. [Using useMemo and useCallback](https://reactjs.org/docs/hooks-reference.html#usememo)

**Code and Expected Output:**
```jsx
// Memoization with useMemo
import React, { useState, useMemo } from 'react';
import ReactDOM from 'react-dom';

function ExpensiveComponent({ num }) {
    const computeExpensiveValue = (num) => {
        console.log('Computing expensive value...');
        return num * 2;
    };

    const memoizedValue = useMemo(() => computeExpensiveValue(num), [num]);

    return <p>Expensive value: {memoizedValue}</p>;
}

function App() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <ExpensiveComponent num={count} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: "Computing expensive value..." logged initially and when the count changes, showing memoized value.
```

```jsx
// Optimizing Rendering with React.memo
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

const Button = React.memo(({ onClick, children }) => {
    console.log('Button rendered');
    return <button onClick={onClick}>{children}</button>;
});

function App() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <Button onClick={() => setCount(count + 1)}>Increment</Button>
            <p>Count: {count}</p>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: "Button rendered" logged only once initially, showing memoized rendering.
```

#### Task 5: React and TypeScript Integration
**Explanation:**
Integrating TypeScript with React provides static typing, which helps catch errors at compile time and improves code quality. TypeScript adds type annotations and interfaces, allowing you to define the shape of props, state, and other variables in your React components. This integration enhances the development experience by providing better tooling, autocomplete, and documentation.

Using TypeScript with React involves setting up a TypeScript project, defining interfaces for props and state, and using TypeScript features like generics and enums. Properly typing your React components ensures that your code is more robust, maintainable, and easier to understand.

**Online Resources:**
1. [React TypeScript Cheatsheets](https://react-typescript-cheatsheet.netlify.app/)
2. [Using TypeScript with React](https://www.typescriptlang.org/docs/handbook/react.html)

**Example 1: Setting Up TypeScript in React**
1. **Initialize a TypeScript Project:** Create a new React project with TypeScript support using Create React App.
2. **Defining TypeScript Interfaces:** Define interfaces for component props and state.

**Explanation for Example 1:**
Initializing a TypeScript project with Create React App sets up the necessary configuration for using TypeScript with React. Defining interfaces for component props and state ensures that your components have well-defined types, improving code quality.

**Example 2: Using TypeScript Features in React**
1. **Type Annotations and Generics:** Use type annotations and generics to define component props and state.
2. **Type Safety in Event Handlers:** Ensure type safety in event handlers and other component methods.

**Explanation for Example 2:**
Using type annotations and generics allows you to define the types of props and state in your React components. Ensuring type safety in event handlers and other component methods helps prevent runtime errors and improves code reliability.

**Online Resources:**
1. [TypeScript React Documentation](https://react-typescript-cheatsheet.netlify.app/docs/basic/setup)
2. [TypeScript in Create React App](https://create-react-app.dev/docs/adding-typescript/)

**Code and Expected Output:**
```sh
// Initialize a TypeScript Project
npx create-react-app my-app --template typescript
```

```tsx
// Defining TypeScript Interfaces
import React from 'react';

interface Props {
    name: string;
    age: number;
}

const User: React.FC<Props> = ({ name, age }) => {
    return (
        <div>
            <p>Name: {name}</p>
            <p>Age: {age}</p>
        </div>
    );
};

const App: React.FC = () => {
    return <User name="Alice" age={30} />;
};

export default App;

// Expected Output: A component displaying the user's name and age with type safety.
```

```tsx
// Using TypeScript Features in React
import React, { useState } from 'react';

interface Props {
    initialCount: number;
}

const Counter: React.FC<Props> = ({ initialCount }) => {
    const [count, setCount] = useState<number>(initialCount);

    const handleIncrement = (): void => {
        setCount(count + 1);
    };

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={handleIncrement}>Increment</button>
        </div>
    );
};

const App: React.FC = () => {
    return <Counter initialCount={0} />;
};

export default App;

// Expected Output: A counter component with type safety for state and event handlers.
```

#### Task 6: Server-Side Rendering (SSR) with React
**Explanation:**
Server-Side Rendering (SSR) in React involves rendering components on the server and sending the HTML to the client. This improves the initial

 load time and search engine optimization (SEO) by providing a fully rendered page to the browser. SSR can be implemented using frameworks like Next.js, which simplifies the process and provides built-in support for SSR.

SSR involves setting up a server to render React components and handle routing. It requires handling data fetching on the server and managing the hydration process, where the client takes over and makes the page interactive. Properly implementing SSR can significantly enhance the performance and SEO of your React applications.

**Online Resources:**
1. [Next.js Documentation](https://nextjs.org/docs)
2. [React SSR Guide](https://www.tutorialspoint.com/reactjs/reactjs_server_side_rendering.htm)

**Example 1: Setting Up Next.js for SSR**
1. **Initialize a Next.js Project:** Create a new Next.js project with built-in SSR support.
2. **Creating Pages:** Create pages using Next.js, which automatically handles SSR.

**Explanation for Example 1:**
Initializing a Next.js project sets up the necessary configuration for SSR in React. Creating pages with Next.js involves using the `pages` directory, where each file corresponds to a route, and Next.js handles the SSR automatically.

**Example 2: Data Fetching with getServerSideProps**
1. **Using getServerSideProps:** Use the `getServerSideProps` function to fetch data on the server.
2. **Rendering with SSR:** Render the page with the fetched data, improving performance and SEO.

**Explanation for Example 2:**
The `getServerSideProps` function allows you to fetch data on the server before rendering the page. This ensures that the page is rendered with the necessary data, improving performance and SEO by providing a fully rendered page to the client.

**Online Resources:**
1. [Next.js getServerSideProps](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [React SSR with Next.js](https://nextjs.org/learn/basics/server-side-rendering)

**Code and Expected Output:**
```sh
// Initialize a Next.js Project
npx create-next-app my-next-app
cd my-next-app
npm run dev
```

```jsx
// Creating Pages with Next.js
// pages/index.js
import React from 'react';

const Home = () => {
    return (
        <div>
            <h1>Welcome to Next.js!</h1>
        </div>
    );
};

export default Home;

// Expected Output: A Next.js page with SSR support displaying a welcome message.
```

```jsx
// Data Fetching with getServerSideProps
// pages/index.js
import React from 'react';

export async function getServerSideProps() {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const post = await res.json();
    return { props: { post } };
}

const Home = ({ post }) => {
    return (
        <div>
            <h1>{post.title}</h1>
            <p>{post.body}</p>
        </div>
    );
};

export default Home;

// Expected Output: A Next.js page rendered with data fetched from an API.
```

#### Task 7: Static Site Generation (SSG) with React
**Explanation:**
Static Site Generation (SSG) involves pre-rendering pages at build time, resulting in static HTML files that can be served quickly. SSG is suitable for content that does not change frequently, providing excellent performance and scalability. Next.js supports SSG through the `getStaticProps` and `getStaticPaths` functions, enabling you to generate static pages with dynamic content.

SSG combines the benefits of static sites and dynamic content by generating static pages that include dynamic data fetched at build time. This approach improves load times and reduces the need for server-side processing, making it ideal for blogs, documentation sites, and other content-driven applications.

**Online Resources:**
1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [React Static Site Generation](https://www.smashingmagazine.com/2020/02/introduction-react-static-site-generators/)

**Example 1: Using getStaticProps**
1. **Defining Static Props:** Use the `getStaticProps` function to fetch data at build time.
2. **Generating Static Pages:** Generate static pages with the fetched data, improving performance.

**Explanation for Example 1:**
The `getStaticProps` function allows you to fetch data at build time and pass it as props to the page component. This enables you to generate static pages with dynamic content, improving performance and scalability.

**Example 2: Generating Dynamic Routes with getStaticPaths**
1. **Defining Dynamic Routes:** Use the `getStaticPaths` function to generate dynamic routes.
2. **Fetching Data for Dynamic Routes:** Fetch data for each dynamic route and generate static pages.

**Explanation for Example 2:**
The `getStaticPaths` function allows you to define dynamic routes and fetch data for each route at build time. This enables you to generate static pages for each dynamic route, ensuring fast load times and improved performance.

**Online Resources:**
1. [Next.js getStaticProps](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js getStaticPaths](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)

**Code and Expected Output:**
```jsx
// Using getStaticProps
// pages/index.js
import React from 'react';

export async function getStaticProps() {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    const post = await res.json();
    return { props: { post } };
}

const Home = ({ post }) => {
    return (
        <div>
            <h1>{post.title}</h1>
            <p>{post.body}</p>
        </div>
    );
};

export default Home;

// Expected Output: A static page generated with data fetched from an API.
```

```jsx
// Generating Dynamic Routes with getStaticPaths
// pages/posts/[id].js
import React from 'react';

export async function getStaticPaths() {
    const res = await fetch('https://jsonplaceholder.typicode.com/posts');
    const posts = await res.json();

    const paths = posts.map(post => ({
        params: { id: post.id.toString() }
    }));

    return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
    const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
    const post = await res.json();
    return { props: { post } };
}

const Post = ({ post }) => {
    return (
        <div>
            <h1>{post.title}</h1>
            <p>{post.body}</p>
        </div>
    );
};

export default Post;

// Expected Output: Static pages generated for each post, improving performance and scalability.
```

#### Task 8: Code Splitting and Lazy Loading with React
**Explanation:**
Code splitting and lazy loading are techniques used to improve the performance of React applications by loading only the necessary code when needed. Code splitting involves breaking the application into smaller bundles that can be loaded on demand. Lazy loading allows you to load components and modules only when they are required, reducing the initial load time and improving the overall performance.

React supports code splitting and lazy loading through dynamic `import()` and the `React.lazy` function. Using these techniques ensures that your application loads faster and uses resources more efficiently, providing a better user experience.

**Online Resources:**
1. [Code-Splitting - React](https://reactjs.org/docs/code-splitting.html)
2. [React Lazy Loading](https://www.tutorialspoint.com/reactjs/reactjs_lazy_loading.htm)

**Example 1: Using React.lazy for Lazy Loading**
1. **Defining a Lazy Loaded Component:** Use `React.lazy` to define a component that will be lazy loaded.
2. **Using Suspense for Loading State:** Wrap the lazy loaded component with `React.Suspense` to handle the loading state.

**Explanation for Example 1:**
Using `React.lazy` allows you to define components that will be lazy loaded, reducing the initial load time of your application. Wrapping the lazy loaded component with `React.Suspense` ensures that a fallback UI is displayed while the component is being loaded.

**Example 2: Code Splitting with Dynamic Import**
1. **Using Dynamic Import:** Use dynamic `import()` to load modules on demand.
2. **Handling Loading State:** Handle the loading state while the module is being loaded to provide a smooth user experience.

**Explanation for Example 2:**
Dynamic `import()` allows you to load modules on demand, creating smaller bundles that can be loaded only when needed. Handling the loading state ensures that the user experience remains smooth and responsive while the module is being loaded.

**Online Resources:**
1. [React.lazy Documentation](https://reactjs.org/docs/code-splitting.html#reactlazy)
2. [Dynamic Import in React](https://www.digitalocean.com/community/tutorials/react-code-splitting)

**Code and Expected Output:**
```jsx
// Using React.lazy for Lazy Loading
import React, { Suspense } from 'react';
import ReactDOM from 'react-dom';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
    return (
        <Suspense fallback={<div>Loading...</div>}>
            <LazyComponent />
        </Suspense>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: "Loading..." displayed initially, followed by the content of LazyComponent once loaded.
```

```jsx
// Code

 Splitting with Dynamic Import
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function App() {
    const [Component, setComponent] = useState(null);

    const loadComponent = () => {
        import('./DynamicComponent')
            .then(module => setComponent(() => module.default))
            .catch(error => console.error('Error loading component:', error));
    };

    return (
        <div>
            <button onClick={loadComponent}>Load Component</button>
            {Component && <Component />}
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button that dynamically loads and renders the DynamicComponent.
```

#### Task 9: React Portals Advanced Usage
**Explanation:**
React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This is useful for cases where you need to render elements outside the regular DOM structure, such as modals, tooltips, or dropdowns. Advanced usage of portals involves managing focus, handling events, and ensuring accessibility.

Using portals ensures that UI elements are rendered correctly and positioned as needed, even when they need to break out of the regular DOM hierarchy. Properly managing focus and events in portals is crucial for creating accessible and user-friendly components.

**Online Resources:**
1. [Portals - React](https://reactjs.org/docs/portals.html)
2. [Advanced React Portals](https://blog.bitsrc.io/advanced-react-portals-419ea30c93d8)

**Example 1: Creating a Modal with Portals**
1. **Defining a Modal Component:** Create a modal component that uses a portal to render its content.
2. **Managing Focus and Accessibility:** Ensure that the modal component manages focus and is accessible to all users.

**Explanation for Example 1:**
Creating a modal component using portals allows you to render the modal content outside the regular DOM hierarchy, ensuring correct positioning and behavior. Managing focus and accessibility ensures that the modal is user-friendly and accessible to all users.

**Example 2: Handling Events in Portals**
1. **Handling Click Events:** Ensure that click events are handled correctly within the portal.
2. **Closing the Modal on Outside Click:** Implement functionality to close the modal when clicking outside its content.

**Explanation for Example 2:**
Handling click events correctly within the portal ensures that the UI behaves as expected. Implementing functionality to close the modal when clicking outside its content improves the user experience by providing intuitive and responsive interactions.

**Online Resources:**
1. [React Portals Documentation](https://reactjs.org/docs/portals.html)
2. [Handling Events in Portals](https://medium.com/@frankcarvalho/handling-events-in-react-portals-35464cf2b93d)

**Code and Expected Output:**
```jsx
// Creating a Modal with Portals
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function Modal({ isOpen, onClose }) {
    if (!isOpen) return null;

    return ReactDOM.createPortal(
        <div className="modal">
            <div className="modal-content" tabIndex="-1" role="dialog" aria-modal="true">
                <h2>Modal Title</h2>
                <p>This is a modal.</p>
                <button onClick={onClose}>Close</button>
            </div>
        </div>,
        document.getElementById('modal-root')
    );
}

function App() {
    const [isModalOpen, setModalOpen] = useState(false);

    const openModal = () => setModalOpen(true);
    const closeModal = () => setModalOpen(false);

    return (
        <div>
            <h1>React Portals Example</h1>
            <button onClick={openModal}>Open Modal</button>
            <Modal isOpen={isModalOpen} onClose={closeModal} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button that opens a modal rendered using a portal, with focus and accessibility management.
```

```jsx
// Handling Events in Portals
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function Modal({ isOpen, onClose }) {
    if (!isOpen) return null;

    const handleOutsideClick = (event) => {
        if (event.target.className === 'modal') {
            onClose();
        }
    };

    return ReactDOM.createPortal(
        <div className="modal" onClick={handleOutsideClick}>
            <div className="modal-content">
                <h2>Modal Title</h2>
                <p>This is a modal.</p>
                <button onClick={onClose}>Close</button>
            </div>
        </div>,
        document.getElementById('modal-root')
    );
}

function App() {
    const [isModalOpen, setModalOpen] = useState(false);

    const openModal = () => setModalOpen(true);
    const closeModal = () => setModalOpen(false);

    return (
        <div>
            <h1>React Portals Example</h1>
            <button onClick={openModal}>Open Modal</button>
            <Modal isOpen={isModalOpen} onClose={closeModal} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button that opens a modal rendered using a portal, with functionality to close the modal on outside click.
```

#### Task 10: State Management with Redux
**Explanation:**
Redux is a predictable state container for JavaScript applications, commonly used with React for managing complex state. Redux follows a unidirectional data flow and relies on three core principles: a single source of truth, state is read-only, and changes are made with pure functions called reducers. This approach ensures that the state is predictable, easy to debug, and scalable.

Using Redux involves setting up a store to hold the application state, defining actions to describe state changes, and creating reducers to handle these actions. Connecting Redux to React components enables you to access and update the state in a predictable manner, improving the maintainability and scalability of your application.

**Online Resources:**
1. [Redux Official Documentation](https://redux.js.org/)
2. [Using Redux with React](https://react-redux.js.org/introduction/getting-started)

**Example 1: Setting Up Redux**
1. **Creating a Redux Store:** Set up a Redux store to hold the application state.
2. **Defining Actions and Reducers:** Define actions and reducers to manage state changes.

**Explanation for Example 1:**
Creating a Redux store involves setting up a central location to hold the application state. Defining actions and reducers provides a structured way to describe state changes and handle them predictably.

**Example 2: Connecting Redux to React**
1. **Using React-Redux:** Use the `react-redux` library to connect Redux to React components.
2. **Accessing and Updating State:** Access and update the state from React components using Redux.

**Explanation for Example 2:**
Using the `react-redux` library allows you to connect Redux to React components, providing access to the application state and dispatching actions to update it. This integration ensures that state management is consistent and predictable across the application.

**Online Resources:**
1. [Redux Basics](https://redux.js.org/basics/basic-tutorial)
2. [React-Redux Documentation](https://react-redux.js.org/)

**Code and Expected Output:**
```sh
// Installing Redux and React-Redux
npm install redux react-redux
```

```jsx
// Setting Up Redux
// store.js
import { createStore } from 'redux';

// Define initial state
const initialState = { count: 0 };

// Define actions
const INCREMENT = 'INCREMENT';
const DECREMENT = 'DECREMENT';

// Define action creators
export const increment = () => ({ type: INCREMENT });
export const decrement = () => ({ type: DECREMENT });

// Define reducer
const reducer = (state = initialState, action) => {
    switch (action.type) {
        case INCREMENT:
            return { count: state.count + 1 };
        case DECREMENT:
            return { count: state.count - 1 };
        default:
            return state;
    }
};

// Create store
const store = createStore(reducer);
export default store;
```

```jsx
// Connecting Redux to React
// App.js
import React from 'react';
import { Provider, useSelector, useDispatch } from 'react-redux';
import store, { increment, decrement } from './store';

function Counter() {
    const count = useSelector(state => state.count);
    const dispatch = useDispatch();

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => dispatch(increment())}>Increment</button>
            <button onClick={() => dispatch(decrement())}>Decrement</button>
        </div>
    );
}

function App() {
    return (
        <Provider store={store}>
            <Counter />
        </Provider>
    );
}

export default App;

// Expected Output: A counter component connected to Redux, allowing you to increment and decrement the count.
```

#### Task 11: State Management with Recoil
**Explanation:**
Recoil is a state management library for React that provides a simple and efficient way to manage shared state. Recoil allows you to create atoms, which are units of state, and selectors, which are derived state based on atoms. This approach enables you to manage global state in a way that is easy to understand and use, while

 maintaining the performance and scalability of your application.

Recoil provides a reactive state management system that works seamlessly with React's concurrent mode. It allows you to define relationships between pieces of state, automatically updating dependent state when the source state changes. This ensures that your application remains responsive and consistent.

**Online Resources:**
1. [Recoil Official Documentation](https://recoiljs.org/)
2. [Recoil State Management](https://www.tutorialspoint.com/reactjs/reactjs_recoil.htm)

**Example 1: Setting Up Recoil**
1. **Creating Atoms:** Create atoms to manage individual pieces of state.
2. **Using RecoilRoot:** Wrap your application with `RecoilRoot` to provide the Recoil state context.

**Explanation for Example 1:**
Creating atoms allows you to manage individual pieces of state in a modular and reusable way. Wrapping your application with `RecoilRoot` provides the Recoil state context, enabling you to use atoms and selectors throughout your application.

**Example 2: Using Selectors for Derived State**
1. **Creating Selectors:** Create selectors to derive state based on atoms.
2. **Using Selectors in Components:** Use selectors in components to access derived state.

**Explanation for Example 2:**
Creating selectors allows you to derive state based on atoms, enabling you to compute state values dynamically. Using selectors in components provides access to derived state, ensuring that your components are always up-to-date with the latest state.

**Online Resources:**
1. [Recoil Atoms and Selectors](https://recoiljs.org/docs/basic-tutorial/atoms/selectors)
2. [Using Recoil with React](https://blog.bitsrc.io/using-recoil-with-react-2b5f1f8bf23d)

**Code and Expected Output:**
```sh
// Installing Recoil
npm install recoil
```

```jsx
// Setting Up Recoil
// atoms.js
import { atom } from 'recoil';

// Create an atom
export const countState = atom({
    key: 'countState',
    default: 0,
});
```

```jsx
// App.js
import React from 'react';
import { RecoilRoot, useRecoilState } from 'recoil';
import { countState } from './atoms';

function Counter() {
    const [count, setCount] = useRecoilState(countState);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <button onClick={() => setCount(count - 1)}>Decrement</button>
        </div>
    );
}

function App() {
    return (
        <RecoilRoot>
            <Counter />
        </RecoilRoot>
    );
}

export default App;

// Expected Output: A counter component managed by Recoil, allowing you to increment and decrement the count.
```

```jsx
// Using Selectors for Derived State
// selectors.js
import { selector } from 'recoil';
import { countState } from './atoms';

// Create a selector
export const doubledCountState = selector({
    key: 'doubledCountState',
    get: ({ get }) => {
        const count = get(countState);
        return count * 2;
    },
});
```

```jsx
// App.js
import React from 'react';
import { RecoilRoot, useRecoilValue, useRecoilState } from 'recoil';
import { countState } from './atoms';
import { doubledCountState } from './selectors';

function Counter() {
    const [count, setCount] = useRecoilState(countState);
    const doubledCount = useRecoilValue(doubledCountState);

    return (
        <div>
            <p>Count: {count}</p>
            <p>Doubled Count: {doubledCount}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <button onClick={() => setCount(count - 1)}>Decrement</button>
        </div>
    );
}

function App() {
    return (
        <RecoilRoot>
            <Counter />
        </RecoilRoot>
    );
}

export default App;

// Expected Output: A counter component managed by Recoil, displaying the count and its doubled value using selectors.
```

#### Task 12: Testing React Components with Jest and Enzyme
**Explanation:**
Testing React components is essential for ensuring that your application behaves as expected and is free of bugs. Jest is a popular JavaScript testing framework, and Enzyme is a testing utility for React that makes it easier to test React components. Using Jest and Enzyme together allows you to write unit tests and integration tests for your React components.

Jest provides a robust framework for running tests, while Enzyme provides utilities for rendering and interacting with React components. Writing tests with Jest and Enzyme ensures that your components are tested in isolation and in combination, improving the reliability and maintainability of your application.

**Online Resources:**
1. [Jest Documentation](https://jestjs.io/docs/en/getting-started)
2. [Enzyme Documentation](https://enzymejs.github.io/enzyme/)

**Example 1: Setting Up Jest and Enzyme**
1. **Installing Jest and Enzyme:** Install Jest and Enzyme to set up the testing environment.
2. **Configuring Enzyme Adapter:** Configure the Enzyme adapter to work with your version of React.

**Explanation for Example 1:**
Installing Jest and Enzyme sets up the testing environment for your React application. Configuring the Enzyme adapter ensures that Enzyme works correctly with your version of React, allowing you to write and run tests.

**Example 2: Writing Tests for React Components**
1. **Unit Testing with Jest and Enzyme:** Write unit tests to test individual components in isolation.
2. **Integration Testing with Jest and Enzyme:** Write integration tests to test interactions between components.

**Explanation for Example 2:**
Unit testing involves testing individual components in isolation to ensure they behave as expected. Integration testing involves testing interactions between components to ensure they work together correctly. Writing both types of tests improves the reliability and maintainability of your application.

**Online Resources:**
1. [Testing React Components with Jest and Enzyme](https://www.pluralsight.com/guides/testing-in-react-using-jest-and-enzyme)
2. [React Testing with Jest and Enzyme](https://www.digitalocean.com/community/tutorials/testing-react-components-with-jest-and-enzyme)

**Code and Expected Output:**
```sh
// Installing Jest and Enzyme
npm install --save-dev jest enzyme enzyme-adapter-react-16 enzyme-to-json
```

```jsx
// Configuring Enzyme Adapter
// setupTests.js
import { configure } from 'enzyme';
import Adapter from 'enzyme-adapter-react-16';

configure({ adapter: new Adapter() });
```

```jsx
// Writing Tests for React Components
// Counter.js
import React from 'react';

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <div>
        <p>Count: {count}</p>
        <button onClick={onIncrement}>Increment</button>
        <button onClick={onDecrement}>Decrement</button>
    </div>
);

// Counter.test.js
import React from 'react';
import { shallow } from 'enzyme';
import { Counter } from './Counter';

describe('Counter component', () => {
    it('should render correctly with initial count', () => {
        const wrapper = shallow(<Counter count={0} />);
        expect(wrapper.find('p').text()).toBe('Count: 0');
    });

    it('should call onIncrement when increment button is clicked', () => {
        const onIncrement = jest.fn();
        const wrapper = shallow(<Counter count={0} onIncrement={onIncrement} />);
        wrapper.find('button').at(0).simulate('click');
        expect(onIncrement).toHaveBeenCalled();
    });

    it('should call onDecrement when decrement button is clicked', () => {
        const onDecrement = jest.fn();
        const wrapper = shallow(<Counter count={0} onDecrement={onDecrement} />);
        wrapper.find('button').at(1).simulate('click');
        expect(onDecrement).toHaveBeenCalled();
    });
});

// Expected Output: Tests verifying that the Counter component renders correctly and calls the correct handlers when buttons are clicked.
```

#### Task 13: Testing React Components with React Testing Library
**Explanation:**
React Testing Library is a testing utility that encourages testing React components in a way that mimics how users interact with the application. It provides utilities for querying the DOM and simulating user interactions, focusing on testing the behavior and output of components rather than their implementation details. React Testing Library works well with Jest, making it a powerful tool for testing React applications.

React Testing Library promotes best practices by encouraging you to test components from the user's perspective. This approach ensures that your tests are more robust and maintainable, improving the reliability of your application.

**Online Resources:**
1. [React Testing Library Documentation](https://testing-library.com/docs/react-testing-library/intro/)
2. [Testing with React Testing Library](https://www.smashingmagazine.com/2020/06/practical-guide-testing-react-applications-react-testing-library/)

**Example 1: Setting Up React Testing Library**
1. **Installing React Testing Library:** Install React Testing Library and its dependencies to set up the testing environment.
2. **Writing Basic Tests:** Write basic tests to verify the rendering and behavior of React components.

**Explanation for Example 1:**
Installing React Testing Library sets up the testing environment for your React application. Writing basic tests ensures that your components render correctly and behave as expected, providing a foundation for

 more complex tests.

**Example 2: Testing User Interactions**
1. **Simulating User Interactions:** Use React Testing Library to simulate user interactions with components.
2. **Verifying Component Behavior:** Verify that components behave correctly in response to user interactions.

**Explanation for Example 2:**
Simulating user interactions with React Testing Library allows you to test how components respond to events such as clicks and form submissions. Verifying component behavior ensures that your application works as intended and provides a good user experience.

**Online Resources:**
1. [React Testing Library API](https://testing-library.com/docs/react-testing-library/api)
2. [Testing React Components](https://www.tutorialspoint.com/reactjs/reactjs_testing.htm)

**Code and Expected Output:**
```sh
// Installing React Testing Library
npm install --save-dev @testing-library/react @testing-library/jest-dom
```

```jsx
// Writing Basic Tests
// Counter.js
import React from 'react';

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <div>
        <p>Count: {count}</p>
        <button onClick={onIncrement}>Increment</button>
        <button onClick={onDecrement}>Decrement</button>
    </div>
);

// Counter.test.js
import React from 'react';
import { render, screen } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { Counter } from './Counter';

describe('Counter component', () => {
    it('should render correctly with initial count', () => {
        render(<Counter count={0} />);
        expect(screen.getByText('Count: 0')).toBeInTheDocument();
    });

    it('should call onIncrement when increment button is clicked', () => {
        const onIncrement = jest.fn();
        render(<Counter count={0} onIncrement={onIncrement} />);
        userEvent.click(screen.getByText('Increment'));
        expect(onIncrement).toHaveBeenCalled();
    });

    it('should call onDecrement when decrement button is clicked', () => {
        const onDecrement = jest.fn();
        render(<Counter count={0} onDecrement={onDecrement} />);
        userEvent.click(screen.getByText('Decrement'));
        expect(onDecrement).toHaveBeenCalled();
    });
});

// Expected Output: Tests verifying that the Counter component renders correctly and calls the correct handlers when buttons are clicked.
```

#### Task 14: Styling React Components with CSS Modules
**Explanation:**
CSS Modules are a popular way to style React components with locally scoped CSS. They allow you to write CSS that is scoped to a specific component, avoiding conflicts with other styles in your application. CSS Modules automatically generate unique class names for your styles, ensuring that they do not conflict with global styles or styles from other components.

Using CSS Modules involves creating CSS files with the `.module.css` extension and importing them into your React components. This approach allows you to use CSS classes as JavaScript objects, making it easy to apply styles to your components in a modular and maintainable way.

**Online Resources:**
1. [CSS Modules Documentation](https://github.com/css-modules/css-modules)
2. [Styling React Components with CSS Modules](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/)

**Example 1: Setting Up CSS Modules**
1. **Creating CSS Module Files:** Create CSS files with the `.module.css` extension to define styles for your components.
2. **Importing CSS Modules:** Import the CSS module files into your React components and apply styles.

**Explanation for Example 1:**
Creating CSS module files allows you to define styles that are scoped to specific components. Importing the CSS module files into your React components ensures that the styles are applied correctly and do not conflict with other styles in your application.

**Example 2: Using CSS Modules with Dynamic Styles**
1. **Applying Conditional Styles:** Use CSS Modules to apply conditional styles based on component state or props.
2. **Combining CSS Modules with Other Styling Approaches:** Combine CSS Modules with other styling approaches like inline styles or styled-components for more complex styling needs.

**Explanation for Example 2:**
Applying conditional styles with CSS Modules allows you to dynamically update the appearance of your components based on their state or props. Combining CSS Modules with other styling approaches provides flexibility and allows you to handle more complex styling scenarios.

**Online Resources:**
1. [CSS Modules with React](https://create-react-app.dev/docs/adding-a-css-modules-stylesheet/)
2. [Advanced CSS Module Usage](https://blog.logrocket.com/using-css-modules-react/)

**Code and Expected Output:**
```css
/* Counter.module.css */
.counter {
    font-size: 20px;
    color: blue;
}

.button {
    background-color: lightblue;
    border: none;
    padding: 10px;
    cursor: pointer;
}
```

```jsx
// Setting Up CSS Modules
// Counter.js
import React from 'react';
import styles from './Counter.module.css';

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <div className={styles.counter}>
        <p>Count: {count}</p>
        <button className={styles.button} onClick={onIncrement}>Increment</button>
        <button className={styles.button} onClick={onDecrement}>Decrement</button>
    </div>
);
```

```jsx
// Using CSS Modules with Dynamic Styles
// Counter.js
import React from 'react';
import styles from './Counter.module.css';

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <div className={styles.counter}>
        <p>Count: {count}</p>
        <button className={`${styles.button} ${count > 0 ? styles.positive : styles.negative}`} onClick={onIncrement}>Increment</button>
        <button className={`${styles.button} ${count < 0 ? styles.negative : styles.positive}`} onClick={onDecrement}>Decrement</button>
    </div>
);
```

```css
/* Counter.module.css */
.counter {
    font-size: 20px;
    color: blue;
}

.button {
    background-color: lightblue;
    border: none;
    padding: 10px;
    cursor: pointer;
}

.positive {
    color: green;
}

.negative {
    color: red;
}
```

#### Task 15: Styling React Components with Styled-Components
**Explanation:**
Styled-components is a popular library for styling React components using tagged template literals. It allows you to write CSS directly within your JavaScript code, creating styled components that encapsulate their styles. This approach provides a powerful way to manage component styles, enabling you to leverage the full power of CSS while keeping your styles scoped to specific components.

Styled-components supports dynamic styling based on props, theming, and nesting of styles. This makes it a flexible and powerful tool for styling React applications, providing a seamless integration between JavaScript and CSS.

**Online Resources:**
1. [Styled-Components Documentation](https://styled-components.com/docs)
2. [Using Styled-Components with React](https://www.smashingmagazine.com/2020/05/styled-components-react/)

**Example 1: Setting Up Styled-Components**
1. **Installing Styled-Components:** Install styled-components to set up the library in your React project.
2. **Creating Styled Components:** Create styled components using tagged template literals and apply styles.

**Explanation for Example 1:**
Installing styled-components sets up the library in your React project, enabling you to create styled components. Creating styled components using tagged template literals allows you to write CSS directly within your JavaScript code, providing a seamless integration between styles and components.

**Example 2: Dynamic Styling with Styled-Components**
1. **Applying Dynamic Styles:** Use styled-components to apply dynamic styles based on props.
2. **Theming with Styled-Components:** Implement theming to provide consistent styles across your application.

**Explanation for Example 2:**
Applying dynamic styles with styled-components allows you to update the appearance of your components based on their props. Implementing theming provides a way to define consistent styles across your application, making it easy to manage and update your styles.

**Online Resources:**
1. [Styled-Components API](https://styled-components.com/docs/api)
2. [Advanced Styled-Components Usage](https://blog.logrocket.com/styled-components-in-react/)

**Code and Expected Output:**
```sh
// Installing Styled-Components
npm install styled-components
```

```jsx
// Setting Up Styled-Components
import React from 'react';
import styled from 'styled-components';

const CounterContainer = styled.div`
    font-size: 20px;
    color: blue;
`;

const Button = styled.button`
    background-color: lightblue;
    border: none;
    padding: 10px;
    cursor: pointer;
`;

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <CounterContainer>
        <p>Count: {count}</p>
        <Button onClick={onIncrement}>Increment</Button>
        <Button onClick={onDecrement}>Decrement</Button>
    </CounterContainer>
);
```

```jsx
// Dynamic Styling with Styled-Components
import React from 'react';
import styled, { ThemeProvider } from 'styled-components';

const CounterContainer = styled.div`
    font-size: 20px;
    color: blue;
`;

const Button = styled.button`
    background-color: lightblue;
    border: none;
    padding: 10px;
    cursor: pointer;
    color: ${(props) => (props.count > 0 ? 'green' : 'red')};
`;

const theme = {
    primary

Color: 'blue',
    secondaryColor: 'lightblue',
};

export const Counter = ({ count, onIncrement, onDecrement }) => (
    <ThemeProvider theme={theme}>
        <CounterContainer>
            <p>Count: {count}</p>
            <Button count={count} onClick={onIncrement}>Increment</Button>
            <Button count={count} onClick={onDecrement}>Decrement</Button>
        </CounterContainer>
    </ThemeProvider>
);
```

#### Task 16: Styling React Components with Tailwind CSS
**Explanation:**
Tailwind CSS is a utility-first CSS framework that provides a set of utility classes for building custom designs without leaving your HTML. It allows you to apply styles directly to your markup, enabling you to create complex designs quickly and efficiently. Tailwind CSS promotes a different approach to styling, focusing on utility classes rather than custom CSS.

Using Tailwind CSS with React involves setting up the framework in your project and applying utility classes to your components. This approach provides a highly customizable and maintainable way to style your application, enabling you to create responsive and consistent designs.

**Online Resources:**
1. [Tailwind CSS Documentation](https://tailwindcss.com/docs)
2. [Using Tailwind CSS with React](https://blog.logrocket.com/using-tailwind-css-with-react/)

**Example 1: Setting Up Tailwind CSS**
1. **Installing Tailwind CSS:** Install Tailwind CSS and set up the necessary configuration in your project.
2. **Applying Utility Classes:** Apply Tailwind CSS utility classes to your React components.

**Explanation for Example 1:**
Installing Tailwind CSS and setting up the necessary configuration ensures that the framework is properly integrated into your project. Applying utility classes to your React components allows you to style them quickly and efficiently using Tailwind's predefined classes.

**Example 2: Customizing Tailwind CSS**
1. **Extending Tailwind Config:** Extend the Tailwind CSS configuration to customize the framework for your project.
2. **Using Custom Utility Classes:** Create and use custom utility classes to meet specific design requirements.

**Explanation for Example 2:**
Extending the Tailwind CSS configuration allows you to customize the framework to meet the specific needs of your project. Creating and using custom utility classes provides additional flexibility, enabling you to implement unique and complex designs.

**Online Resources:**
1. [Tailwind CSS Configuration](https://tailwindcss.com/docs/configuration)
2. [Customizing Tailwind CSS](https://tailwindcss.com/docs/customizing-spacing)

**Code and Expected Output:**
```sh
// Installing Tailwind CSS
npm install -D tailwindcss
npx tailwindcss init
```

```js
// tailwind.config.js
module.exports = {
    purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
    darkMode: false,
    theme: {
        extend: {},
    },
    variants: {
        extend: {},
    },
    plugins: [],
};
```

```css
/* src/index.css */
@tailwind base;
@tailwind components;
@tailwind utilities;
```

```jsx
// Setting Up Tailwind CSS
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';

const Counter = ({ count, onIncrement, onDecrement }) => (
    <div className="text-lg text-blue-500">
        <p>Count: {count}</p>
        <button className="bg-blue-200 p-2 m-1" onClick={onIncrement}>Increment</button>
        <button className="bg-blue-200 p-2 m-1" onClick={onDecrement}>Decrement</button>
    </div>
);

function App() {
    const [count, setCount] = React.useState(0);

    return (
        <div className="p-4">
            <Counter count={count} onIncrement={() => setCount(count + 1)} onDecrement={() => setCount(count - 1)} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));

// Expected Output: A counter component styled with Tailwind CSS utility classes.
```

```js
// Customizing Tailwind CSS
// tailwind.config.js
module.exports = {
    purge: ['./src/**/*.{js,jsx,ts,tsx}', './public/index.html'],
    darkMode: false,
    theme: {
        extend: {
            colors: {
                primary: '#1D4ED8',
                secondary: '#93C5FD',
            },
        },
    },
    variants: {
        extend: {},
    },
    plugins: [],
};
```

```jsx
// Using Custom Utility Classes
import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';

const Counter = ({ count, onIncrement, onDecrement }) => (
    <div className="text-lg text-primary">
        <p>Count: {count}</p>
        <button className="bg-secondary p-2 m-1" onClick={onIncrement}>Increment</button>
        <button className="bg-secondary p-2 m-1" onClick={onDecrement}>Decrement</button>
    </div>
);

function App() {
    const [count, setCount] = React.useState(0);

    return (
        <div className="p-4">
            <Counter count={count} onIncrement={() => setCount(count + 1)} onDecrement={() => setCount(count - 1)} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));

// Expected Output: A counter component styled with custom Tailwind CSS utility classes.
```

#### Task 17: State Management with MobX
**Explanation:**
MobX is a state management library that simplifies state management by using observable state and reactive programming principles. MobX allows you to define observable state, actions, and computed values, making it easy to manage and update state in your React applications. MobX provides a declarative approach to state management, ensuring that your UI stays in sync with your state automatically.

Using MobX involves creating observable state, defining actions to modify the state, and using computed values to derive state based on observables. Integrating MobX with React components ensures that your components re-render automatically when the observable state changes, providing a seamless and efficient state management solution.

**Online Resources:**
1. [MobX Documentation](https://mobx.js.org/README.html)
2. [Using MobX with React](https://mobx.js.org/react-integration.html)

**Example 1: Setting Up MobX**
1. **Installing MobX:** Install MobX and its React bindings to set up the library in your project.
2. **Creating Observable State:** Define observable state and actions to manage state changes.

**Explanation for Example 1:**
Installing MobX and its React bindings sets up the library in your project, enabling you to use MobX for state management. Creating observable state and actions provides a structured way to manage state changes and ensure that your components stay in sync with the state.

**Example 2: Using MobX with React Components**
1. **Observing State Changes:** Use MobX to observe state changes and re-render components automatically.
2. **Using Computed Values:** Define computed values to derive state based on observables and use them in your components.

**Explanation for Example 2:**
Using MobX to observe state changes ensures that your components re-render automatically when the state changes, providing a reactive and efficient state management solution. Defining computed values allows you to derive state based on observables, ensuring that your components display the correct data at all times.

**Online Resources:**
1. [MobX React Integration](https://mobx.js.org/react-integration.html)
2. [MobX Best Practices](https://mobx.js.org/best/pitfalls.html)

**Code and Expected Output:**
```sh
// Installing MobX
npm install mobx mobx-react-lite
```

```jsx
// Setting Up MobX
// store.js
import { makeAutoObservable } from 'mobx';

class CounterStore {
    count = 0;

    constructor() {
        makeAutoObservable(this);
    }

    increment() {
        this.count += 1;
    }

    decrement() {
        this.count -= 1;
    }
}

const store = new CounterStore();
export default store;
```

```jsx
// Using MobX with React Components
// App.js
import React from 'react';
import { observer } from 'mobx-react-lite';
import store from './store';

const Counter = observer(() => {
    return (
        <div>
            <p>Count: {store.count}</p>
            <button onClick={() => store.increment()}>Increment</button>
            <button onClick={() => store.decrement()}>Decrement</button>
        </div>
    );
});

function App() {
    return (
        <div>
            <h1>MobX State Management</h1>
            <Counter />
        </div>
    );
}

export default App;

// Expected Output: A counter component managed by MobX, allowing you to increment and decrement the count.
```

```jsx
// Using Computed Values with MobX
// store.js
import { makeAutoObservable } from 'mobx';

class CounterStore {
    count = 0;

    constructor() {
        makeAutoObservable(this);
    }

    increment() {
        this.count += 1;
    }

    decrement() {
        this.count -= 1;
    }

    get doubledCount() {
        return this.count * 2;
    }
}

const store = new CounterStore();
export default store;
```

```jsx
// App.js


import React from 'react';
import { observer } from 'mobx-react-lite';
import store from './store';

const Counter = observer(() => {
    return (
        <div>
            <p>Count: {store.count}</p>
            <p>Doubled Count: {store.doubledCount}</p>
            <button onClick={() => store.increment()}>Increment</button>
            <button onClick={() => store.decrement()}>Decrement</button>
        </div>
    );
});

function App() {
    return (
        <div>
            <h1>MobX State Management</h1>
            <Counter />
        </div>
    );
}

export default App;

// Expected Output: A counter component managed by MobX, displaying the count and its doubled value using computed values.
```

#### Task 18: Form Handling with React Hook Form
**Explanation:**
React Hook Form is a library for managing form state and validation in React applications. It provides a simple and efficient way to handle form input and validation using hooks. React Hook Form reduces the need for boilerplate code and improves performance by minimizing re-renders and managing form state efficiently.

Using React Hook Form involves creating form components, registering input fields, and defining validation rules. The library provides a set of hooks to manage form state, handle form submission, and integrate with validation libraries like Yup for schema-based validation.

**Online Resources:**
1. [React Hook Form Documentation](https://react-hook-form.com/)
2. [Using React Hook Form](https://react-hook-form.com/get-started)

**Example 1: Setting Up React Hook Form**
1. **Installing React Hook Form:** Install React Hook Form to set up the library in your project.
2. **Creating a Simple Form:** Create a simple form using React Hook Form to manage form state and handle submission.

**Explanation for Example 1:**
Installing React Hook Form sets up the library in your project, enabling you to use it for form handling. Creating a simple form with React Hook Form demonstrates how to manage form state and handle form submission efficiently.

**Example 2: Form Validation with React Hook Form and Yup**
1. **Defining Validation Rules:** Use Yup to define schema-based validation rules for your form.
2. **Integrating Validation:** Integrate Yup validation with React Hook Form to validate form input.

**Explanation for Example 2:**
Defining validation rules with Yup allows you to specify schema-based validation for your form fields. Integrating Yup validation with React Hook Form ensures that your form input is validated according to the defined rules, providing a robust and reliable form handling solution.

**Online Resources:**
1. [React Hook Form API](https://react-hook-form.com/api)
2. [Yup Validation](https://github.com/jquense/yup)

**Code and Expected Output:**
```sh
// Installing React Hook Form and Yup
npm install react-hook-form yup @hookform/resolvers
```

```jsx
// Setting Up React Hook Form
import React from 'react';
import { useForm } from 'react-hook-form';

function App() {
    const { register, handleSubmit } = useForm();

    const onSubmit = (data) => {
        console.log(data);
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <label>
                Name:
                <input {...register('name')} />
            </label>
            <label>
                Email:
                <input type="email" {...register('email')} />
            </label>
            <button type="submit">Submit</button>
        </form>
    );
}

export default App;

// Expected Output: A form with name and email fields, logging the form data on submission.
```

```jsx
// Form Validation with React Hook Form and Yup
import React from 'react';
import { useForm } from 'react-hook-form';
import * as yup from 'yup';
import { yupResolver } from '@hookform/resolvers/yup';

const schema = yup.object().shape({
    name: yup.string().required('Name is required'),
    email: yup.string().email('Invalid email').required('Email is required'),
});

function App() {
    const { register, handleSubmit, formState: { errors } } = useForm({
        resolver: yupResolver(schema),
    });

    const onSubmit = (data) => {
        console.log(data);
    };

    return (
        <form onSubmit={handleSubmit(onSubmit)}>
            <label>
                Name:
                <input {...register('name')} />
                {errors.name && <p>{errors.name.message}</p>}
            </label>
            <label>
                Email:
                <input type="email" {...register('email')} />
                {errors.email && <p>{errors.email.message}</p>}
            </label>
            <button type="submit">Submit</button>
        </form>
    );
}

export default App;

// Expected Output: A form with name and email fields, displaying validation errors when the form is submitted with invalid input.
```

#### Task 19: Internationalization with React-Intl
**Explanation:**
Internationalization (i18n) involves adapting your application to support multiple languages and locales. React-Intl is a library that provides React components and an API for formatting dates, numbers, and strings based on the user's locale. It allows you to manage translations and localize your application efficiently.

Using React-Intl involves setting up the library, defining messages for different locales, and using React-Intl components to format strings, dates, and numbers. This approach ensures that your application can support multiple languages and provide a localized user experience.

**Online Resources:**
1. [React-Intl Documentation](https://formatjs.io/docs/react-intl/)
2. [Internationalization in React](https://react.i18next.com/)

**Example 1: Setting Up React-Intl**
1. **Installing React-Intl:** Install React-Intl to set up the library in your project.
2. **Defining Messages and Locales:** Define messages for different locales and use React-Intl components to display localized content.

**Explanation for Example 1:**
Installing React-Intl sets up the library in your project, enabling you to use it for internationalization. Defining messages for different locales and using React-Intl components allows you to display localized content based on the user's locale.

**Example 2: Dynamic Locale Switching**
1. **Implementing Locale Switching:** Implement functionality to switch between different locales dynamically.
2. **Managing Translations:** Use React-Intl to manage translations and update the UI based on the selected locale.

**Explanation for Example 2:**
Implementing locale switching allows users to change the language of the application dynamically. Using React-Intl to manage translations ensures that the UI is updated based on the selected locale, providing a localized user experience.

**Online Resources:**
1. [React-Intl API](https://formatjs.io/docs/react-intl/api/)
2. [Dynamic Locale Switching with React-Intl](https://formatjs.io/docs/guides/dynamic-loading/)

**Code and Expected Output:**
```sh
// Installing React-Intl
npm install react-intl
```

```jsx
// Setting Up React-Intl
import React from 'react';
import ReactDOM from 'react-dom';
import { IntlProvider, FormattedMessage, FormattedNumber } from 'react-intl';

const messages = {
    en: {
        welcome: 'Welcome to React-Intl',
        count: 'Count: {count}',
    },
    fr: {
        welcome: 'Bienvenue  React-Intl',
        count: 'Compte: {count}',
    },
};

function App({ locale }) {
    return (
        <IntlProvider locale={locale} messages={messages[locale]}>
            <div>
                <h1><FormattedMessage id="welcome" /></h1>
                <p><FormattedMessage id="count" values={{ count: <FormattedNumber value={10} /> }} /></p>
            </div>
        </IntlProvider>
    );
}

ReactDOM.render(<App locale="en" />, document.getElementById('root'));

// Expected Output: A localized message displayed based on the selected locale.
```

```jsx
// Dynamic Locale Switching
import React, { useState } from 'react';
import ReactDOM from 'react-dom';
import { IntlProvider, FormattedMessage, FormattedNumber } from 'react-intl';

const messages = {
    en: {
        welcome: 'Welcome to React-Intl',
        count: 'Count: {count}',
    },
    fr: {
        welcome: 'Bienvenue  React-Intl',
        count: 'Compte: {count}',
    },
};

function App() {
    const [locale, setLocale] = useState('en');

    const switchLocale = () => {
        setLocale(locale === 'en' ? 'fr' : 'en');
    };

    return (
        <IntlProvider locale={locale} messages={messages[locale]}>
            <div>
                <h1><FormattedMessage id="welcome" /></h1>
                <p><FormattedMessage id="count" values={{ count: <FormattedNumber value={10} /> }} /></p>
                <button onClick={switchLocale}>Switch Locale</button>
            </div>
        </IntlProvider>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));

// Expected Output: A button that switches the locale dynamically, updating the displayed messages.
```

#### Task 20: Implementing Authentication with Firebase
**Explanation:**
Firebase is a platform that provides various services, including authentication, for building and managing web applications. Firebase Authentication allows you to authenticate users using email/password, social providers like Google and Facebook, and more. It provides a secure and easy-to-use authentication system that can be integrated into your React application.

Using Firebase Authentication involves setting up Firebase in your project

, configuring authentication providers, and implementing authentication flows in your React components. This approach ensures that your application has a secure and reliable authentication system.

**Online Resources:**
1. [Firebase Authentication Documentation](https://firebase.google.com/docs/auth)
2. [Using Firebase with React](https://firebase.google.com/docs/web/setup)

**Example 1: Setting Up Firebase Authentication**
1. **Installing Firebase:** Install Firebase to set up the library in your project.
2. **Configuring Authentication Providers:** Configure authentication providers in the Firebase console and integrate them into your React application.

**Explanation for Example 1:**
Installing Firebase sets up the library in your project, enabling you to use Firebase services. Configuring authentication providers in the Firebase console allows you to set up various authentication methods, which can then be integrated into your React application.

**Example 2: Implementing Authentication Flows**
1. **Handling User Sign-In:** Implement functionality to handle user sign-in using Firebase Authentication.
2. **Managing Authentication State:** Use Firebase to manage authentication state and update the UI based on the user's authentication status.

**Explanation for Example 2:**
Implementing user sign-in functionality allows users to authenticate using Firebase Authentication. Managing authentication state ensures that the UI is updated based on the user's authentication status, providing a secure and user-friendly authentication system.

**Online Resources:**
1. [Firebase Authentication Setup](https://firebase.google.com/docs/auth/web/start)
2. [React Firebase Authentication](https://dev.to/sivaneshs/add-authentication-to-your-react-app-using-firebase-5bc5)

**Code and Expected Output:**
```sh
// Installing Firebase
npm install firebase
```

```jsx
// Setting Up Firebase Authentication
// firebase.js
import firebase from 'firebase/app';
import 'firebase/auth';

const firebaseConfig = {
    apiKey: 'YOUR_API_KEY',
    authDomain: 'YOUR_AUTH_DOMAIN',
    projectId: 'YOUR_PROJECT_ID',
    storageBucket: 'YOUR_STORAGE_BUCKET',
    messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
    appId: 'YOUR_APP_ID',
};

firebase.initializeApp(firebaseConfig);

export const auth = firebase.auth();
export const googleProvider = new firebase.auth.GoogleAuthProvider();
```

```jsx
// Implementing Authentication Flows
// App.js
import React, { useState, useEffect } from 'react';
import { auth, googleProvider } from './firebase';

function App() {
    const [user, setUser] = useState(null);

    useEffect(() => {
        const unsubscribe = auth.onAuthStateChanged((user) => {
            setUser(user);
        });
        return () => unsubscribe();
    }, []);

    const signInWithGoogle = () => {
        auth.signInWithPopup(googleProvider);
    };

    const signOut = () => {
        auth.signOut();
    };

    return (
        <div>
            {user ? (
                <div>
                    <p>Welcome, {user.displayName}</p>
                    <button onClick={signOut}>Sign Out</button>
                </div>
            ) : (
                <button onClick={signInWithGoogle}>Sign In with Google</button>
            )}
        </div>
    );
}

export default App;

// Expected Output: A button that allows users to sign in with Google, displaying a welcome message and sign-out button upon successful authentication.
```

This completes the detailed breakdown of tasks for Day 5. Each task provides a deep dive into advanced React topics, with explanations, examples, and code snippets to practice. This approach ensures a comprehensive understanding and hands-on experience with various advanced concepts in React development.
