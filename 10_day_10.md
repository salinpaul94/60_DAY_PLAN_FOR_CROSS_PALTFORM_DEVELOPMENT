for day 10, tasks listed between
"""
Study more advanced navigation concepts.
Implement tab navigation.
Use drawer navigation.
Combine different navigators.
Learn about navigation guards.
Implement authentication flow.
Study authentication methods.
Use Firebase for authentication.
Implement OAuth with third-party services.
Study form libraries (Formik).
Use Formik for complex forms.
Validate forms with Yup.
Learn about testing in React Native.
Set up testing environment.
Write unit tests with Jest.
Test components with React Native Testing Library.
Learn about E2E testing.
Use Detox for E2E tests.
Study debugging techniques.
Use React Native Debugger and Flipper.
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output
### Task 1: Study more advanced navigation concepts

**Explanation:**
Advanced navigation concepts in React Native involve understanding and implementing complex navigation structures and features. These include nested navigators, dynamic routing, custom navigation transitions, and state persistence. Advanced navigation allows for creating a more user-friendly and intuitive navigation experience, which can handle a wide variety of use cases.

Mastering advanced navigation concepts is essential for building scalable and maintainable applications. It ensures that the navigation flow is smooth, responsive, and capable of handling various scenarios, such as deep linking, user authentication, and complex UI interactions.

**Resources:**
- [React Navigation Advanced Guide](https://reactnavigation.org/docs/advanced-guides/)
- [Medium: Advanced Navigation Patterns in React Native](https://medium.com/react-native-training/advanced-navigation-patterns-in-react-native-4fc836e2f20e)

**Example 1:**
```javascript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();

function HomeScreen() {
  return <View><Text>Home Screen</Text></View>;
}

function DetailsScreen() {
  return <View><Text>Details Screen</Text></View>;
}

function HomeStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Details" component={DetailsScreen} />
    </Stack.Navigator>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator>
        <Tab.Screen name="Home" component={HomeStack} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}

function SettingsScreen() {
  return <View><Text>Settings Screen</Text></View>;
}
```

**Example Explanation:**
This example demonstrates a nested navigator setup using a stack navigator inside a tab navigator. The `HomeStack` contains the home and details screens, which are nested inside the bottom tab navigator that includes the home and settings tabs.

**Example 2:**
```javascript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createDrawerNavigator } from '@react-navigation/drawer';

const Stack = createStackNavigator();
const Drawer = createDrawerNavigator();

function HomeScreen() {
  return <View><Text>Home Screen</Text></View>;
}

function DetailsScreen() {
  return <View><Text>Details Screen</Text></View>;
}

function DrawerNavigator() {
  return (
    <Drawer.Navigator>
      <Drawer.Screen name="Home" component={HomeScreen} />
      <Drawer.Screen name="Details" component={DetailsScreen} />
    </Drawer.Navigator>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Drawer" component={DrawerNavigator} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates combining stack and drawer navigators. The `DrawerNavigator` is nested inside a stack navigator, providing a drawer menu with home and details screens.

**Resources:**
- [W3Schools: Advanced Navigation in React Native](https://www.w3schools.com/react/react_native_navigation.asp)
- [FreeCodeCamp: Advanced Navigation Techniques in React Native](https://www.freecodecamp.org/news/advanced-navigation-react-native/)

**Expected Output:**
For Example 1:
```
Displays a bottom tab navigator with a home stack and settings screen.
```
For Example 2:
```
Displays a stack navigator with a drawer navigator containing home and details screens.
```

---

### Task 2: Implement tab navigation

**Explanation:**
Tab navigation allows users to navigate between different screens using tabs. In React Native, the `@react-navigation/bottom-tabs` package provides an easy way to implement tab navigation with a customizable tab bar. Tab navigation is ideal for applications with a few main sections, as it provides quick and easy access to each section.

Implementing tab navigation enhances the user experience by providing a clear and intuitive way to switch between different parts of the application. It helps organize content and makes navigation more efficient, especially in apps with distinct functional areas.

**Resources:**
- [React Navigation: Tab Navigation](https://reactnavigation.org/docs/tab-based-navigation/)
- [Medium: Implementing Tab Navigation in React Native](https://medium.com/react-native-training/react-native-tab-navigator-9a7e2a3c5097)

**Example 1:**
```javascript
import React from 'react';
import { View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';

const Tab = createBottomTabNavigator();

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

function SettingsScreen() {
  return (
    <View>
      <Text>Settings Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator>
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing tab navigation using the `createBottomTabNavigator` function from React Navigation. The `Tab.Navigator` contains two tabs: home and settings, each rendering their respective components.

**Example 2:**
```javascript
import React from 'react';
import { View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Icon from 'react-native-vector-icons/Ionicons';

const Tab = createBottomTabNavigator();

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

function SettingsScreen() {
  return (
    <View>
      <Text>Settings Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Tab.Navigator
        screenOptions={({ route }) => ({
          tabBarIcon: ({ color, size }) => {
            let iconName;
            if (route.name === 'Home') {
              iconName = 'ios-home';
            } else if (route.name === 'Settings') {
              iconName = 'ios-settings';
            }
            return <Icon name={iconName} size={size} color={color} />;
          },
        })}
        tabBarOptions={{
          activeTintColor: 'tomato',
          inactiveTintColor: 'gray',
        }}
      >
        <Tab.Screen name="Home" component={HomeScreen} />
        <Tab.Screen name="Settings" component={SettingsScreen} />
      </Tab.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing tab navigation with icons using the `react-native-vector-icons` library. The `screenOptions` prop configures icons for each tab, and the `tabBarOptions` prop customizes the appearance of the tab bar.

**Resources:**
- [W3Schools: Tab Navigation in React Native](https://www.w3schools.com/react/react_native_tab_navigation.asp)
- [FreeCodeCamp: Tab Navigation with React Navigation](https://www.freecodecamp.org/news/react-native-tab-navigation/)

**Expected Output:**
For Example 1:
```
Displays a bottom tab navigator with home and settings screens.
```
For Example 2:
```
Displays a bottom tab navigator with home and settings screens, each with icons.
```

---

### Task 3: Use drawer navigation

**Explanation:**
Drawer navigation allows users to open a side menu to navigate between different screens. In React Native, the `@react-navigation/drawer` package provides a customizable drawer navigator that can be used to implement side menus. Drawer navigation is suitable for applications with multiple sections or options that users need to access frequently.

Using drawer navigation enhances the user experience by providing a convenient way to access various sections of the application. It helps organize content and allows for quick navigation, especially in apps with many functional areas.

**Resources:**
- [React Navigation: Drawer Navigation](https://reactnavigation.org/docs/drawer-based-navigation/)
- [Medium: Implementing Drawer Navigation in React Native](https://medium.com/react-native-training/react-native-drawer-navigator-using-react-navigation-9cd7da7b1a55)

**Example 1:**
```javascript
import React from 'react';
import { View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createDrawerNavigator } from '@react-navigation/drawer';

const Drawer = createDrawerNavigator();

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

function SettingsScreen() {
  return (
    <View>
      <Text>Settings Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator>
        <Drawer.Screen name="Home" component={HomeScreen} />
        <Drawer.Screen name="Settings" component={SettingsScreen} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing drawer navigation using the `createDrawerNavigator` function from React Navigation. The `Drawer

.Navigator` contains two screens: home and settings, each rendering their respective components.

**Example 2:**
```javascript
import React from 'react';
import { View, Text } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import Icon from 'react-native-vector-icons/Ionicons';

const Drawer = createDrawerNavigator();

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

function SettingsScreen() {
  return (
    <View>
      <Text>Settings Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator
        screenOptions={({ route }) => ({
          drawerIcon: ({ color, size }) => {
            let iconName;
            if (route.name === 'Home') {
              iconName = 'ios-home';
            } else if (route.name === 'Settings') {
              iconName = 'ios-settings';
            }
            return <Icon name={iconName} size={size} color={color} />;
          },
        })}
      >
        <Drawer.Screen name="Home" component={HomeScreen} />
        <Drawer.Screen name="Settings" component={SettingsScreen} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing drawer navigation with icons using the `react-native-vector-icons` library. The `screenOptions` prop configures icons for each drawer item.

**Resources:**
- [W3Schools: Drawer Navigation in React Native](https://www.w3schools.com/react/react_native_drawer_navigation.asp)
- [FreeCodeCamp: Drawer Navigation with React Navigation](https://www.freecodecamp.org/news/react-native-drawer-navigation/)

**Expected Output:**
For Example 1:
```
Displays a drawer navigator with home and settings screens.
```
For Example 2:
```
Displays a drawer navigator with home and settings screens, each with icons.
```

---

### Task 4: Combine different navigators

**Explanation:**
Combining different navigators involves using multiple types of navigators (e.g., stack, tab, drawer) within a single application to create a comprehensive navigation structure. This allows for a more flexible and organized navigation experience, where different sections of the app can have their own specific navigation logic.

Combining different navigators is essential for building complex applications with multiple layers of navigation. It provides a way to organize screens logically and ensure a smooth user experience across various parts of the application.

**Resources:**
- [React Navigation: Nesting Navigators](https://reactnavigation.org/docs/nesting-navigators/)
- [Medium: Combining Navigators in React Native](https://medium.com/react-native-training/nesting-navigators-in-react-native-df97a6f3a97c)

**Example 1:**
```javascript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createDrawerNavigator } from '@react-navigation/drawer';

const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();
const Drawer = createDrawerNavigator();

function HomeScreen() {
  return <View><Text>Home Screen</Text></View>;
}

function DetailsScreen() {
  return <View><Text>Details Screen</Text></View>;
}

function SettingsScreen() {
  return <View><Text>Settings Screen</Text></View>;
}

function HomeStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Details" component={DetailsScreen} />
    </Stack.Navigator>
  );
}

function TabNavigator() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="HomeStack" component={HomeStack} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator>
        <Drawer.Screen name="Tabs" component={TabNavigator} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates combining stack, tab, and drawer navigators. The `HomeStack` contains the home and details screens, nested inside a tab navigator, which is further nested inside a drawer navigator.

**Example 2:**
```javascript
import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import { createDrawerNavigator } from '@react-navigation/drawer';

const Stack = createStackNavigator();
const Tab = createBottomTabNavigator();
const Drawer = createDrawerNavigator();

function HomeScreen() {
  return <View><Text>Home Screen</Text></View>;
}

function DetailsScreen() {
  return <View><Text>Details Screen</Text></View>;
}

function ProfileScreen() {
  return <View><Text>Profile Screen</Text></View>;
}

function HomeStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Details" component={DetailsScreen} />
    </Stack.Navigator>
  );
}

function ProfileStack() {
  return (
    <Stack.Navigator>
      <Stack.Screen name="Profile" component={ProfileScreen} />
    </Stack.Navigator>
  );
}

function TabNavigator() {
  return (
    <Tab.Navigator>
      <Tab.Screen name="HomeStack" component={HomeStack} />
      <Tab.Screen name="ProfileStack" component={ProfileStack} />
    </Tab.Navigator>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Drawer.Navigator>
        <Drawer.Screen name="Tabs" component={TabNavigator} />
      </Drawer.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates combining multiple stack navigators within a tab navigator, which is then nested inside a drawer navigator. This structure provides a comprehensive navigation system with multiple layers of navigation.

**Resources:**
- [W3Schools: Combining Navigators in React Native](https://www.w3schools.com/react/react_native_combining_navigators.asp)
- [FreeCodeCamp: Nesting Navigators in React Native](https://www.freecodecamp.org/news/react-native-nesting-navigators/)

**Expected Output:**
For Example 1:
```
Displays a drawer navigator with a tab navigator containing home and settings screens, with the home screen containing nested stack screens.
```
For Example 2:
```
Displays a drawer navigator with a tab navigator containing two stack navigators (home and profile), each with their own screens.
```

---

### Task 5: Learn about navigation guards

**Explanation:**
Navigation guards are functions that are invoked before navigating to a new screen. They can be used to prevent navigation, perform checks, or run asynchronous code. Navigation guards are commonly used for authentication, ensuring that only authorized users can access certain screens.

Learning about navigation guards is essential for securing and managing navigation in your application. They provide a way to control access to screens, enhance security, and improve the user experience by handling conditions before navigation occurs.

**Resources:**
- [React Navigation: Before Remove Listener](https://reactnavigation.org/docs/preventing-going-back/)
- [Medium: Implementing Navigation Guards in React Native](https://medium.com/react-native-training/implementing-navigation-guards-in-react-native-7c11e5b7fefd)

**Example 1:**
```javascript
import React from 'react';
import { View, Text, Button } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

function HomeScreen({ navigation }) {
  return (
    <View>
      <Text>Home Screen</Text>
      <Button title="Go to Details" onPress={() => navigation.navigate('Details')} />
    </View>
  );
}

function DetailsScreen({ navigation }) {
  React.useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      if (!shouldNavigateAway()) {
        e.preventDefault();
      }
    });

    return unsubscribe;
  }, [navigation]);

  const shouldNavigateAway = () => {
    // Perform your check here
    return true;
  };

  return (
    <View>
      <Text>Details Screen</Text>
      <Button title="Go Back" onPress={() => navigation.goBack()} />
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates using a navigation guard in the `DetailsScreen` to prevent navigation based on a condition. The `beforeRemove` listener checks the `shouldNavigateAway` function before allowing the navigation action.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, Button } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

function HomeScreen({ navigation }) {
  return (
    <View>
      <Text>Home Screen</Text>
      <Button title="Go to Profile" on

Press={() => navigation.navigate('Profile')} />
    </View>
  );
}

function ProfileScreen({ navigation }) {
  React.useEffect(() => {
    const unsubscribe = navigation.addListener('beforeRemove', (e) => {
      e.preventDefault();
      // Perform your check here and navigate conditionally
      navigation.navigate('Home');
    });

    return unsubscribe;
  }, [navigation]);

  return (
    <View>
      <Text>Profile Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Profile" component={ProfileScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates using a navigation guard in the `ProfileScreen` to prevent navigation and conditionally navigate to another screen. The `beforeRemove` listener performs a check and navigates to the `Home` screen based on the condition.

**Resources:**
- [W3Schools: Navigation Guards in React Native](https://www.w3schools.com/react/react_native_navigation_guards.asp)
- [FreeCodeCamp: Implementing Navigation Guards in React Native](https://www.freecodecamp.org/news/react-native-navigation-guards/)

**Expected Output:**
For Example 1:
```
Prevents navigation away from the details screen based on a condition.
```
For Example 2:
```
Prevents navigation away from the profile screen and conditionally navigates to the home screen based on a check.
```

---

### Task 6: Implement authentication flow

**Explanation:**
Implementing an authentication flow involves creating a series of screens and logic to handle user authentication. This typically includes login, signup, and password recovery screens, as well as logic for handling authentication tokens and redirecting users based on their authentication status. A well-designed authentication flow ensures that only authorized users can access certain parts of the application.

Implementing authentication flow is essential for securing your application and protecting sensitive data. It provides a way to manage user access, enhance security, and improve the user experience by ensuring that users are authenticated before accessing protected screens.

**Resources:**
- [React Navigation: Authentication Flows](https://reactnavigation.org/docs/auth-flow/)
- [Medium: Implementing Authentication in React Native](https://medium.com/react-native-training/implementing-authentication-in-react-native-2034db8a5c4b)

**Example 1:**
```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, Button, ActivityIndicator } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const Stack = createStackNavigator();

function AuthLoadingScreen({ navigation }) {
  useEffect(() => {
    // Check if user is authenticated
    const isAuthenticated = false; // Replace with your auth logic
    navigation.navigate(isAuthenticated ? 'App' : 'Auth');
  }, [navigation]);

  return (
    <View>
      <ActivityIndicator />
    </View>
  );
}

function SignInScreen({ navigation }) {
  return (
    <View>
      <Text>Sign In Screen</Text>
      <Button title="Sign In" onPress={() => navigation.navigate('App')} />
    </View>
  );
}

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="AuthLoading" component={AuthLoadingScreen} />
        <Stack.Screen name="SignIn" component={SignInScreen} />
        <Stack.Screen name="Home" component={HomeScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing a basic authentication flow with an `AuthLoadingScreen` to check if the user is authenticated, a `SignInScreen` for user login, and a `HomeScreen` for authenticated users.

**Example 2:**
```javascript
import React, { useState, useEffect } from 'react';
import { View, Text, Button, ActivityIndicator } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import AsyncStorage from '@react-native-async-storage/async-storage';

const Stack = createStackNavigator();

function AuthLoadingScreen({ navigation }) {
  useEffect(() => {
    const checkAuth = async () => {
      const userToken = await AsyncStorage.getItem('userToken');
      navigation.navigate(userToken ? 'App' : 'Auth');
    };

    checkAuth();
  }, [navigation]);

  return (
    <View>
      <ActivityIndicator />
    </View>
  );
}

function SignInScreen({ navigation }) {
  const signIn = async () => {
    await AsyncStorage.setItem('userToken', 'abc123');
    navigation.navigate('App');
  };

  return (
    <View>
      <Text>Sign In Screen</Text>
      <Button title="Sign In" onPress={signIn} />
    </View>
  );
}

function HomeScreen() {
  return (
    <View>
      <Text>Home Screen</Text>
    </View>
  );
}

export default function App() {
  return (
    <NavigationContainer>
      <Stack.Navigator>
        <Stack.Screen name="AuthLoading" component={AuthLoadingScreen} />
        <Stack.Screen name="SignIn" component={SignInScreen} />
        <Stack.Screen name="Home" component={HomeScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}
```

**Example Explanation:**
This example demonstrates implementing an authentication flow using `AsyncStorage` to store the user token. The `AuthLoadingScreen` checks for the token, and the `SignInScreen` sets the token upon successful login.

**Resources:**
- [W3Schools: Authentication Flow in React Native](https://www.w3schools.com/react/react_native_authentication_flow.asp)
- [FreeCodeCamp: Building Authentication in React Native](https://www.freecodecamp.org/news/react-native-authentication-flow/)

**Expected Output:**
For Example 1:
```
Implements a basic authentication flow with loading, sign-in, and home screens.
```
For Example 2:
```
Implements an authentication flow using AsyncStorage to store and check user tokens.
```

---

### Task 7: Study authentication methods

**Explanation:**
Authentication methods refer to the various ways users can be authenticated in an application. Common methods include email and password authentication, social login (OAuth), and biometric authentication (fingerprint, face recognition). Each method has its own set of benefits and use cases, and selecting the right method depends on the application's requirements.

Studying authentication methods is essential for implementing secure and user-friendly authentication in your application. It helps you choose the most appropriate method for your use case and ensures that user data is protected while providing a seamless login experience.

**Resources:**
- [Auth0: Authentication Methods](https://auth0.com/docs/authentication)
- [Okta: Authentication Overview](https://developer.okta.com/docs/concepts/authentication/)

**Example 1:**
```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, Button } from 'react-native';

function EmailPasswordAuth({ navigation }) {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const signIn = () => {
    // Perform email and password authentication
    console.log('Email:', email);
    console.log('Password:', password);
    navigation.navigate('Home');
  };

  return (
    <View>
      <Text>Email and Password Authentication</Text>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <Button title="Sign In" onPress={signIn} />
    </View>
  );
}

export default EmailPasswordAuth;
```

**Example Explanation:**
This example demonstrates implementing email and password authentication. The `EmailPasswordAuth` component includes text inputs for the email and password, and a button to perform the sign-in action.

**Example 2:**
```javascript
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import * as GoogleSignIn from 'expo-google-sign-in';

function GoogleAuth({ navigation }) {
  const [user, setUser] = useState(null);

  const signInWithGoogle = async () => {
    try {
      await GoogleSignIn.initAsync();
      const result = await GoogleSignIn.signInAsync();
      if (result.type === 'success') {
        setUser(result.user);
        navigation.navigate('Home');
      }
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View>
      <Text>Google Authentication</Text>
      <Button title="Sign In with Google" onPress={signInWithGoogle} />
      {user && <Text>Welcome, {user.name}</Text>}
    </View>
  );
}

export default GoogleAuth;
```

**Example Explanation:**
This example demonstrates implementing Google authentication using `expo-google-sign-in`. The `GoogleAuth` component includes a button to initiate the Google sign-in process and displays the user's name upon successful authentication.

**Resources:**
- [W3Schools: Authentication Methods in React Native](

https://www.w3schools.com/react/react_native_authentication_methods.asp)
- [FreeCodeCamp: Implementing Authentication Methods in React Native](https://www.freecodecamp.org/news/react-native-authentication-methods/)

**Expected Output:**
For Example 1:
```
Implements email and password authentication with text inputs and a sign-in button.
```
For Example 2:
```
Implements Google authentication with a sign-in button and displays the user's name upon successful authentication.
```

---

### Task 8: Use Firebase for authentication

**Explanation:**
Firebase provides a comprehensive authentication solution that supports multiple authentication methods, including email and password, phone authentication, and social login (Google, Facebook, etc.). Firebase Authentication is easy to integrate with React Native and offers a secure and scalable way to manage user authentication.

Using Firebase for authentication is essential for building secure and reliable authentication systems in your application. It simplifies the implementation process, provides built-in security features, and supports a wide range of authentication methods.

**Resources:**
- [Firebase Documentation: Authentication](https://firebase.google.com/docs/auth)
- [React Native Firebase Documentation: Authentication](https://rnfirebase.io/auth/usage)

**Example 1:**
```javascript
import React, { useState } from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import auth from '@react-native-firebase/auth';

function FirebaseEmailPasswordAuth() {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const signIn = async () => {
    try {
      await auth().signInWithEmailAndPassword(email, password);
      console.log('User signed in!');
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View>
      <Text>Email and Password Authentication with Firebase</Text>
      <TextInput
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <Button title="Sign In" onPress={signIn} />
    </View>
  );
}

export default FirebaseEmailPasswordAuth;
```

**Example Explanation:**
This example demonstrates implementing email and password authentication using Firebase. The `FirebaseEmailPasswordAuth` component includes text inputs for the email and password, and a button to perform the sign-in action using Firebase Authentication.

**Example 2:**
```javascript
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import auth from '@react-native-firebase/auth';

function FirebaseGoogleAuth() {
  const [user, setUser] = useState(null);

  const signInWithGoogle = async () => {
    try {
      // TODO: Add Google sign-in logic using Firebase
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View>
      <Text>Google Authentication with Firebase</Text>
      <Button title="Sign In with Google" onPress={signInWithGoogle} />
      {user && <Text>Welcome, {user.displayName}</Text>}
    </View>
  );
}

export default FirebaseGoogleAuth;
```

**Example Explanation:**
This example demonstrates implementing Google authentication using Firebase. The `FirebaseGoogleAuth` component includes a button to initiate the Google sign-in process using Firebase Authentication and displays the user's name upon successful authentication.

**Resources:**
- [W3Schools: Firebase Authentication in React Native](https://www.w3schools.com/react/react_native_firebase_authentication.asp)
- [FreeCodeCamp: Implementing Firebase Authentication in React Native](https://www.freecodecamp.org/news/react-native-firebase-authentication/)

**Expected Output:**
For Example 1:
```
Implements email and password authentication using Firebase with text inputs and a sign-in button.
```
For Example 2:
```
Implements Google authentication using Firebase with a sign-in button and displays the user's name upon successful authentication.
```

---

### Task 9: Implement OAuth with third-party services

**Explanation:**
OAuth (Open Authorization) is a protocol that allows users to grant third-party applications access to their resources without sharing their credentials. In React Native, OAuth can be used for social login (e.g., Google, Facebook) to authenticate users. Implementing OAuth involves using libraries like `react-native-app-auth` or `expo-auth-session`.

Implementing OAuth with third-party services is essential for providing a seamless and secure authentication experience. It allows users to sign in with their existing social accounts, reducing friction and enhancing the user experience.

**Resources:**
- [OAuth.net: OAuth 2.0](https://oauth.net/2/)
- [React Native App Auth Documentation](https://github.com/FormidableLabs/react-native-app-auth)

**Example 1:**
```javascript
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import { authorize } from 'react-native-app-auth';

const config = {
  issuer: 'https://accounts.google.com',
  clientId: 'YOUR_GOOGLE_CLIENT_ID',
  redirectUrl: 'com.yourapp:/oauth2redirect/google',
  scopes: ['openid', 'profile', 'email'],
};

function GoogleOAuth() {
  const [user, setUser] = useState(null);

  const signInWithGoogle = async () => {
    try {
      const result = await authorize(config);
      setUser(result);
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View>
      <Text>Google OAuth</Text>
      <Button title="Sign In with Google" onPress={signInWithGoogle} />
      {user && <Text>Welcome, {user.idToken}</Text>}
    </View>
  );
}

export default GoogleOAuth;
```

**Example Explanation:**
This example demonstrates implementing Google OAuth using `react-native-app-auth`. The `GoogleOAuth` component includes a button to initiate the Google sign-in process and displays the user's ID token upon successful authentication.

**Example 2:**
```javascript
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import * as AuthSession from 'expo-auth-session';

const config = {
  issuer: 'https://accounts.google.com',
  clientId: 'YOUR_GOOGLE_CLIENT_ID',
  redirectUrl: AuthSession.makeRedirectUri({ useProxy: true }),
  scopes: ['openid', 'profile', 'email'],
};

function GoogleOAuthExpo() {
  const [user, setUser] = useState(null);

  const signInWithGoogle = async () => {
    const authUrl = `${config.issuer}/o/oauth2/v2/auth?response_type=token&client_id=${config.clientId}&redirect_uri=${config.redirectUrl}&scope=${config.scopes.join(' ')}`;
    const result = await AuthSession.startAsync({ authUrl });

    if (result.type === 'success') {
      setUser(result.params);
    }
  };

  return (
    <View>
      <Text>Google OAuth with Expo</Text>
      <Button title="Sign In with Google" onPress={signInWithGoogle} />
      {user && <Text>Welcome, {user.access_token}</Text>}
    </View>
  );
}

export default GoogleOAuthExpo;
```

**Example Explanation:**
This example demonstrates implementing Google OAuth using `expo-auth-session`. The `GoogleOAuthExpo` component includes a button to initiate the Google sign-in process and displays the user's access token upon successful authentication.

**Resources:**
- [W3Schools: OAuth in React Native](https://www.w3schools.com/react/react_native_oauth.asp)
- [FreeCodeCamp: Implementing OAuth in React Native](https://www.freecodecamp.org/news/react-native-oauth/)

**Expected Output:**
For Example 1:
```
Implements Google OAuth using react-native-app-auth with a sign-in button and displays the user's ID token upon successful authentication.
```
For Example 2:
```
Implements Google OAuth using expo-auth-session with a sign-in button and displays the user's access token upon successful authentication.
```

---

### Task 10: Study form libraries (Formik)

**Explanation:**
Formik is a popular form library for React and React Native that simplifies form management, validation, and submission. It provides a set of components and hooks for handling form state, validation, and submission logic. Formik integrates well with Yup, a schema validation library, for handling complex form validations.

Studying Formik is essential for building robust and user-friendly forms in your application. It helps manage form state efficiently, reduces boilerplate code, and provides a consistent way to handle form validation and submission.

**Resources:**
- [Formik Documentation](https://formik.org/docs/overview)
- [Yup Documentation](https://github.com/jquense/yup)

**Example 1:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik } from 'formik';

function SimpleForm() {
  return (
    <Formik
      initialValues={{ email: '' }}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values }) => (
        <View>
          <Text>Email</Text>
          <TextInput
            onChangeText={handleChange('email')}
            onBlur={handleBlur('email')}
            value={values.email}
          />
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default SimpleForm;
```

**Example

 Explanation:**
This example demonstrates a simple form using Formik. The `SimpleForm` component initializes form state with `initialValues` and handles form submission with `handleSubmit`. The form includes a text input for the email and a submit button.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  email: Yup.string().email('Invalid email').required('Required'),
});

function ValidatedForm() {
  return (
    <Formik
      initialValues={{ email: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors }) => (
        <View>
          <Text>Email</Text>
          <TextInput
            onChangeText={handleChange('email')}
            onBlur={handleBlur('email')}
            value={values.email}
          />
          {errors.email && <Text>{errors.email}</Text>}
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default ValidatedForm;
```

**Example Explanation:**
This example demonstrates a form with validation using Formik and Yup. The `ValidatedForm` component initializes form state with `initialValues`, validates the email field using `Yup`, and handles form submission with `handleSubmit`. The form includes a text input for the email, a submit button, and error messages for validation.

**Resources:**
- [W3Schools: Formik in React Native](https://www.w3schools.com/react/react_native_formik.asp)
- [FreeCodeCamp: Using Formik in React Native](https://www.freecodecamp.org/news/react-native-formik/)

**Expected Output:**
For Example 1:
```
Implements a simple form using Formik with a text input for the email and a submit button.
```
For Example 2:
```
Implements a form with validation using Formik and Yup, including a text input for the email, a submit button, and error messages for validation.
```

---

### Task 11: Use Formik for complex forms

**Explanation:**
Formik simplifies the process of building and managing complex forms in React Native. It provides tools for handling form state, validation, and submission, making it easier to create forms with multiple fields, nested values, and advanced validation logic. Formik's integration with Yup allows for powerful schema-based validation.

Using Formik for complex forms is essential for creating user-friendly and robust forms. It helps manage form state efficiently, reduces boilerplate code, and ensures that forms are validated and submitted correctly.

**Resources:**
- [Formik Documentation: Complex Forms](https://formik.org/docs/guides/arrays)
- [Yup Documentation: Schema Validation](https://github.com/jquense/yup)

**Example 1:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik, FieldArray } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  friends: Yup.array().of(
    Yup.object().shape({
      name: Yup.string().required('Required'),
    })
  ),
});

function ComplexForm() {
  return (
    <Formik
      initialValues={{ friends: [{ name: '' }] }}
      validationSchema={validationSchema}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors }) => (
        <View>
          <FieldArray
            name="friends"
            render={(arrayHelpers) => (
              <View>
                {values.friends.map((friend, index) => (
                  <View key={index}>
                    <Text>Friend {index + 1}</Text>
                    <TextInput
                      onChangeText={handleChange(`friends[${index}].name`)}
                      onBlur={handleBlur(`friends[${index}].name`)}
                      value={friend.name}
                    />
                    {errors.friends && errors.friends[index] && (
                      <Text>{errors.friends[index].name}</Text>
                    )}
                    <Button
                      title="Remove"
                      onPress={() => arrayHelpers.remove(index)}
                    />
                  </View>
                ))}
                <Button
                  title="Add Friend"
                  onPress={() => arrayHelpers.push({ name: '' })}
                />
              </View>
            )}
          />
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default ComplexForm;
```

**Example Explanation:**
This example demonstrates a complex form using Formik with a dynamic list of friends. The `ComplexForm` component initializes form state with an array of friends, validates each friend's name using Yup, and handles form submission with `handleSubmit`. The form includes text inputs for each friend's name, buttons to add and remove friends, and a submit button.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik, FieldArray } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  user: Yup.object().shape({
    name: Yup.string().required('Required'),
    email: Yup.string().email('Invalid email').required('Required'),
    addresses: Yup.array().of(
      Yup.object().shape({
        street: Yup.string().required('Required'),
      })
    ),
  }),
});

function NestedForm() {
  return (
    <Formik
      initialValues={{ user: { name: '', email: '', addresses: [{ street: '' }] } }}
      validationSchema={validationSchema}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors }) => (
        <View>
          <Text>Name</Text>
          <TextInput
            onChangeText={handleChange('user.name')}
            onBlur={handleBlur('user.name')}
            value={values.user.name}
          />
          {errors.user && errors.user.name && <Text>{errors.user.name}</Text>}
          <Text>Email</Text>
          <TextInput
            onChangeText={handleChange('user.email')}
            onBlur={handleBlur('user.email')}
            value={values.user.email}
          />
          {errors.user && errors.user.email && <Text>{errors.user.email}</Text>}
          <FieldArray
            name="user.addresses"
            render={(arrayHelpers) => (
              <View>
                {values.user.addresses.map((address, index) => (
                  <View key={index}>
                    <Text>Address {index + 1}</Text>
                    <TextInput
                      onChangeText={handleChange(`user.addresses[${index}].street`)}
                      onBlur={handleBlur(`user.addresses[${index}].street`)}
                      value={address.street}
                    />
                    {errors.user && errors.user.addresses && errors.user.addresses[index] && (
                      <Text>{errors.user.addresses[index].street}</Text>
                    )}
                    <Button
                      title="Remove"
                      onPress={() => arrayHelpers.remove(index)}
                    />
                  </View>
                ))}
                <Button
                  title="Add Address"
                  onPress={() => arrayHelpers.push({ street: '' })}
                />
              </View>
            )}
          />
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default NestedForm;
```

**Example Explanation:**
This example demonstrates a nested form using Formik with a dynamic list of addresses. The `NestedForm` component initializes form state with a nested user object, validates each field using Yup, and handles form submission with `handleSubmit`. The form includes text inputs for the user's name, email, and addresses, buttons to add and remove addresses, and a submit button.

**Resources:**
- [W3Schools: Complex Forms with Formik](https://www.w3schools.com/react/react_native_formik_complex.asp)
- [FreeCodeCamp: Building Complex Forms with Formik in React Native](https://www.freecodecamp.org/news/react-native-formik-complex-forms/)

**Expected Output:**
For Example 1:
```
Implements a complex form with a dynamic list of friends using Formik and Yup.
```
For Example 2:
```
Implements a nested form with a dynamic list of addresses using Formik and Yup.
```

---

### Task 12: Validate forms with Yup

**Explanation:**
Yup is a JavaScript schema validation library that works seamlessly with Formik to validate form inputs. Yup allows you to define validation schemas using a simple and intuitive API, supporting complex validation logic, including nested objects and arrays, custom validation methods, and conditional validation.

Validating forms with Yup is essential for ensuring that user inputs are correct and meet the application's requirements. It provides a powerful and flexible way to handle form validation, improving the user experience by providing real-time feedback on input errors.

**Resources:**
- [Yup Documentation](https://github.com/jquense/yup)
- [Formik Documentation: Yup Schema Validation](https://formik.org/docs/guides/validation)

**Example 1:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().

shape({
  email: Yup.string().email('Invalid email').required('Required'),
  password: Yup.string().min(6, 'Password too short').required('Required'),
});

function SimpleValidationForm() {
  return (
    <Formik
      initialValues={{ email: '', password: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors }) => (
        <View>
          <Text>Email</Text>
          <TextInput
            onChangeText={handleChange('email')}
            onBlur={handleBlur('email')}
            value={values.email}
          />
          {errors.email && <Text>{errors.email}</Text>}
          <Text>Password</Text>
          <TextInput
            onChangeText={handleChange('password')}
            onBlur={handleBlur('password')}
            value={values.password}
            secureTextEntry
          />
          {errors.password && <Text>{errors.password}</Text>}
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default SimpleValidationForm;
```

**Example Explanation:**
This example demonstrates a simple form with validation using Formik and Yup. The `SimpleValidationForm` component initializes form state with email and password fields, validates the inputs using Yup, and handles form submission with `handleSubmit`. The form includes text inputs for the email and password, a submit button, and error messages for validation.

**Example 2:**
```javascript
import React from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { Formik } from 'formik';
import * as Yup from 'yup';

const validationSchema = Yup.object().shape({
  name: Yup.string().required('Required'),
  age: Yup.number().min(18, 'Must be 18 or older').required('Required'),
});

function ProfileForm() {
  return (
    <Formik
      initialValues={{ name: '', age: '' }}
      validationSchema={validationSchema}
      onSubmit={(values) => console.log(values)}
    >
      {({ handleChange, handleBlur, handleSubmit, values, errors }) => (
        <View>
          <Text>Name</Text>
          <TextInput
            onChangeText={handleChange('name')}
            onBlur={handleBlur('name')}
            value={values.name}
          />
          {errors.name && <Text>{errors.name}</Text>}
          <Text>Age</Text>
          <TextInput
            onChangeText={handleChange('age')}
            onBlur={handleBlur('age')}
            value={values.age}
            keyboardType="numeric"
          />
          {errors.age && <Text>{errors.age}</Text>}
          <Button onPress={handleSubmit} title="Submit" />
        </View>
      )}
    </Formik>
  );
}

export default ProfileForm;
```

**Example Explanation:**
This example demonstrates a form with validation using Formik and Yup. The `ProfileForm` component initializes form state with name and age fields, validates the inputs using Yup, and handles form submission with `handleSubmit`. The form includes text inputs for the name and age, a submit button, and error messages for validation.

**Resources:**
- [W3Schools: Validating Forms with Yup](https://www.w3schools.com/react/react_native_formik_yup.asp)
- [FreeCodeCamp: Form Validation with Formik and Yup in React Native](https://www.freecodecamp.org/news/react-native-formik-yup-validation/)

**Expected Output:**
For Example 1:
```
Implements a simple form with validation using Formik and Yup, including text inputs for the email and password, a submit button, and error messages for validation.
```
For Example 2:
```
Implements a form with validation using Formik and Yup, including text inputs for the name and age, a submit button, and error messages for validation.
```

---

### Task 13: Learn about testing in React Native

**Explanation:**
Testing in React Native involves writing and running tests to ensure that your components and application logic work as expected. Common types of tests include unit tests, integration tests, and end-to-end (E2E) tests. Testing helps catch bugs early, improve code quality, and ensure that your application behaves correctly across different scenarios.

Learning about testing in React Native is essential for building reliable and maintainable applications. It helps ensure that your code works as intended, reduces the risk of regressions, and provides confidence when making changes to your codebase.

**Resources:**
- [React Native Testing Library Documentation](https://github.com/callstack/react-native-testing-library)
- [Jest Documentation](https://jestjs.io/docs/en/tutorial-react-native)

**Example 1:**
```javascript
import React from 'react';
import { render } from '@testing-library/react-native';
import { Text } from 'react-native';

function Greeting({ name }) {
  return <Text>Hello, {name}!</Text>;
}

test('renders the correct greeting', () => {
  const { getByText } = render(<Greeting name="John" />);
  expect(getByText('Hello, John!')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates a simple unit test using Jest and React Native Testing Library. The `Greeting` component renders a greeting message, and the test verifies that the correct message is rendered.

**Example 2:**
```javascript
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { Button, Text } from 'react-native';

function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
}

test('increments the counter', () => {
  const { getByText } = render(<Counter />);
  fireEvent.press(getByText('Increment'));
  expect(getByText('Count: 1')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates a unit test for a `Counter` component. The test verifies that the counter is incremented when the button is pressed.

**Resources:**
- [W3Schools: Testing in React Native](https://www.w3schools.com/react/react_native_testing.asp)
- [FreeCodeCamp: Testing React Native Apps](https://www.freecodecamp.org/news/testing-react-native-apps/)

**Expected Output:**
For Example 1:
```
Verifies that the Greeting component renders the correct greeting message.
```
For Example 2:
```
Verifies that the Counter component increments the counter when the button is pressed.
```

---

### Task 14: Set up testing environment

**Explanation:**
Setting up a testing environment in React Native involves configuring tools and libraries such as Jest, React Native Testing Library, and Babel to enable testing capabilities. This setup allows you to write and run tests, ensuring that your components and application logic work as expected.

Setting up a testing environment is essential for developing reliable and maintainable applications. It provides the necessary infrastructure to write and run tests, helping catch bugs early and improve code quality.

**Resources:**
- [Jest Documentation: Getting Started](https://jestjs.io/docs/en/getting-started)
- [React Native Testing Library Documentation: Getting Started](https://github.com/callstack/react-native-testing-library#installation)

**Example 1:**
```bash
# Install dependencies
npm install --save-dev jest @testing-library/react-native @testing-library/jest-native babel-jest @babel/preset-env @babel/preset-react @babel/preset-flow
```

**Example 2:**
```json
// Add to package.json
{
  "scripts": {
    "test": "jest"
  },
  "jest": {
    "preset": "react-native",
    "setupFilesAfterEnv": ["@testing-library/jest-native/extend-expect"]
  }
}
```

**Example Explanation:**
These examples demonstrate installing testing dependencies and configuring Jest for a React Native project. The first example shows the command to install the necessary dependencies, and the second example shows how to configure Jest in the `package.json` file.

**Resources:**
- [W3Schools: Setting Up Testing Environment in React Native](https://www.w3schools.com/react/react_native_testing_setup.asp)
- [FreeCodeCamp: Setting Up Jest in React Native](https://www.freecodecamp.org/news/setting-up-jest-in-react-native/)

**Expected Output:**
For Example 1:
```
Installs the necessary dependencies for testing in a React Native project.
```
For Example 2:
```
Configures Jest for a React Native project in the package.json file.
```

---

### Task 15: Write unit tests with Jest

**Explanation:**
Unit tests are tests that verify the functionality of individual components or functions in isolation. Jest is a popular testing framework for JavaScript that provides a simple and powerful way to write and run unit tests. Jest integrates well with React Native and supports features like snapshot testing, mocking, and code coverage.

Writing unit tests with Jest is essential for ensuring that your components and functions work correctly. It helps catch bugs early, improve code quality, and provides confidence when making changes to your codebase.

**Resources:**
- [Jest Documentation: Unit Testing](https://jestjs.io/docs/en/getting-started)
- [React Native Testing Library Documentation: Unit Testing](https://github.com/callstack/react-native-testing-library)

**Example 1:**
```javascript
import React from 'react';
import { render } from '@testing-library/react

-native';
import { Text } from 'react-native';

function Greeting({ name }) {
  return <Text>Hello, {name}!</Text>;
}

test('renders the correct greeting', () => {
  const { getByText } = render(<Greeting name="John" />);
  expect(getByText('Hello, John!')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates a simple unit test using Jest and React Native Testing Library. The `Greeting` component renders a greeting message, and the test verifies that the correct message is rendered.

**Example 2:**
```javascript
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { Button, Text } from 'react-native';

function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
}

test('increments the counter', () => {
  const { getByText } = render(<Counter />);
  fireEvent.press(getByText('Increment'));
  expect(getByText('Count: 1')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates a unit test for a `Counter` component. The test verifies that the counter is incremented when the button is pressed.

**Resources:**
- [W3Schools: Writing Unit Tests with Jest](https://www.w3schools.com/react/react_native_unit_tests.asp)
- [FreeCodeCamp: Writing Unit Tests in React Native](https://www.freecodecamp.org/news/react-native-unit-testing/)

**Expected Output:**
For Example 1:
```
Verifies that the Greeting component renders the correct greeting message.
```
For Example 2:
```
Verifies that the Counter component increments the counter when the button is pressed.
```

---

### Task 16: Test components with React Native Testing Library

**Explanation:**
React Native Testing Library provides a set of tools for testing React Native components in a way that resembles how users interact with them. It focuses on testing components from the user's perspective, ensuring that they behave correctly and render the expected output. This library integrates well with Jest and provides utilities for rendering components, querying elements, and simulating user interactions.

Testing components with React Native Testing Library is essential for ensuring that your components work as expected in real-world scenarios. It helps catch bugs, improve code quality, and provides confidence that your components behave correctly.

**Resources:**
- [React Native Testing Library Documentation](https://github.com/callstack/react-native-testing-library)
- [Jest Documentation: Testing React Native Components](https://jestjs.io/docs/en/tutorial-react-native)

**Example 1:**
```javascript
import React from 'react';
import { render } from '@testing-library/react-native';
import { Text } from 'react-native';

function Greeting({ name }) {
  return <Text>Hello, {name}!</Text>;
}

test('renders the correct greeting', () => {
  const { getByText } = render(<Greeting name="John" />);
  expect(getByText('Hello, John!')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates testing a `Greeting` component with React Native Testing Library. The test verifies that the correct greeting message is rendered based on the `name` prop.

**Example 2:**
```javascript
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import { Button, Text } from 'react-native';

function Counter() {
  const [count, setCount] = React.useState(0);

  return (
    <View>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
}

test('increments the counter', () => {
  const { getByText } = render(<Counter />);
  fireEvent.press(getByText('Increment'));
  expect(getByText('Count: 1')).toBeTruthy();
});
```

**Example Explanation:**
This example demonstrates testing a `Counter` component with React Native Testing Library. The test verifies that the counter is incremented when the button is pressed.

**Resources:**
- [W3Schools: Testing Components with React Native Testing Library](https://www.w3schools.com/react/react_native_testing_library.asp)
- [FreeCodeCamp: Testing React Native Components](https://www.freecodecamp.org/news/react-native-component-testing/)

**Expected Output:**
For Example 1:
```
Verifies that the Greeting component renders the correct greeting message.
```
For Example 2:
```
Verifies that the Counter component increments the counter when the button is pressed.
```

---

### Task 17: Learn about E2E testing

**Explanation:**
End-to-end (E2E) testing involves testing an application from start to finish to ensure that it behaves correctly in a real-world scenario. E2E tests simulate user interactions and verify that the application works as expected across different devices and environments. Detox is a popular E2E testing framework for React Native that provides tools for writing and running E2E tests.

Learning about E2E testing is essential for ensuring that your application works correctly in production. It helps catch integration issues, improve code quality, and provide confidence that your application behaves as expected in real-world scenarios.

**Resources:**
- [Detox Documentation](https://wix.github.io/Detox/docs/introduction/getting-started/)
- [Medium: End-to-End Testing in React Native](https://medium.com/react-native-training/end-to-end-testing-in-react-native-4c5e24b54b24)

**Example 1:**
```bash
# Install Detox CLI and dependencies
npm install -g detox-cli
npm install detox --save-dev
detox init -r jest
```

**Example 2:**
```javascript
describe('Example', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should have welcome screen', async () => {
    await expect(element(by.id('welcome'))).toBeVisible();
  });

  it('should navigate to home screen after tap', async () => {
    await element(by.id('welcome-button')).tap();
    await expect(element(by.id('home'))).toBeVisible();
  });
});
```

**Example Explanation:**
These examples demonstrate setting up Detox and writing a basic E2E test. The first example shows the command to install Detox and initialize it with Jest. The second example shows an E2E test that verifies the visibility of elements and simulates a button tap to navigate to a different screen.

**Resources:**
- [W3Schools: E2E Testing in React Native](https://www.w3schools.com/react/react_native_e2e_testing.asp)
- [FreeCodeCamp: End-to-End Testing in React Native with Detox](https://www.freecodecamp.org/news/react-native-e2e-testing-detox/)

**Expected Output:**
For Example 1:
```
Installs Detox CLI and dependencies, and initializes Detox with Jest.
```
For Example 2:
```
Verifies the visibility of elements and simulates a button tap to navigate to a different screen using Detox.
```

---

### Task 18: Use Detox for E2E tests

**Explanation:**
Detox is an end-to-end (E2E) testing framework for React Native that allows you to write and run tests simulating real user interactions. Detox provides tools for launching the application, interacting with elements, and verifying the application's behavior. It supports testing on both iOS and Android devices and emulators.

Using Detox for E2E tests is essential for ensuring that your application works correctly in real-world scenarios. It helps catch integration issues, improve code quality, and provide confidence that your application behaves as expected.

**Resources:**
- [Detox Documentation](https://wix.github.io/Detox/docs/introduction/getting-started/)
- [React Native Testing Library: E2E Testing with Detox](https://github.com/callstack/react-native-testing-library/blob/master/docs/E2E.md)

**Example 1:**
```bash
# Install Detox CLI and dependencies
npm install -g detox-cli
npm install detox --save-dev
detox init -r jest
```

**Example 2:**
```javascript
describe('Example', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should have welcome screen', async () => {
    await expect(element(by.id('welcome'))).toBeVisible();
  });

  it('should navigate to home screen after tap', async () => {
    await element(by.id('welcome-button')).tap();
    await expect(element(by.id('home'))).toBeVisible();
  });
});
```

**Example Explanation:**
These examples demonstrate setting up Detox and writing a basic E2E test. The first example shows the command to install Detox and initialize it with Jest. The second example shows an E2E test that verifies the visibility of elements and simulates a button tap to navigate to a different screen.

**Resources:**
- [W3Schools: Detox for E2E Testing](https://www.w3schools.com/react/react_native_detox.asp)
- [FreeCodeCamp: End-to-End Testing in React Native with Detox](https://www.freecodecamp.org/news/react-native-e2e-testing-detox/)

**Expected Output:**
For Example 1:
```
Installs Detox CLI and dependencies, and initializes Detox with Jest.
```
For Example 2:
```
Verifies the visibility of elements and simulates a button tap to navigate to a different screen using Detox.
```

---



### Task 19: Study debugging techniques

**Explanation:**
Debugging is the process of identifying and resolving issues in your application. In React Native, common debugging techniques include using the Chrome DevTools, React Native Debugger, and Flipper. These tools provide features like breakpoints, step-through debugging, network inspection, and performance monitoring.

Studying debugging techniques is essential for efficiently identifying and fixing issues in your application. It helps improve code quality, enhance performance, and ensure that your application behaves as expected.

**Resources:**
- [React Native Debugging Documentation](https://reactnative.dev/docs/debugging)
- [Flipper Documentation](https://fbflipper.com/docs/features/react-native/)

**Example 1:**
```bash
# Start React Native Debugger
react-native start
```

**Example 2:**
```javascript
// Debugging with console.log
console.log('Debugging message');
```

**Example Explanation:**
These examples demonstrate starting the React Native Debugger and using `console.log` for debugging. The first example shows the command to start the debugger, and the second example shows how to use `console.log` to print debugging messages.

**Resources:**
- [W3Schools: Debugging React Native](https://www.w3schools.com/react/react_native_debugging.asp)
- [FreeCodeCamp: Debugging Techniques in React Native](https://www.freecodecamp.org/news/debugging-react-native/)

**Expected Output:**
For Example 1:
```
Starts the React Native Debugger.
```
For Example 2:
```
Prints debugging messages using console.log.
```

---

### Task 20: Use React Native Debugger and Flipper

**Explanation:**
React Native Debugger is a standalone tool that combines the Chrome DevTools, Redux DevTools, and React DevTools in a single app. Flipper is a platform for debugging mobile apps that integrates with React Native to provide tools for inspecting elements, monitoring network requests, and viewing logs.

Using React Native Debugger and Flipper is essential for efficiently debugging your application. These tools provide powerful features for inspecting and diagnosing issues, improving code quality, and ensuring that your application behaves as expected.

**Resources:**
- [React Native Debugger Documentation](https://github.com/jhen0409/react-native-debugger)
- [Flipper Documentation](https://fbflipper.com/docs/features/react-native/)

**Example 1:**
```bash
# Install React Native Debugger
brew install --cask react-native-debugger

# Open React Native Debugger
open "rndebugger://set-debugger-loc?port=8081"
```

**Example 2:**
```bash
# Install Flipper
brew install --cask flipper

# Start Flipper
flipper
```

**Example Explanation:**
These examples demonstrate installing and starting React Native Debugger and Flipper. The first example shows the command to install and open React Native Debugger, and the second example shows the command to install and start Flipper.

**Resources:**
- [W3Schools: React Native Debugger](https://www.w3schools.com/react/react_native_debugger.asp)
- [FreeCodeCamp: Using Flipper with React Native](https://www.freecodecamp.org/news/react-native-flipper/)

**Expected Output:**
For Example 1:
```
Installs and opens React Native Debugger.
```
For Example 2:
```
Installs and starts Flipper.
```

---