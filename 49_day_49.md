## Task 1: Study Advanced State Management with Redux Saga

Redux Saga is a powerful middleware library that makes it easier to manage application side effects like asynchronous operations and I/O handling in a Redux-based architecture. By leveraging generator functions, Redux Saga allows you to write complex async workflows in a more manageable and testable way. It provides a clear way to handle side effects by using `sagas`, which are JavaScript functions that can pause and resume their execution using `yield` expressions. This makes it ideal for handling scenarios like API calls, data fetching, and background processing, where you need to coordinate multiple asynchronous actions.

One of the key advantages of using Redux Saga over other middleware, such as Redux Thunk, is its ability to manage more complex workflows involving concurrent tasks, race conditions, and cancellation of ongoing operations. Redux Saga also improves code readability and maintainability by isolating side effects from the rest of your Redux code, leading to a more predictable state management system. This separation of concerns not only makes your codebase easier to understand but also simplifies testing, as you can test your sagas in isolation without needing to mock network requests or other asynchronous operations.

### Online Resources

1. [Redux Saga Official Documentation](https://redux-saga.js.org/)
2. [Introduction to Redux Saga](https://redux.js.org/advanced/async-flow)

### Examples to Practice

#### Example 1: Fetching Data from an API

##### Paragraph 1
In this example, you will create a simple saga to handle fetching data from an API. This involves setting up actions, a reducer, and a saga that listens for a specific action to trigger the API call. When the API call is successful, the saga will dispatch a success action to update the Redux store with the fetched data. If the API call fails, the saga will dispatch a failure action.

##### Paragraph 2
The purpose of this example is to understand how to orchestrate side effects using Redux Saga, manage asynchronous data fetching, and handle success and error scenarios effectively. This foundational practice will help you build more complex sagas that involve multiple API calls or other side effects.

##### Example Code
```javascript
// actions.js
export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';
export const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';
export const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';

export const fetchDataRequest = () => ({ type: FETCH_DATA_REQUEST });
export const fetchDataSuccess = (data) => ({ type: FETCH_DATA_SUCCESS, payload: data });
export const fetchDataFailure = (error) => ({ type: FETCH_DATA_FAILURE, payload: error });

// reducer.js
const initialState = {
  data: [],
  loading: false,
  error: null,
};

export const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_DATA_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_DATA_SUCCESS:
      return { ...state, loading: false, data: action.payload };
    case FETCH_DATA_FAILURE:
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

// sagas.js
import { call, put, takeLatest } from 'redux-saga/effects';
import { FETCH_DATA_REQUEST, fetchDataSuccess, fetchDataFailure } from './actions';

function* fetchDataSaga() {
  try {
    const response = yield call(fetch, 'https://api.example.com/data');
    const data = yield response.json();
    yield put(fetchDataSuccess(data));
  } catch (error) {
    yield put(fetchDataFailure(error.message));
  }
}

export function* watchFetchData() {
  yield takeLatest(FETCH_DATA_REQUEST, fetchDataSaga);
}

// sagaMiddleware setup in store configuration
import createSagaMiddleware from 'redux-saga';
import { watchFetchData } from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(
  dataReducer,
  applyMiddleware(sagaMiddleware)
);
sagaMiddleware.run(watchFetchData);
```

##### Expected Output
When the `fetchDataRequest` action is dispatched, the saga will trigger an API call. If the call is successful, the Redux store will be updated with the fetched data, and the loading state will be set to false. If the call fails, the error message will be stored in the Redux state.

### Online Resources for Example 1

1. [Handling Actions in Redux Saga](https://redux-saga.js.org/docs/basics/HandlingActions.html)
2. [Testing Redux Saga](https://redux-saga.js.org/docs/advanced/Testing.html)

#### Example 2: User Authentication Flow

##### Paragraph 1
In this example, you will implement a user authentication flow using Redux Saga. This involves creating sagas to handle login, logout, and user session management. The sagas will coordinate the authentication process, including making API calls to authenticate the user and managing the session token in local storage.

##### Paragraph 2
This example is crucial for understanding how to manage authentication state in a React Native application using Redux Saga. It demonstrates how to handle side effects related to user authentication, such as persisting the session token and handling authentication errors, providing a secure and user-friendly authentication mechanism.

##### Example Code
```javascript
// authActions.js
export const LOGIN_REQUEST = 'LOGIN_REQUEST';
export const LOGIN_SUCCESS = 'LOGIN_SUCCESS';
export const LOGIN_FAILURE = 'LOGIN_FAILURE';
export const LOGOUT = 'LOGOUT';

export const loginRequest = (credentials) => ({ type: LOGIN_REQUEST, payload: credentials });
export const loginSuccess = (token) => ({ type: LOGIN_SUCCESS, payload: token });
export const loginFailure = (error) => ({ type: LOGIN_FAILURE, payload: error });
export const logout = () => ({ type: LOGOUT });

// authReducer.js
const initialState = {
  token: null,
  loading: false,
  error: null,
};

export const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case LOGIN_REQUEST:
      return { ...state, loading: true, error: null };
    case LOGIN_SUCCESS:
      return { ...state, loading: false, token: action.payload };
    case LOGIN_FAILURE:
      return { ...state, loading: false, error: action.payload };
    case LOGOUT:
      return { ...state, token: null };
    default:
      return state;
  }
};

// authSagas.js
import { call, put, takeLatest } from 'redux-saga/effects';
import { LOGIN_REQUEST, loginSuccess, loginFailure, logout } from './authActions';

function* loginSaga(action) {
  try {
    const response = yield call(fetch, 'https://api.example.com/login', {
      method: 'POST',
      body: JSON.stringify(action.payload),
    });
    const data = yield response.json();
    if (data.token) {
      yield put(loginSuccess(data.token));
      localStorage.setItem('token', data.token);
    } else {
      yield put(loginFailure(data.error));
    }
  } catch (error) {
    yield put(loginFailure(error.message));
  }
}

function* logoutSaga() {
  yield call([localStorage, 'removeItem'], 'token');
}

export function* watchAuth() {
  yield takeLatest(LOGIN_REQUEST, loginSaga);
  yield takeLatest(LOGOUT, logoutSaga);
}

// sagaMiddleware setup in store configuration
import createSagaMiddleware from 'redux-saga';
import { watchAuth } from './authSagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(
  authReducer,
  applyMiddleware(sagaMiddleware)
);
sagaMiddleware.run(watchAuth);
```

##### Expected Output
When the `loginRequest` action is dispatched with user credentials, the saga will make an API call to authenticate the user. On success, the session token will be stored in the Redux state and local storage. If the authentication fails, the error message will be stored in the Redux state. The `logout` action will clear the session token from both the Redux state and local storage.

### Online Resources for Example 2

1. [Redux Saga Authentication Example](https://redux-saga.js.org/docs/advanced/ExampleSagaAuthentication.html)
2. [Managing Side Effects in Redux](https://redux.js.org/advanced/middleware)

#### Example 3: Handling Multiple API Requests

##### Paragraph 1
In this example, you will learn how to handle multiple concurrent API requests using Redux Saga. This involves creating sagas to manage multiple asynchronous operations, such as fetching user details and posts simultaneously. You will use the `all` and `call` effects to run these operations in parallel and wait for all of them to complete.

##### Paragraph 2
This example demonstrates the power of Redux Saga in coordinating complex asynchronous workflows. By managing multiple API requests concurrently, you can optimize your application's performance and ensure that all necessary data is available before rendering the user interface. This practice is essential for building responsive and efficient applications.

##### Example Code
```javascript
// multiApiActions.js
export const FETCH_USER_AND_POSTS_REQUEST = 'FETCH_USER_AND_POSTS_REQUEST';
export const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
export const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';
export const FETCH_FAILURE = 'FETCH_FAILURE';

export const fetchUserAndPostsRequest = () => ({ type: FETCH_USER_AND_POSTS_REQUEST });
export const fetchUserSuccess = (user) => ({ type: FETCH_USER_SUCCESS, payload: user });
export const fetchPostsSuccess = (posts) => ({ type: FETCH_POSTS_SUCCESS, payload: posts });
export const fetchFailure = (error) => ({ type: FETCH_FAILURE, payload: error });

// multiApiReducer.js
const initialState = {
  user: null,


  posts: [],
  loading: false,
  error: null,
};

export const multiApiReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_USER_AND_POSTS_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_USER_SUCCESS:
      return { ...state, loading: false, user: action.payload };
    case FETCH_POSTS_SUCCESS:
      return { ...state, loading: false, posts: action.payload };
    case FETCH_FAILURE:
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

// multiApiSagas.js
import { call, put, all, takeLatest } from 'redux-saga/effects';
import { FETCH_USER_AND_POSTS_REQUEST, fetchUserSuccess, fetchPostsSuccess, fetchFailure } from './multiApiActions';

function* fetchUser() {
  const response = yield call(fetch, 'https://api.example.com/user');
  const data = yield response.json();
  return data;
}

function* fetchPosts() {
  const response = yield call(fetch, 'https://api.example.com/posts');
  const data = yield response.json();
  return data;
}

function* fetchUserAndPostsSaga() {
  try {
    const [user, posts] = yield all([call(fetchUser), call(fetchPosts)]);
    yield put(fetchUserSuccess(user));
    yield put(fetchPostsSuccess(posts));
  } catch (error) {
    yield put(fetchFailure(error.message));
  }
}

export function* watchFetchUserAndPosts() {
  yield takeLatest(FETCH_USER_AND_POSTS_REQUEST, fetchUserAndPostsSaga);
}

// sagaMiddleware setup in store configuration
import createSagaMiddleware from 'redux-saga';
import { watchFetchUserAndPosts } from './multiApiSagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(
  multiApiReducer,
  applyMiddleware(sagaMiddleware)
);
sagaMiddleware.run(watchFetchUserAndPosts);
```

##### Expected Output
When the `fetchUserAndPostsRequest` action is dispatched, the saga will trigger API calls to fetch user details and posts concurrently. Once both API calls are successful, the Redux store will be updated with the user and posts data. If either of the API calls fails, the error message will be stored in the Redux state.

### Online Resources for Example 3

1. [Running Multiple Sagas in Parallel](https://redux-saga.js.org/docs/advanced/RunningMultipleEffects.html)
2. [Managing Concurrent Tasks with Redux Saga](https://redux-saga.js.org/docs/advanced/Concurrency.html)

---

## Task 2: Integrate Redux Saga for Complex State Management

Integrating Redux Saga into a React Native project allows developers to manage complex state logic and asynchronous operations efficiently. Redux Saga uses generator functions to handle side effects, such as data fetching, caching, and synchronization. This middleware provides a structured and scalable way to handle these operations by using `sagas`, which can be paused and resumed, making asynchronous flows easier to manage and debug. By decoupling side effects from the core Redux logic, Redux Saga enhances code maintainability and readability.

Redux Saga is particularly useful for managing intricate workflows that involve multiple steps, parallel processes, or conditional branching. For example, it can handle complex scenarios like user authentication, where you may need to perform multiple API calls, handle various success and error states, and update the application state accordingly. Additionally, Redux Saga can manage long-running processes and background tasks, making it an ideal choice for applications with advanced state management requirements.

### Online Resources

1. [Redux Saga Official Documentation](https://redux-saga.js.org/)
2. [A Beginner's Guide to Redux Saga](https://blog.logrocket.com/redux-saga-tutorial-beginners-guide/)

### Examples to Practice

#### Example 1: Fetching Data from an API

##### Explanation
In this example, you will learn how to fetch data from an API using Redux Saga. This includes setting up the necessary actions, reducers, and a saga to handle the API call. You will create a saga that listens for a fetch request action, performs the API call, and dispatches success or failure actions based on the response. This practice will help you understand the basics of managing side effects with Redux Saga.

##### Example Code
```javascript
// actions.js
export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';
export const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';
export const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';

export const fetchDataRequest = () => ({ type: FETCH_DATA_REQUEST });
export const fetchDataSuccess = (data) => ({ type: FETCH_DATA_SUCCESS, payload: data });
export const fetchDataFailure = (error) => ({ type: FETCH_DATA_FAILURE, payload: error });

// reducer.js
const initialState = {
  data: [],
  loading: false,
  error: null,
};

export const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_DATA_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_DATA_SUCCESS:
      return { ...state, loading: false, data: action.payload };
    case FETCH_DATA_FAILURE:
      return { ...state, loading: false, error: action.payload };
    default:
      return state;
  }
};

// sagas.js
import { call, put, takeLatest } from 'redux-saga/effects';
import { FETCH_DATA_REQUEST, fetchDataSuccess, fetchDataFailure } from './actions';

function* fetchDataSaga() {
  try {
    const response = yield call(fetch, 'https://jsonplaceholder.typicode.com/posts');
    const data = yield response.json();
    yield put(fetchDataSuccess(data));
  } catch (error) {
    yield put(fetchDataFailure(error.message));
  }
}

export function* watchFetchData() {
  yield takeLatest(FETCH_DATA_REQUEST, fetchDataSaga);
}

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { dataReducer } from './reducer';
import { watchFetchData } from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(dataReducer, applyMiddleware(sagaMiddleware));
sagaMiddleware.run(watchFetchData);

export default store;
```

##### Expected Output
When you dispatch the `fetchDataRequest` action, the saga will trigger an API call to fetch posts from the JSONPlaceholder API. On success, the data will be stored in the Redux state, and on failure, an error message will be displayed in the state.

##### Online Resources for Example 1
1. [Handling Actions in Redux Saga](https://redux-saga.js.org/docs/basics/HandlingActions.html)
2. [Testing Redux Saga](https://redux-saga.js.org/docs/advanced/Testing.html)

#### Example 2: User Authentication

##### Explanation
This example involves creating a user authentication flow using Redux Saga. You will set up actions, reducers, and sagas to handle login, logout, and user session management. The saga will manage the authentication process, including API calls to authenticate users and manage session tokens. This example will demonstrate how to handle complex side effects, such as managing authentication state and handling errors.

##### Example Code
```javascript
// authActions.js
export const LOGIN_REQUEST = 'LOGIN_REQUEST';
export const LOGIN_SUCCESS = 'LOGIN_SUCCESS';
export const LOGIN_FAILURE = 'LOGIN_FAILURE';
export const LOGOUT = 'LOGOUT';

export const loginRequest = (credentials) => ({ type: LOGIN_REQUEST, payload: credentials });
export const loginSuccess = (token) => ({ type: LOGIN_SUCCESS, payload: token });
export const loginFailure = (error) => ({ type: LOGIN_FAILURE, payload: error });
export const logout = () => ({ type: LOGOUT });

// authReducer.js
const initialState = {
  token: null,
  loading: false,
  error: null,
};

export const authReducer = (state = initialState, action) => {
  switch (action.type) {
    case LOGIN_REQUEST:
      return { ...state, loading: true, error: null };
    case LOGIN_SUCCESS:
      return { ...state, loading: false, token: action.payload };
    case LOGIN_FAILURE:
      return { ...state, loading: false, error: action.payload };
    case LOGOUT:
      return { ...state, token: null };
    default:
      return state;
  }
};

// authSagas.js
import { call, put, takeLatest } from 'redux-saga/effects';
import { LOGIN_REQUEST, loginSuccess, loginFailure, logout } from './authActions';

function* loginSaga(action) {
  try {
    const response = yield call(fetch, 'https://example.com/api/login', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(action.payload),
    });
    const data = yield response.json();
    if (data.token) {
      yield put(loginSuccess(data.token));
      localStorage.setItem('token', data.token);
    } else {
      yield put(loginFailure(data.error));
    }
  } catch (error) {
    yield put(loginFailure(error.message));
  }
}

function* logoutSaga() {
  yield call([localStorage, 'removeItem'], 'token');
}

export function* watchAuth() {
  yield takeLatest(LOGIN_REQUEST, loginSaga);
  yield takeLatest(LOGOUT, logoutSaga);
}

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { authReducer } from './authReducer';
import { watchAuth } from './authSagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(authReducer, applyMiddleware(sagaMiddleware));
sagaMiddleware.run(watchAuth);

export default store;
```

##### Expected Output
When the `loginRequest` action is dispatched with user credentials, the saga will make an API call to authenticate the user. On success, the session token will be stored in the Redux state and local storage. If the authentication fails, an error message will be stored in the state. The `logout` action will clear the session token from both the state and local storage.

##### Online Resources for Example 2
1. [Redux Saga Authentication Example](https://redux-saga.js.org/docs/advanced/ExampleSagaAuthentication.html)
2. [Managing Side Effects in Redux](https://redux.js.org/advanced/middleware)

#### Example 3: Handling Multiple API Requests

##### Explanation
In this example, you will learn how to handle multiple concurrent API requests using Redux Saga. You will create a saga that manages multiple asynchronous operations, such as fetching user details and posts simultaneously. The `all` and `call` effects will be used to run these operations in parallel and wait for all of them to complete. This practice will help you understand how to coordinate multiple side effects and manage complex workflows in your application.

##### Example Code
```javascript
// multiApiActions.js
export const FETCH_USER_AND_POSTS_REQUEST = 'FETCH_USER_AND_POSTS_REQUEST';
export const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
export const FETCH_POSTS_SUCCESS = 'FETCH_POSTS_SUCCESS';
export const FETCH_FAILURE = 'FETCH_FAILURE';

export const fetchUserAndPostsRequest = () => ({ type: FETCH_USER_AND_POSTS_REQUEST });
export const fetchUserSuccess = (user) => ({ type: FETCH_USER_SUCCESS, payload: user });
export const fetchPostsSuccess = (posts) => ({ type: FETCH_POSTS_SUCCESS, payload: posts });
export const fetchFailure = (error) => ({ type: FETCH_FAILURE, payload: error });

// multiApiReducer.js
const initialState = {
  user: null,
  posts: [],
  loading: false,
  error: null,
};

export const multiApiReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_USER_AND_POSTS_REQUEST:
      return { ...state, loading: true, error: null };
    case FETCH_USER_SUCCESS:
      return { ...state, loading: false, user: action.payload };
    case FETCH_POSTS_SUCCESS:
      return { ...state, loading: false, posts: action.payload };
    case FETCH_FAILURE:
      return { ...state, loading: false, error: action.payload };
    default:
      return state

;
  }
};

// multiApiSagas.js
import { call, put, all, takeLatest } from 'redux-saga/effects';
import { FETCH_USER_AND_POSTS_REQUEST, fetchUserSuccess, fetchPostsSuccess, fetchFailure } from './multiApiActions';

function* fetchUser() {
  const response = yield call(fetch, 'https://jsonplaceholder.typicode.com/users/1');
  const data = yield response.json();
  return data;
}

function* fetchPosts() {
  const response = yield call(fetch, 'https://jsonplaceholder.typicode.com/posts');
  const data = yield response.json();
  return data;
}

function* fetchUserAndPostsSaga() {
  try {
    const [user, posts] = yield all([call(fetchUser), call(fetchPosts)]);
    yield put(fetchUserSuccess(user));
    yield put(fetchPostsSuccess(posts));
  } catch (error) {
    yield put(fetchFailure(error.message));
  }
}

export function* watchFetchUserAndPosts() {
  yield takeLatest(FETCH_USER_AND_POSTS_REQUEST, fetchUserAndPostsSaga);
}

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { multiApiReducer } from './multiApiReducer';
import { watchFetchUserAndPosts } from './multiApiSagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(multiApiReducer, applyMiddleware(sagaMiddleware));
sagaMiddleware.run(watchFetchUserAndPosts);

export default store;
```

##### Expected Output
When the `fetchUserAndPostsRequest` action is dispatched, the saga will trigger API calls to fetch user details and posts concurrently. Once both API calls are successful, the Redux store will be updated with the user and posts data. If either of the API calls fails, the error message will be stored in the state.

##### Online Resources for Example 3
1. [Running Multiple Sagas in Parallel](https://redux-saga.js.org/docs/advanced/RunningMultipleEffects.html)
2. [Managing Concurrent Tasks with Redux Saga](https://redux-saga.js.org/docs/advanced/Concurrency.html)

---

### Cross-Platform Development Using React Native

## Task 3: Study Advanced Caching Strategies

Advanced caching strategies are essential for optimizing the performance of mobile applications. In React Native, caching can significantly improve the user experience by reducing the need for repeated network requests and speeding up data retrieval. Advanced caching involves techniques such as in-memory caching, local storage, and leveraging service workers for offline capabilities. These strategies ensure that frequently accessed data is readily available, even when the user is offline or experiencing poor network conditions.

Implementing effective caching strategies requires a good understanding of the different types of caches and their use cases. For instance, in-memory caching is ideal for data that changes frequently and needs to be accessed quickly, while local storage (e.g., AsyncStorage in React Native) is suitable for persisting data across app sessions. Advanced caching techniques also include cache invalidation strategies to ensure that outdated or stale data does not degrade the user experience. By mastering these techniques, developers can create highly performant and reliable mobile applications.

### Online Resources

1. [Caching Strategies for React Native](https://medium.com/@arpitbhayani/caching-strategies-in-react-native-12b6e6b0e48c)
2. [React Native AsyncStorage](https://react-native-async-storage.github.io/async-storage/docs/install/)

### Examples to Practice

#### Example 1: Implementing In-Memory Caching

##### Explanation
In this example, you will learn how to implement in-memory caching in a React Native application. In-memory caching stores data in the application's memory, making it extremely fast to access. This technique is particularly useful for data that is frequently accessed and updated, such as user preferences or session information. You will create a simple caching mechanism to store and retrieve data in memory.

##### Example Code
```javascript
// cache.js
class InMemoryCache {
  constructor() {
    this.cache = {};
  }

  set(key, value) {
    this.cache[key] = value;
  }

  get(key) {
    return this.cache[key];
  }

  clear() {
    this.cache = {};
  }
}

const cache = new InMemoryCache();
export default cache;

// App.js
import React, { useEffect } from 'react';
import { Text, View } from 'react-native';
import cache from './cache';

const App = () => {
  useEffect(() => {
    // Set data in cache
    cache.set('username', 'JohnDoe');

    // Retrieve data from cache
    const username = cache.get('username');
    console.log('Cached Username:', username);
  }, []);

  return (
    <View>
      <Text>Check console for cached data.</Text>
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, the username "JohnDoe" will be stored in the in-memory cache. The cached data will be logged to the console, demonstrating how data can be stored and retrieved quickly using in-memory caching.

##### Online Resources for Example 1
1. [Understanding In-Memory Caching](https://developer.mozilla.org/en-US/docs/Web/HTTP/Caching)
2. [Optimizing Performance with In-Memory Caching](https://www.alibabacloud.com/blog/optimizing-performance-with-in-memory-caching_594899)

#### Example 2: Using AsyncStorage for Persistent Caching

##### Explanation
AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the React Native application. It is ideal for persisting small amounts of data that need to be available across app launches, such as user preferences or settings. In this example, you will learn how to use AsyncStorage to store and retrieve data persistently in a React Native application.

##### Example Code
```javascript
// storage.js
import AsyncStorage from '@react-native-async-storage/async-storage';

export const storeData = async (key, value) => {
  try {
    await AsyncStorage.setItem(key, value);
  } catch (e) {
    console.error('Failed to save the data to the storage', e);
  }
};

export const getData = async (key) => {
  try {
    const value = await AsyncStorage.getItem(key);
    return value;
  } catch (e) {
    console.error('Failed to fetch the data from storage', e);
  }
};

// App.js
import React, { useEffect, useState } from 'react';
import { Text, View, Button } from 'react-native';
import { storeData, getData } from './storage';

const App = () => {
  const [username, setUsername] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      const storedUsername = await getData('username');
      if (storedUsername) {
        setUsername(storedUsername);
      }
    };
    fetchData();
  }, []);

  const handleSave = async () => {
    await storeData('username', 'JohnDoe');
    setUsername('JohnDoe');
  };

  return (
    <View>
      <Text>Stored Username: {username}</Text>
      <Button title="Save Username" onPress={handleSave} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will initially fetch the stored username from AsyncStorage and display it. When you press the "Save Username" button, the username "JohnDoe" will be stored in AsyncStorage, and the displayed username will be updated.

##### Online Resources for Example 2
1. [React Native AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/docs/api/)
2. [Persisting Data with AsyncStorage in React Native](https://reactnative.dev/docs/asyncstorage)

#### Example 3: Implementing a Custom Caching Strategy with IndexedDB

##### Explanation
IndexedDB is a low-level API for storing significant amounts of structured data, including files/blobs. While not natively supported in React Native, you can use a similar approach by leveraging libraries like `react-native-sqlite-storage` to achieve similar functionality. This example demonstrates how to implement a custom caching strategy using SQLite, which can handle larger amounts of data and more complex queries than AsyncStorage.

##### Example Code
```javascript
// database.js
import SQLite from 'react-native-sqlite-storage';

const db = SQLite.openDatabase(
  {
    name: 'cacheDB',
    location: 'default',
  },
  () => {
    console.log('Database opened');
  },
  error => {
    console.error('Error opening database', error);
  }
);

export const createTable = () => {
  db.transaction(tx => {
    tx.executeSql(
      'CREATE TABLE IF NOT EXISTS Cache (key TEXT PRIMARY KEY, value TEXT)',
      [],
      () => {
        console.log('Table created');
      },
      error => {
        console.error('Error creating table', error);
      }
    );
  });
};

export const storeData = (key, value) => {
  db.transaction(tx => {
    tx.executeSql(
      'INSERT OR REPLACE INTO Cache (key, value) VALUES (?, ?)',
      [key, value],
      () => {
        console.log('Data stored');
      },
      error => {
        console.error('Error storing data', error);
      }
    );
  });
};

export const getData = (key, callback) => {
  db.transaction(tx => {
    tx.executeSql(
      'SELECT value FROM Cache WHERE key = ?',
      [key],
      (tx, results) => {
        if (results.rows.length > 0) {
          callback(results.rows.item(0).value);
        } else {
          callback(null);
        }
      },
      error => {
        console.error('Error fetching data', error);
      }
    );
  });
};

// App.js
import React, { useEffect, useState } from 'react';
import { Text, View, Button } from 'react-native';
import { createTable, storeData, getData } from './database';

const App = () => {
  const [data, setData] = useState('');

  useEffect(() => {
    createTable();
    getData('key1', (value) => {
      if (value) {
        setData(value);
      }
    });
  }, []);

  const handleSave = () => {
    storeData('key1', 'Sample data');
    setData('Sample data');
  };

  return (
    <View>
      <Text>Cached Data: {data}</Text>
      <Button title="Save Data" onPress={handleSave} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will create a table in SQLite and attempt to fetch the data associated with 'key1'. If the data exists, it will be displayed. When you press the "Save Data" button, the data "Sample data" will be stored in the SQLite database, and the displayed data will be updated.

##### Online Resources for Example 3
1. [React Native SQLite Storage](https://github.com/andpor/react-native-sqlite-storage)
2. [Using SQLite in React Native](https://aboutreact.com/example-of-sqlite-database-in-react-native/)

---

### Cross-Platform Development Using React Native

## Task 4: Implement Caching with Apollo Client

Apollo Client is a powerful state management library for JavaScript applications, particularly those utilizing GraphQL for data fetching. One of the standout features of Apollo Client is its caching mechanism, which helps improve performance by storing query results locally. This local cache reduces the need for repeated network requests, thereby speeding up data retrieval and reducing bandwidth usage. By efficiently managing cache, Apollo Client ensures that your application remains responsive and performs well even under varying network conditions.

Implementing caching with Apollo Client involves setting up the client with a caching strategy, configuring cache policies, and understanding how to manipulate the cache directly. The InMemoryCache provided by Apollo Client is a robust and highly configurable cache that supports various caching strategies, including normalized caching, which keeps data consistent and avoids redundancy. Advanced features such as cache eviction, garbage collection, and cache persistence provide developers with the tools necessary to fine-tune their caching strategy to meet specific application needs.

### Online Resources

1. [Apollo Client: Caching](https://www.apollographql.com/docs/react/caching/overview/)
2. [Apollo Client: Getting Started](https://www.apollographql.com/docs/react/get-started/)

### Examples to Practice

#### Example 1: Basic Apollo Client Setup with Caching

##### Explanation
In this example, you will set up Apollo Client in a React Native application and configure it to use an in-memory cache. You will write a simple query to fetch data and observe how Apollo Client caches the result. This example serves as a foundation to understand the basic setup and utilization of Apollo Client's caching mechanism.

##### Example Code
```javascript
// App.js
import React from 'react';
import { Text, View } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';

// Initialize Apollo Client
const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app/',
  cache: new InMemoryCache()
});

const GET_POKEMON = gql`
  query GetPokemon {
    pokemon(name: "Pikachu") {
      id
      name
      number
      attacks {
        special {
          name
        }
      }
    }
  }
`;

const Pokemon = () => {
  const { loading, error, data } = useQuery(GET_POKEMON);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <Text>Pokemon Name: {data.pokemon.name}</Text>
      <Text>Pokemon Number: {data.pokemon.number}</Text>
      <Text>Special Attacks:</Text>
      {data.pokemon.attacks.special.map((attack, index) => (
        <Text key={index}>{attack.name}</Text>
      ))}
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <View>
        <Text>GraphQL Pokemon API</Text>
        <Pokemon />
      </View>
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch data about Pikachu from the GraphQL Pokemon API and display it. Subsequent queries for the same data will be served from the Apollo Client cache, demonstrating the caching mechanism.

##### Online Resources for Example 1
1. [Apollo Client Setup](https://www.apollographql.com/docs/react/get-started/)
2. [InMemoryCache Configuration](https://www.apollographql.com/docs/react/caching/cache-configuration/)

#### Example 2: Updating Cached Data with Apollo Client

##### Explanation
In this example, you will learn how to update cached data in Apollo Client. You will write a mutation to modify data and ensure the Apollo Client cache reflects these changes. This practice will help you understand how to manage data consistency between the cache and the server.

##### Example Code
```javascript
// App.js
import React from 'react';
import { Text, View, Button } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql } from '@apollo/client';

// Initialize Apollo Client
const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app/',
  cache: new InMemoryCache()
});

const GET_POKEMON = gql`
  query GetPokemon {
    pokemon(name: "Pikachu") {
      id
      name
      number
      attacks {
        special {
          name
        }
      }
    }
  }
`;

const UPDATE_POKEMON = gql`
  mutation UpdatePokemon($name: String!) {
    updatePokemon(name: $name) {
      name
    }
  }
`;

const Pokemon = () => {
  const { loading, error, data } = useQuery(GET_POKEMON);
  const [updatePokemon] = useMutation(UPDATE_POKEMON, {
    update(cache, { data: { updatePokemon } }) {
      const existingData = cache.readQuery({ query: GET_POKEMON });
      cache.writeQuery({
        query: GET_POKEMON,
        data: {
          pokemon: {
            ...existingData.pokemon,
            name: updatePokemon.name,
          }
        }
      });
    }
  });

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <Text>Pokemon Name: {data.pokemon.name}</Text>
      <Text>Pokemon Number: {data.pokemon.number}</Text>
      <Button title="Update Pokemon Name" onPress={() => updatePokemon({ variables: { name: 'Raichu' } })} />
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <View>
        <Text>GraphQL Pokemon API</Text>
        <Pokemon />
      </View>
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch data about Pikachu from the GraphQL Pokemon API and display it. Pressing the "Update Pokemon Name" button will change the name to "Raichu" and update the cache, ensuring the UI reflects the new data.

##### Online Resources for Example 2
1. [Apollo Client Mutations](https://www.apollographql.com/docs/react/data/mutations/)
2. [Updating the Cache after a Mutation](https://www.apollographql.com/docs/react/caching/cache-interaction/#updating-the-cache-after-a-mutation)

#### Example 3: Implementing Cache Eviction with Apollo Client

##### Explanation
In this example, you will implement cache eviction in Apollo Client to manage and remove outdated or unnecessary data from the cache. This practice is crucial for maintaining cache efficiency and ensuring that the application doesn't store stale data. You will write code to evict specific items from the cache after a certain operation.

##### Example Code
```javascript
// App.js
import React from 'react';
import { Text, View, Button } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql } from '@apollo/client';

// Initialize Apollo Client
const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app/',
  cache: new InMemoryCache()
});

const GET_POKEMON = gql`
  query GetPokemon {
    pokemon(name: "Pikachu") {
      id
      name
      number
      attacks {
        special {
          name
        }
      }
    }
  }
`;

const DELETE_POKEMON = gql`
  mutation DeletePokemon($id: ID!) {
    deletePokemon(id: $id) {
      id
    }
  }
`;

const Pokemon = () => {
  const { loading, error, data } = useQuery(GET_POKEMON);
  const [deletePokemon] = useMutation(DELETE_POKEMON, {
    update(cache, { data: { deletePokemon } }) {
      cache.evict({ id: cache.identify(deletePokemon) });
      cache.gc();
    }
  });

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <Text>Pokemon Name: {data.pokemon.name}</Text>
      <Text>Pokemon Number: {data.pokemon.number}</Text>
      <Button title="Delete Pokemon" onPress={() => deletePokemon({ variables: { id: data.pokemon.id } })} />
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <View>
        <Text>GraphQL Pokemon API</Text>
        <Pokemon />
      </View>
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch data about Pikachu from the GraphQL Pokemon API and display it. Pressing the "Delete Pokemon" button will delete the Pokemon and evict it from the cache, ensuring that the UI and cache no longer contain the deleted data.

##### Online Resources for Example 3
1. [Apollo Client Cache Eviction](https://www.apollographql.com/docs/react/caching/cache-interaction/#evicting-fields-from-the-cache)
2. [Managing Cache with Apollo Client](https://www.apollographql.com/docs/react/caching/cache-configuration/)

---
## Task 5: Study Advanced Networking Techniques

Advanced networking techniques in React Native are essential for building robust and scalable mobile applications that can handle various network conditions and efficiently manage data transfer. These techniques involve using libraries and patterns that optimize network requests, manage state synchronization, and ensure data consistency across different parts of the application. This includes leveraging tools like Axios for HTTP requests, WebSockets for real-time communication, and GraphQL for more efficient querying and data fetching.


Implementing advanced networking techniques also involves understanding and handling issues such as network latency, error handling, retries, and data caching. By mastering these techniques, developers can create applications that provide a seamless user experience even in low or fluctuating network conditions. Additionally, techniques such as request cancellation, optimistic updates, and batched requests can further enhance the performance and reliability of network interactions in a React Native application.

### Online Resources

1. [Advanced Networking in React Native](https://dev.to/knowthen/advanced-networking-with-react-native-3m3)
2. [Handling Network Requests in React Native](https://reactnative.dev/docs/network)

### Examples to Practice

#### Example 1: Handling HTTP Requests with Axios

##### Explanation
In this example, you will learn how to use Axios, a popular HTTP client, to make network requests in a React Native application. Axios provides a simple and flexible API for sending HTTP requests and handling responses. You will set up Axios in your project, make GET and POST requests, and handle errors effectively.

##### Example Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, Button, TextInput, FlatList } from 'react-native';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState([]);
  const [title, setTitle] = useState('');
  const [body, setBody] = useState('');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const response = await axios.get('https://jsonplaceholder.typicode.com/posts');
      setData(response.data);
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  const createPost = async () => {
    try {
      const response = await axios.post('https://jsonplaceholder.typicode.com/posts', {
        title,
        body
      });
      setData([response.data, ...data]);
      setTitle('');
      setBody('');
    } catch (error) {
      console.error('Error creating post:', error);
    }
  };

  return (
    <View>
      <TextInput
        placeholder="Title"
        value={title}
        onChangeText={setTitle}
        style={{ borderWidth: 1, margin: 5, padding: 5 }}
      />
      <TextInput
        placeholder="Body"
        value={body}
        onChangeText={setBody}
        style={{ borderWidth: 1, margin: 5, padding: 5 }}
      />
      <Button title="Create Post" onPress={createPost} />
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => (
          <View style={{ padding: 10, borderBottomWidth: 1 }}>
            <Text style={{ fontWeight: 'bold' }}>{item.title}</Text>
            <Text>{item.body}</Text>
          </View>
        )}
      />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch and display a list of posts from the JSONPlaceholder API. You can create a new post using the provided input fields and the new post will be added to the list and displayed immediately.

##### Online Resources for Example 1
1. [Axios Documentation](https://axios-http.com/docs/intro)
2. [Using Axios with React Native](https://blog.logrocket.com/using-axios-network-requests-react-native/)

#### Example 2: Real-Time Communication with WebSockets

##### Explanation
In this example, you will learn how to implement real-time communication using WebSockets in a React Native application. WebSockets provide a full-duplex communication channel that allows the server to push updates to the client in real-time. This is particularly useful for applications that require live updates, such as chat applications, real-time notifications, or live data feeds.

##### Example Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { w3cwebsocket as W3CWebSocket } from 'websocket';

const client = new W3CWebSocket('ws://echo.websocket.org');

const App = () => {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');

  useEffect(() => {
    client.onopen = () => {
      console.log('WebSocket Client Connected');
    };

    client.onmessage = (message) => {
      setMessages((prevMessages) => [...prevMessages, message.data]);
    };

    return () => {
      client.close();
    };
  }, []);

  const sendMessage = () => {
    client.send(input);
    setInput('');
  };

  return (
    <View>
      <TextInput
        value={input}
        onChangeText={setInput}
        placeholder="Type a message"
        style={{ borderWidth: 1, margin: 5, padding: 5 }}
      />
      <Button title="Send Message" onPress={sendMessage} />
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => (
          <View style={{ padding: 10, borderBottomWidth: 1 }}>
            <Text>{item}</Text>
          </View>
        )}
      />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send messages through a WebSocket connection to the echo server. The sent messages will be echoed back and displayed in the list in real-time.

##### Online Resources for Example 2
1. [WebSocket API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
2. [Real-Time Data in React Native Using WebSockets](https://www.freecodecamp.org/news/how-to-build-a-real-time-chat-app-with-react-native/)

#### Example 3: Efficient Data Fetching with GraphQL

##### Explanation
In this example, you will learn how to use GraphQL to efficiently fetch data in a React Native application. GraphQL allows clients to request exactly the data they need, reducing the amount of data transferred over the network. You will set up Apollo Client with GraphQL, perform queries, and manage the data in your application.

##### Example Code
```javascript
// App.js
import React from 'react';
import { Text, View, FlatList } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';

// Initialize Apollo Client
const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app/',
  cache: new InMemoryCache()
});

const GET_POKEMONS = gql`
  query GetPokemons {
    pokemons(first: 10) {
      id
      name
      image
    }
  }
`;

const Pokemons = () => {
  const { loading, error, data } = useQuery(GET_POKEMONS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <FlatList
      data={data.pokemons}
      keyExtractor={(item) => item.id}
      renderItem={({ item }) => (
        <View style={{ padding: 10, borderBottomWidth: 1 }}>
          <Text>{item.name}</Text>
          <Image source={{ uri: item.image }} style={{ width: 50, height: 50 }} />
        </View>
      )}
    />
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <View>
        <Text>GraphQL Pokemon API</Text>
        <Pokemons />
      </View>
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch and display a list of Pokemons from the GraphQL Pokemon API. The data fetched will include only the necessary fields specified in the query, demonstrating the efficiency of GraphQL.

##### Online Resources for Example 3
1. [GraphQL Documentation](https://graphql.org/learn/)
2. [Apollo Client: Querying Data](https://www.apollographql.com/docs/react/data/queries/)

---

## Task 6: Optimize Network Requests with HTTP/2

HTTP/2 is a major revision of the HTTP network protocol, designed to improve the performance of web applications by optimizing how data is transported between clients and servers. Unlike HTTP/1.1, HTTP/2 allows for multiple concurrent requests over a single connection, which reduces latency and improves page load times. It also introduces features like header compression and server push, which further enhance performance by reducing the amount of data transmitted and allowing servers to proactively send resources to clients before they are requested.

In the context of React Native, utilizing HTTP/2 can significantly optimize network requests, leading to faster data fetching and a smoother user experience. React Native applications can benefit from HTTP/2's ability to multiplex multiple requests, making it particularly effective for applications that require frequent communication with the server. By implementing HTTP/2, developers can take advantage of these performance improvements to build more responsive and efficient applications.

### Online Resources

1. [Introduction to HTTP/2](https://developers.google.com/web/fundamentals/performance/http2)
2. [HTTP/2 in Practice](https://http2.github.io/)

### Examples to Practice

#### Example 1: Setting Up an HTTP/2 Server

##### Explanation
In this example, you will set up an HTTP/2 server using Node.js. This will serve as a backend for your React Native application, enabling you to leverage HTTP/2's performance benefits. Setting up an HTTP/2 server involves configuring the server to support HTTP/2, generating SSL certificates for secure communication, and creating endpoints for your React Native application to consume.

##### Example Code
```javascript
// server.js
const http2 = require('http2');
const fs = require('fs');

// Load SSL certificate and key
const serverOptions = {
  key: fs.readFileSync('server.key'),
  cert: fs.readFileSync('server.crt')
};

// Create an HTTP/2 server
const server = http2.createSecureServer(serverOptions);

server.on('stream', (stream, headers) => {
  // Respond to GET requests to /data
  if (headers[':path'] === '/data' && headers[':method'] === 'GET') {
    stream.respond({
      'content-type': 'application/json',
      ':status': 200
    });
    stream.end(JSON.stringify({ message: 'Hello, HTTP/2!' }));
  }
});

// Start the server
server.listen(8443, () => {
  console.log('HTTP/2 server running at https://localhost:8443');
});
```

##### Expected Output
When you run the server, it will listen on port 8443 for HTTP/2 connections. You can access the endpoint `/data` to receive a JSON response. This sets up the foundation for your React Native app to interact with an HTTP/2 server.

##### Online Resources for Example 1
1. [Node.js HTTP/2 Documentation](https://nodejs.org/dist/latest-v12.x/docs/api/http2.html)
2. [Setting Up HTTP/2 with Node.js](https://flaviocopes.com/http2-node/)

#### Example 2: Making HTTP/2 Requests in React Native

##### Explanation
In this example, you will configure your React Native application to make HTTP/2 requests to the server you set up in Example 1. This involves using libraries that support HTTP/2 and ensuring that your requests are properly handled by the HTTP/2 server. By making HTTP/2 requests, you can take advantage of faster data fetching and improved performance.

##### Example Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, Button } from 'react-native';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState('');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const response = await axios.get('https://localhost:8443/data', {
        httpsAgent: new (require('https').Agent)({
          rejectUnauthorized: false
        })
      });
      setData(response.data.message);
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  return (
    <View>
      <Text>Data from HTTP/2 Server: {data}</Text>
      <Button title="Fetch Data" onPress={fetchData} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch data from the HTTP/2 server you set up earlier and display the message "Hello, HTTP/2!". This demonstrates how to make HTTP/2 requests from a React Native application.

##### Online Resources for Example 2
1. [Axios Documentation](https://axios-http.com/docs/intro)
2. [Making HTTP Requests in React Native](https://reactnative.dev/docs/network)

#### Example 3: Implementing Server Push with HTTP/2

##### Explanation
In this example, you will implement server push with HTTP/2 to proactively send resources to the client. Server push allows the server to send additional resources to the client without the client explicitly requesting them. This can significantly reduce the number of round trips required to load a page, improving load times and overall performance.

##### Example Code
```javascript
// server.js
const http2 = require('http2');
const fs = require('fs');

// Load SSL certificate and key
const serverOptions = {
  key: fs.readFileSync('server.key'),
  cert: fs.readFileSync('server.crt')
};

// Create an HTTP/2 server
const server = http2.createSecureServer(serverOptions);

server.on('stream', (stream, headers) => {
  if (headers[':path'] === '/main' && headers[':method'] === 'GET') {
    // Push additional resources
    stream.pushStream({ ':path': '/pushed-resource' }, (err, pushStream) => {
      if (err) throw err;
      pushStream.respond({
        'content-type': 'text/plain',
        ':status': 200
      });
      pushStream.end('This is a pushed resource!');
    });

    stream.respond({
      'content-type': 'text/plain',
      ':status': 200
    });
    stream.end('Main response with server push');
  }
});

server.listen(8443, () => {
  console.log('HTTP/2 server with server push running at https://localhost:8443');
});
```

```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, Button } from 'react-native';
import axios from 'axios';

const App = () => {
  const [mainData, setMainData] = useState('');
  const [pushedData, setPushedData] = useState('');

  useEffect(() => {
    fetchData();
  }, []);

  const fetchData = async () => {
    try {
      const response = await axios.get('https://localhost:8443/main', {
        httpsAgent: new (require('https').Agent)({
          rejectUnauthorized: false
        })
      });
      setMainData(response.data);
      // Assume the pushed resource is cached by the client
      setPushedData('This is a pushed resource!');
    } catch (error) {
      console.error('Error fetching data:', error);
    }
  };

  return (
    <View>
      <Text>Main Data: {mainData}</Text>
      <Text>Pushed Data: {pushedData}</Text>
      <Button title="Fetch Data" onPress={fetchData} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will fetch the main response from the HTTP/2 server and also display the pushed resource. This demonstrates how to use HTTP/2 server push to send additional resources proactively to the client.

##### Online Resources for Example 3
1. [HTTP/2 Server Push](https://developers.google.com/web/fundamentals/performance/http2#server-push)
2. [Using Server Push with Node.js](https://web.dev/server-push-with-http2/)

---
## Task 7: Study Server-Side Rendering in Next.js

Server-Side Rendering (SSR) in Next.js is a technique used to render web pages on the server rather than in the browser. This approach can improve the performance and SEO of web applications by generating HTML content on the server and sending it to the client. Next.js, a React framework, offers built-in support for SSR, allowing developers to create pre-rendered pages with dynamic data. This is achieved by using special methods like `getServerSideProps` and `getInitialProps`, which fetch data on the server before rendering the page.

SSR can enhance user experience by providing faster load times and ensuring that content is available to search engines, which can significantly improve the website's visibility. Additionally, SSR can handle initial requests more efficiently, especially for applications with dynamic content. However, it is essential to balance SSR with client-side rendering to ensure optimal performance and scalability. By leveraging SSR in Next.js, developers can create highly performant web applications that offer a seamless experience across various devices and network conditions.

### Online Resources

1. [Next.js Documentation on Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)

### Examples to Practice

#### Example 1: Basic Server-Side Rendering with Next.js

##### Explanation
In this example, you will create a simple Next.js application with a page that uses server-side rendering. You will use the `getServerSideProps` function to fetch data from an API and render it on the server before sending the HTML to the client. This will help you understand the basics of SSR in Next.js and how to fetch and display data dynamically.

##### Example Code
```javascript
// pages/index.js
import React from 'react';

const HomePage = ({ data }) => {
  return (
    <div>
      <h1>Server-Side Rendered Page</h1>
      <p>Data fetched from API: {data.title}</p>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will display the data fetched from the API. The data is fetched on the server, and the HTML content is sent to the client, demonstrating server-side rendering.

##### Online Resources for Example 1
1. [getServerSideProps Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Next.js Tutorial: Create a Simple SSR Page](https://www.learnwithjason.dev/blog/next-js-server-side-rendering)

#### Example 2: SSR with Dynamic Routes

##### Explanation
In this example, you will create a Next.js application with dynamic routes and server-side rendering. You will use the `getServerSideProps` function to fetch data based on dynamic route parameters and render it on the server. This example will help you understand how to handle dynamic content with SSR in Next.js.

##### Example Code
```javascript
// pages/posts/[id].js
import React from 'react';

const PostPage = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';

const HomePage = ({ posts }) => {
  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will list posts fetched from the API. Clicking on a post will navigate to a dynamically generated route that displays the post's details. Both the home page and the post pages are rendered on the server.

##### Online Resources for Example 2
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [SSR with Dynamic Routes in Next.js](https://dev.to/ivandotv/next-js-server-side-rendering-ssr-with-dynamic-routes-3g4p)

#### Example 3: Integrating SSR with a GraphQL API

##### Explanation
In this example, you will integrate SSR in Next.js with a GraphQL API. You will set up a GraphQL server, fetch data using a GraphQL query in the `getServerSideProps` function, and render the data on the server. This example demonstrates how to use GraphQL with SSR in Next.js.

##### Example Code
```javascript
// server.js (GraphQL server setup)
const { ApolloServer, gql } = require('apollo-server');

const typeDefs = gql`
  type Post {
    id: ID!
    title: String!
    body: String!
  }

  type Query {
    posts: [Post]
    post(id: ID!): Post
  }
`;

const posts = [
  { id: '1', title: 'Post 1', body: 'This is the first post' },
  { id: '2', title: 'Post 2', body: 'This is the second post' },
];

const resolvers = {
  Query: {
    posts: () => posts,
    post: (_, { id }) => posts.find(post => post.id === id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`  Server ready at ${url}`);
});
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const HomePage = ({ posts }) => {
  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getServerSideProps() {
  const client = new ApolloClient({
    uri: 'http://localhost:4000',
    cache: new InMemoryCache()
  });

  const { data } = await client.query({
    query: gql`
      query {
        posts {
          id
          title
        }
      }
    `
  });

  return {
    props: { posts: data.posts },
  };
}

export default HomePage;
```

```javascript
// pages/posts/[id].js
import React from 'react';
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const PostPage = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;

  const client = new ApolloClient({
    uri: 'http://localhost:4000',
    cache: new InMemoryCache()
  });

  const { data } = await client.query({
    query: gql`
      query($id: ID!) {
        post(id: $id) {
          id
          title
          body
        }
      }
    `,
    variables: { id }
  });

  return {
    props: { post: data.post },
  };
}

export default PostPage;
```

##### Expected Output
When you run the GraphQL server and the Next.js application, the home page will display a list of posts fetched from the GraphQL API. Clicking on a post will navigate to a dynamically generated route that displays the post's details. Both the home page and the post pages are rendered on the server using data fetched from the GraphQL API.

##### Online Resources for Example 3
1. [Using Apollo Client with Next.js](https://www.apollographql.com/blog/apollo-client/next-js/next-js-getting-started/)
2. [Server-Side Rendering with Apollo Client](https://www.apollographql.com/docs/react/performance/server-side-rendering/)

---
## Task 8: Implement SSR with Next.js for Mobile

Server-Side Rendering (SSR) with Next.js is a powerful technique for rendering web pages on the server instead of the client. This approach helps improve performance and search engine optimization (SEO) by delivering fully rendered HTML pages to the client. For mobile applications, SSR can significantly enhance the user experience by reducing the time it takes to display content, as the server handles the initial rendering of pages. Next.js facilitates SSR with features like `getServerSideProps`, allowing developers to fetch data and pre-render pages on the server.

Implementing SSR in a mobile context involves optimizing the rendered content for mobile devices, ensuring responsive design, and managing data fetching efficiently. By leveraging SSR with Next.js, mobile web applications can deliver faster load times and a more engaging user experience. This approach is particularly beneficial for dynamic content and applications that rely heavily on real-time data. Understanding how to implement and optimize SSR for mobile can help developers create high-performance, SEO-friendly applications that cater to the needs of mobile users.

### Online Resources

1. [Next.js Documentation on Server-Side Rendering](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Next.js Server-Side Rendering](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)

### Examples to Practice

#### Example 1: Basic Server-Side Rendering with Next.js for Mobile

##### Explanation
In this example, you will create a simple Next.js application with a page that uses server-side rendering optimized for mobile. You will use the `getServerSideProps` function to fetch data from an API and render it on the server before sending the HTML to the client. Additionally, you will apply responsive design techniques to ensure the page looks good on mobile devices.

##### Example Code
```javascript
// pages/index.js
import React from 'react';
import Head from 'next/head';

const HomePage = ({ data }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile SSR with Next.js</title>
      </Head>
      <h1>Server-Side Rendered Page for Mobile</h1>
      <p>Data fetched from API: {data.title}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will display data fetched from the API. The page will be rendered on the server, and the content will be styled to look good on mobile devices, demonstrating server-side rendering with responsive design.

##### Online Resources for Example 1
1. [getServerSideProps Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Responsive Design in Next.js](https://nextjs.org/docs/basic-features/layouts)

#### Example 2: Dynamic Routes with SSR for Mobile

##### Explanation
In this example, you will create a Next.js application with dynamic routes and server-side rendering optimized for mobile. You will use the `getServerSideProps` function to fetch data based on dynamic route parameters and render it on the server. The page will also include responsive design elements to ensure it is optimized for mobile devices.

##### Example Code
```javascript
// pages/posts/[id].js
import React from 'react';
import Head from 'next/head';

const PostPage = ({ post }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{post.title}</title>
      </Head>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';

const HomePage = ({ posts }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile Posts</title>
      </Head>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will list posts fetched from the API. Clicking on a post will navigate to a dynamically generated route that displays the post's details. Both the home page and the post pages are rendered on the server and optimized for mobile devices.

##### Online Resources for Example 2
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [SSR with Dynamic Routes in Next.js](https://dev.to/ivandotv/next-js-server-side-rendering-ssr-with-dynamic-routes-3g4p)

#### Example 3: Integrating SSR with a GraphQL API for Mobile

##### Explanation
In this example, you will integrate SSR in Next.js with a GraphQL API, optimized for mobile. You will set up a GraphQL server, fetch data using a GraphQL query in the `getServerSideProps` function, and render the data on the server. The pages will include responsive design elements to ensure they are optimized for mobile devices.

##### Example Code
```javascript
// server.js (GraphQL server setup)
const { ApolloServer, gql } = require('apollo-server');

const typeDefs = gql`
  type Post {
    id: ID!
    title: String!
    body: String!
  }

  type Query {
    posts: [Post]
    post(id: ID!): Post
  }
`;

const posts = [
  { id: '1', title: 'Post 1', body: 'This is the first post' },
  { id: '2', title: 'Post 2', body: 'This is the second post' },
];

const resolvers = {
  Query: {
    posts: () => posts,
    post: (_, { id }) => posts.find(post => post.id === id),
  },
};

const server = new ApolloServer({ typeDefs, resolvers });

server.listen().then(({ url }) => {
  console.log(`  Server ready at ${url}`);
});
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const HomePage = ({ posts }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile Posts</title>
      </Head>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`


        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps() {
  const client = new ApolloClient({
    uri: 'http://localhost:4000',
    cache: new InMemoryCache()
  });

  const { data } = await client.query({
    query: gql`
      query {
        posts {
          id
          title
        }
      }
    `
  });

  return {
    props: { posts: data.posts },
  };
}

export default HomePage;
```

```javascript
// pages/posts/[id].js
import React from 'react';
import Head from 'next/head';
import { ApolloClient, InMemoryCache, gql } from '@apollo/client';

const PostPage = ({ post }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{post.title}</title>
      </Head>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;

  const client = new ApolloClient({
    uri: 'http://localhost:4000',
    cache: new InMemoryCache()
  });

  const { data } = await client.query({
    query: gql`
      query($id: ID!) {
        post(id: $id) {
          id
          title
          body
        }
      }
    `,
    variables: { id }
  });

  return {
    props: { post: data.post },
  };
}

export default PostPage;
```

##### Expected Output
When you run the GraphQL server and the Next.js application, the home page will display a list of posts fetched from the GraphQL API. Clicking on a post will navigate to a dynamically generated route that displays the post's details. Both the home page and the post pages are rendered on the server using data fetched from the GraphQL API and are optimized for mobile devices.

##### Online Resources for Example 3
1. [Using Apollo Client with Next.js](https://www.apollographql.com/blog/apollo-client/next-js/next-js-getting-started/)
2. [Server-Side Rendering with Apollo Client](https://www.apollographql.com/docs/react/performance/server-side-rendering/)

---

## Task: Study Static Site Generation with Next.js

Static Site Generation (SSG) is a method of pre-rendering pages at build time, resulting in a static HTML file for each page. This approach can significantly improve the performance and security of web applications, as the content is generated once and served statically, reducing the need for server-side processing. Next.js, a popular React framework, provides built-in support for SSG through its `getStaticProps` and `getStaticPaths` functions. These functions allow developers to fetch data at build time and generate static pages accordingly.

Using SSG with Next.js is particularly beneficial for content-heavy websites, blogs, and e-commerce platforms where the content does not change frequently. By pre-rendering pages, you can deliver fast load times and improve SEO, as search engines can easily index the static HTML content. Additionally, Next.js allows you to combine SSG with client-side rendering, providing a flexible approach to handle dynamic content. Understanding how to implement and optimize SSG in Next.js can help developers build high-performance web applications that offer an excellent user experience.

### Online Resources

1. [Next.js Documentation on Static Site Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Static Site Generation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)

### Examples to Practice

#### Example 1: Basic Static Site Generation with Next.js

##### Explanation
In this example, you will create a simple Next.js application with a page that uses static site generation. You will use the `getStaticProps` function to fetch data from an API and generate static HTML pages at build time. This example will help you understand the basics of SSG in Next.js and how to fetch and display data statically.

##### Example Code
```javascript
// pages/index.js
import React from 'react';

const HomePage = ({ data }) => {
  return (
    <div>
      <h1>Static Site Generated Page</h1>
      <p>Data fetched from API: {data.title}</p>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will display the data fetched from the API. The data is fetched at build time, and the HTML content is statically generated and served to the client.

##### Online Resources for Example 1
1. [getStaticProps Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js Tutorial: Static Site Generation](https://www.learnwithjason.dev/blog/next-js-static-site-generation)

#### Example 2: SSG with Dynamic Routes

##### Explanation
In this example, you will create a Next.js application with dynamic routes and static site generation. You will use the `getStaticPaths` and `getStaticProps` functions to fetch data for each dynamic route and generate static HTML pages at build time. This example will help you understand how to handle dynamic content with SSG in Next.js.

##### Example Code
```javascript
// pages/posts/[id].js
import React from 'react';

const PostPage = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';

const HomePage = ({ posts }) => {
  return (
    <div>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will list posts fetched from the API. Clicking on a post will navigate to a statically generated page that displays the post's details. Both the home page and the post pages are generated at build time.

##### Online Resources for Example 2
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [SSG with Dynamic Routes in Next.js](https://dev.to/ivandotv/next-js-static-site-generation-ssg-with-dynamic-routes-3g4p)

#### Example 3: Incremental Static Regeneration (ISR) with Next.js

##### Explanation
In this example, you will implement Incremental Static Regeneration (ISR) in a Next.js application. ISR allows you to update static content after the site has been built and deployed, ensuring that your site remains up-to-date with the latest data. You will use the `revalidate` property in the `getStaticProps` function to specify how often the static content should be regenerated.

##### Example Code
```javascript
// pages/index.js
import React from 'react';

const HomePage = ({ data }) => {
  return (
    <div>
      <h1>Incremental Static Regeneration with Next.js</h1>
      <p>Data fetched from API: {data.title}</p>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
    revalidate: 10, // Revalidate the data every 10 seconds
  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will display the data fetched from the API. The data is fetched at build time, and the HTML content is statically generated. The page will be regenerated on the server every 10 seconds to ensure the data is up-to-date.

##### Online Resources for Example 3
1. [Incremental Static Regeneration Documentation](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [Using ISR with Next.js](https://www.smashingmagazine.com/2021/06/incremental-static-regeneration-nextjs/)

---
## Task 10: Implement SSG with Next.js for Mobile

Static Site Generation (SSG) with Next.js is a powerful method for pre-rendering web pages at build time, resulting in static HTML files that can be served quickly to clients. This approach enhances performance and SEO, as the content is generated once and delivered statically, reducing the need for server-side processing on each request. For mobile applications, SSG is particularly beneficial as it ensures fast load times and a seamless user experience, even on slower network connections. By pre-rendering pages, developers can optimize their mobile web applications for speed and efficiency.

When implementing SSG for mobile with Next.js, it's crucial to focus on responsive design and optimization techniques to ensure that the static pages look good and perform well on various mobile devices. This involves using media queries, flexible layouts, and optimizing images and other assets. Additionally, Next.js provides features like `getStaticProps` and `getStaticPaths` to fetch data at build time and generate static pages accordingly. Understanding how to leverage these features for mobile-specific optimizations can help developers create high-performance web applications that deliver an excellent user experience on mobile devices.

### Online Resources

1. [Next.js Documentation on Static Site Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Next.js Static Site Generation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)

### Examples to Practice

#### Example 1: Basic Static Site Generation with Responsive Design

##### Explanation
In this example, you will create a simple Next.js application with a page that uses static site generation and is optimized for mobile devices. You will use the `getStaticProps` function to fetch data from an API and generate static HTML pages at build time. Additionally, you will apply responsive design techniques to ensure the page looks good on mobile devices.

##### Example Code
```javascript
// pages/index.js
import React from 'react';
import Head from 'next/head';

const HomePage = ({ data }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile Optimized SSG Page</title>
      </Head>
      <h1>Static Site Generated Page for Mobile</h1>
      <p>Data fetched from API: {data.title}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will display data fetched from the API. The data is fetched at build time, and the HTML content is statically generated and served to the client. The page will be styled to look good on mobile devices, demonstrating static site generation with responsive design.

##### Online Resources for Example 1
1. [getStaticProps Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Responsive Design in Next.js](https://nextjs.org/docs/basic-features/layouts)

#### Example 2: Dynamic Routes with SSG for Mobile

##### Explanation
In this example, you will create a Next.js application with dynamic routes and static site generation optimized for mobile devices. You will use the `getStaticPaths` and `getStaticProps` functions to fetch data for each dynamic route and generate static HTML pages at build time. The page will also include responsive design elements to ensure it is optimized for mobile devices.

##### Example Code
```javascript
// pages/posts/[id].js
import React from 'react';
import Head from 'next/head';

const PostPage = ({ post }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{post.title}</title>
      </Head>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';

const HomePage = ({ posts }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile Posts</title>
      </Head>
      <h1>Posts</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will list posts fetched from the API. Clicking on a post will navigate to a statically generated page that displays the post's details. Both the home page and the post pages are generated at build time and optimized for mobile devices.

##### Online Resources for Example 2
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [SSG with Dynamic Routes in Next.js](https://dev.to/ivandotv/next-js-static-site-generation-ssg-with-dynamic-routes-3g4p)

#### Example 3: Incremental Static Regeneration (ISR) for Mobile

##### Explanation
In this example, you will implement Incremental Static Regeneration (ISR) in a Next.js application, optimized for mobile devices. ISR allows you to update static content after the site has been built and deployed, ensuring that your site remains up-to-date with the latest data. You will use the `revalidate` property in the `getStaticProps` function to specify how often the static content should be regenerated.

##### Example Code
```javascript
// pages/index.js
import React from 'react';
import Head from 'next/head';

const HomePage = ({ data }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Mobile Optimized ISR Page</title>
      </Head>
      <h1>Incremental Static Regeneration with Next.js</h1>
      <p>Data fetched from API: {data.title}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await res.json();

  return {
    props: { data },
    revalidate: 10, // Revalidate the data every 10 seconds


  };
}

export default HomePage;
```

##### Expected Output
When you build and run the Next.js application, the home page will display the data fetched from the API. The data is fetched at build time, and the HTML content is statically generated. The page will be regenerated on the server every 10 seconds to ensure the data is up-to-date and optimized for mobile devices.

##### Online Resources for Example 3
1. [Incremental Static Regeneration Documentation](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [Using ISR with Next.js](https://www.smashingmagazine.com/2021/06/incremental-static-regeneration-nextjs/)

---

## Task 11: Study Hybrid Rendering with Next.js

Hybrid rendering in Next.js refers to the ability to use different rendering methods within the same application. Next.js supports Static Site Generation (SSG), Server-Side Rendering (SSR), and Client-Side Rendering (CSR), allowing developers to choose the most suitable rendering method for each page or component. By leveraging hybrid rendering, you can optimize the performance and user experience of your application. For example, you can use SSG for static content that rarely changes, SSR for dynamic content that needs to be up-to-date on each request, and CSR for highly interactive components that depend on user actions.

The flexibility of hybrid rendering in Next.js enables developers to build applications that are both performant and scalable. This approach can improve load times, reduce server load, and enhance SEO. Next.js provides functions like `getStaticProps`, `getServerSideProps`, and `getStaticPaths` to implement these rendering strategies effectively. Understanding how to combine these rendering methods allows developers to create complex applications that deliver the best possible experience for users, regardless of their device or network conditions.

### Online Resources

1. [Next.js Hybrid Rendering](https://nextjs.org/docs/routing/introduction)
2. [Next.js Data Fetching](https://nextjs.org/docs/basic-features/data-fetching)

### Examples to Practice

#### Example 1: Combining SSG and SSR in a Next.js Application

##### Explanation
In this example, you will create a Next.js application that uses both Static Site Generation (SSG) and Server-Side Rendering (SSR). You will use SSG for a static homepage and SSR for a dynamic user profile page. This example demonstrates how to combine these rendering methods to optimize performance and provide up-to-date content.

##### Example Code
```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';

const HomePage = ({ posts }) => {
  return (
    <div>
      <h1>Home Page (Static Site Generated)</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

```javascript
// pages/posts/[id].js
import React from 'react';

const PostPage = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

##### Expected Output
When you build and run the Next.js application, the homepage will list posts fetched from the API, generated at build time (SSG). Clicking on a post will navigate to a dynamically rendered page that displays the post's details (SSR).

##### Online Resources for Example 1
1. [Next.js SSG Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js SSR Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)

#### Example 2: Combining SSG and CSR in a Next.js Application

##### Explanation
In this example, you will create a Next.js application that uses both Static Site Generation (SSG) and Client-Side Rendering (CSR). You will use SSG for a static blog page and CSR for a comments section that users can interact with. This example demonstrates how to pre-render static content and then hydrate interactive components on the client side.

##### Example Code
```javascript
// pages/blog.js
import React from 'react';
import Link from 'next/link';

const BlogPage = ({ posts }) => {
  return (
    <div>
      <h1>Blog Page (Static Site Generated)</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/blog/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default BlogPage;
```

```javascript
// pages/blog/[id].js
import React, { useState, useEffect } from 'react';

const PostPage = ({ post }) => {
  const [comments, setComments] = useState([]);

  useEffect(() => {
    const fetchComments = async () => {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${post.id}/comments`);
      const data = await res.json();
      setComments(data);
    };
    fetchComments();
  }, [post.id]);

  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <h2>Comments</h2>
      <ul>
        {comments.map((comment) => (
          <li key={comment.id}>
            <p>{comment.body}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

##### Expected Output
When you build and run the Next.js application, the blog page will list posts fetched from the API, generated at build time (SSG). Clicking on a post will navigate to a statically generated page that displays the post's details, with the comments section dynamically loaded on the client side (CSR).

##### Online Resources for Example 2
1. [Next.js SSG Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)

#### Example 3: Combining SSR and CSR in a Next.js Application

##### Explanation
In this example, you will create a Next.js application that uses both Server-Side Rendering (SSR) and Client-Side Rendering (CSR). You will use SSR for a product page that fetches product details from an API and CSR for a shopping cart that users can interact with. This example demonstrates how to pre-render dynamic content on the server and hydrate interactive components on the client side.

##### Example Code
```javascript
// pages/products/[id].js
import React, { useState } from 'react';

const ProductPage = ({ product }) => {
  const [cart, setCart] = useState([]);

  const addToCart = () => {
    setCart([...cart, product]);
  };

  return (
    <div>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <button onClick={addToCart}>Add to Cart</button>
      <h2>Shopping Cart</h2>
      <ul>
        {cart.map((item, index) => (
          <li key={index}>
            <p>{item.name}</p>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://fakestoreapi.com/products/${id}`);
  const product = await res.json();

  return {
    props: { product },
  };
}

export default ProductPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';

const HomePage = ({ products }) => {
  return (
    <div>
      <h1>Products</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>
            <Link href={`/products/${product.id}`}>
              <a>{product.title}</a>
            </Link>
          </li>
        ))}
      </ul>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://fakestoreapi.com/products');
  const products = await res.json();

  return {
    props: { products },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will list products fetched from the API, rendered on the server (SSR). Clicking on a product will navigate to a server-rendered page that displays the product's details, with the shopping cart functionality implemented on the client side (CSR).

##### Online Resources for Example 

3
1. [Next.js SSR Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)

---

## Task 12: Implement Hybrid Rendering with Next.js for Mobile

Hybrid rendering in Next.js refers to the use of multiple rendering strategies within a single application. This includes Static Site Generation (SSG), Server-Side Rendering (SSR), and Client-Side Rendering (CSR). By combining these strategies, developers can optimize the performance and user experience of their applications. SSG is used for content that rarely changes, ensuring fast load times. SSR is beneficial for dynamic content that needs to be up-to-date on each request. CSR is used for highly interactive components that rely on user actions. This hybrid approach allows developers to leverage the strengths of each rendering method as needed.

For mobile applications, hybrid rendering can significantly improve performance, load times, and user experience. Mobile devices often have varying network conditions and performance capabilities, making it crucial to deliver content efficiently. Using Next.js, developers can ensure that static content loads quickly with SSG, while dynamic content is rendered on the server with SSR, and interactive elements are managed with CSR. Understanding how to implement and optimize hybrid rendering in Next.js can help developers create responsive, high-performance mobile web applications.

### Online Resources

1. [Next.js Hybrid Rendering](https://nextjs.org/docs/routing/introduction)
2. [Next.js Data Fetching](https://nextjs.org/docs/basic-features/data-fetching)

### Examples to Practice

#### Example 1: Combining SSG and SSR for Mobile

##### Explanation
In this example, you will create a Next.js application that uses both Static Site Generation (SSG) and Server-Side Rendering (SSR) optimized for mobile devices. You will use SSG for a static homepage and SSR for a dynamic user profile page. This example demonstrates how to combine these rendering methods to optimize performance and provide up-to-date content.

##### Example Code
```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';

const HomePage = ({ posts }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Home Page</title>
      </Head>
      <h1>Home Page (Static Site Generated)</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/posts/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default HomePage;
```

```javascript
// pages/posts/[id].js
import React from 'react';
import Head from 'next/head';

const PostPage = ({ post }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{post.title}</title>
      </Head>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

##### Expected Output
When you build and run the Next.js application, the homepage will list posts fetched from the API, generated at build time (SSG). Clicking on a post will navigate to a dynamically rendered page that displays the post's details (SSR). Both pages are optimized for mobile devices with responsive design elements.

##### Online Resources for Example 1
1. [Next.js SSG Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js SSR Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)

#### Example 2: Combining SSG and CSR for Mobile

##### Explanation
In this example, you will create a Next.js application that uses both Static Site Generation (SSG) and Client-Side Rendering (CSR) optimized for mobile devices. You will use SSG for a static blog page and CSR for a comments section that users can interact with. This example demonstrates how to pre-render static content and then hydrate interactive components on the client side.

##### Example Code
```javascript
// pages/blog.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';

const BlogPage = ({ posts }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Blog Page</title>
      </Head>
      <h1>Blog Page (Static Site Generated)</h1>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>
            <Link href={`/blog/${post.id}`}>
              <a>{post.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: { posts },
  };
}

export default BlogPage;
```

```javascript
// pages/blog/[id].js
import React, { useState, useEffect } from 'react';
import Head from 'next/head';

const PostPage = ({ post }) => {
  const [comments, setComments] = useState([]);

  useEffect(() => {
    const fetchComments = async () => {
      const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${post.id}/comments`);
      const data = await res.json();
      setComments(data);
    };
    fetchComments();
  }, [post.id]);

  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{post.title}</title>
      </Head>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
      <h2>Comments</h2>
      <ul>
        {comments.map((comment) => (
          <li key={comment.id}>
            <p>{comment.body}</p>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: { post },
  };
}

export default PostPage;
```

##### Expected Output
When you build and run the Next.js application, the blog page will list posts fetched from the API, generated at build time (SSG). Clicking on a post will navigate

 to a statically generated page that displays the post's details, with the comments section dynamically loaded on the client side (CSR). Both pages are optimized for mobile devices with responsive design elements.

##### Online Resources for Example 2
1. [Next.js SSG Documentation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)

#### Example 3: Combining SSR and CSR for Mobile

##### Explanation
In this example, you will create a Next.js application that uses both Server-Side Rendering (SSR) and Client-Side Rendering (CSR) optimized for mobile devices. You will use SSR for a product page that fetches product details from an API and CSR for a shopping cart that users can interact with. This example demonstrates how to pre-render dynamic content on the server and hydrate interactive components on the client side.

##### Example Code
```javascript
// pages/products/[id].js
import React, { useState } from 'react';
import Head from 'next/head';

const ProductPage = ({ product }) => {
  const [cart, setCart] = useState([]);

  const addToCart = () => {
    setCart([...cart, product]);
  };

  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>{product.name}</title>
      </Head>
      <h1>{product.name}</h1>
      <p>{product.description}</p>
      <button onClick={addToCart}>Add to Cart</button>
      <h2>Shopping Cart</h2>
      <ul>
        {cart.map((item, index) => (
          <li key={index}>
            <p>{item.name}</p>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        p {
          font-size: 18px;
        }
        button {
          font-size: 16px;
          padding: 10px;
          margin: 10px 0;
          background-color: blue;
          color: white;
          border: none;
          cursor: pointer;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          p {
            font-size: 16px;
          }
          button {
            font-size: 14px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps(context) {
  const { id } = context.params;
  const res = await fetch(`https://fakestoreapi.com/products/${id}`);
  const product = await res.json();

  return {
    props: { product },
  };
}

export default ProductPage;
```

```javascript
// pages/index.js
import React from 'react';
import Link from 'next/link';
import Head from 'next/head';

const HomePage = ({ products }) => {
  return (
    <div>
      <Head>
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Products</title>
      </Head>
      <h1>Products</h1>
      <ul>
        {products.map((product) => (
          <li key={product.id}>
            <Link href={`/products/${product.id}`}>
              <a>{product.title}</a>
            </Link>
          </li>
        ))}
      </ul>
      <style jsx>{`
        div {
          padding: 20px;
        }
        h1 {
          font-size: 24px;
        }
        ul {
          list-style: none;
          padding: 0;
        }
        li {
          margin: 10px 0;
        }
        a {
          font-size: 18px;
          color: blue;
          text-decoration: none;
        }
        @media (max-width: 600px) {
          h1 {
            font-size: 20px;
          }
          a {
            font-size: 16px;
          }
        }
      `}</style>
    </div>
  );
};

export async function getServerSideProps() {
  const res = await fetch('https://fakestoreapi.com/products');
  const products = await res.json();

  return {
    props: { products },
  };
}

export default HomePage;
```

##### Expected Output
When you run the Next.js application, the home page will list products fetched from the API, rendered on the server (SSR). Clicking on a product will navigate to a server-rendered page that displays the product's details, with the shopping cart functionality implemented on the client side (CSR). Both pages are optimized for mobile devices with responsive design elements.

##### Online Resources for Example 3
1. [Next.js SSR Documentation](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/data-fetching#fetching-data-on-the-client-side)

---

## Task 13: Study Advanced Data Synchronization Techniques

Advanced data synchronization techniques are crucial for ensuring that data remains consistent and up-to-date across different devices and platforms. In a cross-platform context, such as React Native applications, data synchronization involves keeping the local data store and remote server data in sync, handling offline scenarios, conflict resolution, and ensuring that updates are propagated across all clients. Techniques like real-time data synchronization, delta syncing, and conflict-free replicated data types (CRDTs) play a significant role in achieving efficient and reliable data synchronization.

Implementing advanced data synchronization involves using tools and libraries that provide real-time capabilities, handling offline data storage, and managing network changes seamlessly. Firebase, Apollo Client with GraphQL subscriptions, and other real-time databases offer built-in support for data synchronization, making it easier to keep data consistent across multiple clients. Understanding these techniques allows developers to build responsive and reliable applications that provide a seamless user experience, even in varying network conditions.

### Online Resources

1. [Firebase Real-time Database](https://firebase.google.com/docs/database)
2. [Apollo Client with GraphQL Subscriptions](https://www.apollographql.com/docs/react/data/subscriptions/)

### Examples to Practice

#### Example 1: Real-time Data Synchronization with Firebase

##### Explanation
In this example, you will learn how to use Firebase for real-time data synchronization in a React Native application. Firebase offers real-time capabilities, allowing you to synchronize data across clients instantly. You will set up a Firebase project, integrate it with your React Native app, and implement real-time data synchronization for a simple chat application.

##### Example Code
```javascript
// Install Firebase: npm install @react-native-firebase/app @react-native-firebase/database

// firebase.js
import firebase from '@react-native-firebase/app';
import '@react-native-firebase/database';

const firebaseConfig = {
  apiKey: "YOUR_API_KEY",
  authDomain: "YOUR_AUTH_DOMAIN",
  databaseURL: "YOUR_DATABASE_URL",
  projectId: "YOUR_PROJECT_ID",
  storageBucket: "YOUR_STORAGE_BUCKET",
  messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
  appId: "YOUR_APP_ID"
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

export default firebase.database();

// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import database from './firebase';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState('');

  useEffect(() => {
    const onChildAdd = database()
      .ref('/messages')
      .on('child_added', snapshot => {
        setMessages(messages => [...messages, snapshot.val()]);
      });

    // Stop listening for updates when no longer required
    return () => database().ref('/messages').off('child_added', onChildAdd);
  }, []);

  const sendMessage = () => {
    const newMessage = { text, timestamp: new Date().toISOString() };
    database().ref('/messages').push(newMessage);
    setText('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item.text}</Text>}
      />
      <TextInput
        value={text}
        onChangeText={setText}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send and receive messages in real-time. Each message is instantly synchronized across all connected clients using Firebase's real-time database.

##### Online Resources for Example 1
1. [Firebase Real-time Database Documentation](https://firebase.google.com/docs/database)
2. [React Native Firebase Documentation](https://rnfirebase.io/)

#### Example 2: Data Synchronization with Apollo Client and GraphQL Subscriptions

##### Explanation
In this example, you will learn how to use Apollo Client with GraphQL subscriptions for real-time data synchronization in a React Native application. GraphQL subscriptions enable you to receive real-time updates from the server, making it ideal for applications that require instant data updates, such as live chat or notifications.

##### Example Code
```javascript
// Install required packages: npm install @apollo/client graphql subscriptions-transport-ws

// server.js (GraphQL server setup with subscriptions)
const { ApolloServer, gql, PubSub } = require('apollo-server');
const pubsub = new PubSub();

const typeDefs = gql`
  type Message {
    id: ID!
    text: String!
    timestamp: String!
  }

  type Query {
    messages: [Message!]
  }

  type Mutation {
    sendMessage(text: String!): Message!
  }

  type Subscription {
    messageSent: Message!
  }
`;

const messages = [];

const resolvers = {
  Query: {
    messages: () => messages,
  },
  Mutation: {
    sendMessage: (_, { text }) => {
      const message = { id: messages.length + 1, text, timestamp: new Date().toISOString() };
      messages.push(message);
      pubsub.publish('MESSAGE_SENT', { messageSent: message });
      return message;
    },
  },
  Subscription: {
    messageSent: {
      subscribe: () => pubsub.asyncIterator('MESSAGE_SENT'),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });
server.listen().then(({ url }) => console.log(`Server ready at ${url}`));
```

```javascript
// App.js (React Native client setup)
import React, { useEffect, useState } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql, useSubscription, HttpLink, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: `ws://localhost:4000/graphql`,
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const GET_MESSAGES = gql`
  query GetMessages {
    messages {
      id
      text
      timestamp
    }
  }
`;

const SEND_MESSAGE = gql`
  mutation SendMessage($text: String!) {
    sendMessage(text: $text) {
      id
      text
      timestamp
    }
  }
`;

const MESSAGE_SENT = gql`
  subscription MessageSent {
    messageSent {
      id
      text
      timestamp
    }
  }
`;

const Messages = () => {
  const { data, loading } = useQuery(GET_MESSAGES);
  const { data: subscriptionData } = useSubscription(MESSAGE_SENT);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState('');
  const [sendMessage] = useMutation(SEND_MESSAGE);

  useEffect(() => {
    if (data) {
      setMessages(data.messages);
    }
  }, [data]);

  useEffect(() => {
    if (subscriptionData) {
      setMessages((prevMessages) => [...prevMessages, subscriptionData.messageSent]);
    }
  }, [subscriptionData]);

  const handleSend = () => {
    sendMessage({ variables: { text } });
    setText('');
  };

  if (loading) return <Text>Loading...</Text>;

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.text}</Text>}
      />
      <TextInput
        value={text}
        onChangeText={setText}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={handleSend} />
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <Messages />
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the GraphQL server and the React Native app, you will be able to send and receive messages in real-time. Each message is instantly synchronized across all connected clients using GraphQL subscriptions.

##### Online Resources for Example 2
1. [Apollo Client Subscriptions Documentation](https://www.apollographql.com/docs/react/data/subscriptions/)
2. [GraphQL Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)

#### Example 3: Offline Data Synchronization with Redux Offline

##### Explanation
In this example, you will learn how to implement offline data synchronization using Redux Offline in a React Native application. Redux Offline provides tools for handling offline capabilities, including queuing actions to

 be executed when the device goes back online, and syncing local data with the server.

##### Example Code
```javascript
// Install required packages: npm install @reduxjs/toolkit redux-offline axios

// store.js
import { configureStore } from '@reduxjs/toolkit';
import { offlineMiddleware, offlineEnhancer } from 'redux-offline';
import offlineConfig from 'redux-offline/lib/defaults';
import axios from 'axios';

const apiMiddleware = store => next => action => {
  if (action.type === 'SEND_MESSAGE') {
    const { text, timestamp } = action.payload;
    axios.post('https://jsonplaceholder.typicode.com/posts', { text, timestamp });
  }
  return next(action);
};

const store = configureStore({
  reducer: (state = { messages: [] }, action) => {
    switch (action.type) {
      case 'ADD_MESSAGE':
        return { ...state, messages: [...state.messages, action.payload] };
      default:
        return state;
    }
  },
  enhancers: [offlineEnhancer(offlineConfig)],
  middleware: getDefaultMiddleware => getDefaultMiddleware().concat(apiMiddleware, offlineMiddleware(offlineConfig)),
});

export default store;

// App.js
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import store from './store';

const Messages = () => {
  const dispatch = useDispatch();
  const messages = useSelector(state => state.messages);
  const [text, setText] = useState('');

  const sendMessage = () => {
    const timestamp = new Date().toISOString();
    dispatch({ type: 'ADD_MESSAGE', payload: { text, timestamp } });
    dispatch({ type: 'SEND_MESSAGE', payload: { text, timestamp } });
    setText('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item.text}</Text>}
      />
      <TextInput
        value={text}
        onChangeText={setText}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

const App = () => {
  return (
    <Provider store={store}>
      <Messages />
    </Provider>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send messages that are stored locally and synchronized with the server when the device goes back online. Redux Offline handles the queuing and synchronization of actions, ensuring data consistency even when the device is offline.

##### Online Resources for Example 3
1. [Redux Offline Documentation](https://redux-offline.gitbook.io/redux-offline/)
2. [Redux Toolkit Documentation](https://redux-toolkit.js.org/)

---

## Task 14: Implement Real-Time Data Sync with GraphQL Subscriptions


GraphQL subscriptions are a powerful feature that allows clients to receive real-time updates from the server. This capability is particularly useful in applications where timely updates are crucial, such as chat applications, live sports scores, or collaborative tools. Subscriptions in GraphQL work by establishing a WebSocket connection between the client and the server. Whenever the server has new data that matches the subscription query, it pushes the update to the client, ensuring that the data displayed in the application is always up-to-date.

Implementing real-time data sync with GraphQL subscriptions involves setting up a GraphQL server that supports subscriptions and configuring the client to handle these updates. Apollo Client is a popular choice for managing GraphQL data on the client side and provides built-in support for subscriptions. By leveraging Apollo Client with GraphQL subscriptions, developers can create highly responsive applications that provide an excellent user experience by ensuring that users always see the most current data without the need for manual refreshes.

### Online Resources

1. [GraphQL Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)
2. [Using Subscriptions with Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)

### Examples to Practice

#### Example 1: Setting Up a GraphQL Server with Subscriptions

##### Explanation
In this example, you will set up a GraphQL server with subscription support. You will define a schema with a subscription type and use the Apollo Server to handle subscription requests. This example will help you understand the server-side setup required for enabling real-time data updates using GraphQL subscriptions.

##### Example Code
```javascript
// server.js
const { ApolloServer, gql, PubSub } = require('apollo-server');
const pubsub = new PubSub();

const typeDefs = gql`
  type Message {
    id: ID!
    text: String!
    timestamp: String!
  }

  type Query {
    messages: [Message!]
  }

  type Mutation {
    sendMessage(text: String!): Message!
  }

  type Subscription {
    messageSent: Message!
  }
`;

const messages = [];

const resolvers = {
  Query: {
    messages: () => messages,
  },
  Mutation: {
    sendMessage: (_, { text }) => {
      const message = { id: messages.length + 1, text, timestamp: new Date().toISOString() };
      messages.push(message);
      pubsub.publish('MESSAGE_SENT', { messageSent: message });
      return message;
    },
  },
  Subscription: {
    messageSent: {
      subscribe: () => pubsub.asyncIterator('MESSAGE_SENT'),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });
server.listen().then(({ url }) => console.log(`Server ready at ${url}`));
```

##### Expected Output
When you run the GraphQL server, it will be ready to handle subscription requests. You can test the setup using a GraphQL client like Apollo Studio or GraphiQL, where you can send subscription queries and see real-time updates as new messages are sent.

##### Online Resources for Example 1
1. [Apollo Server Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)
2. [GraphQL Subscriptions with Apollo Server](https://www.howtographql.com/graphql-js/7-subscriptions/)

#### Example 2: Configuring Apollo Client for Subscriptions in React Native

##### Explanation
In this example, you will configure Apollo Client in a React Native application to handle GraphQL subscriptions. You will set up the Apollo Client with WebSocket support and create a component that subscribes to real-time updates. This example will help you understand how to integrate subscription functionality into a React Native application.

##### Example Code
```javascript
// Install required packages: npm install @apollo/client graphql subscriptions-transport-ws

// App.js
import React, { useEffect, useState } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql, useSubscription, HttpLink, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: `ws://localhost:4000/graphql`,
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const GET_MESSAGES = gql`
  query GetMessages {
    messages {
      id
      text
      timestamp
    }
  }
`;

const SEND_MESSAGE = gql`
  mutation SendMessage($text: String!) {
    sendMessage(text: $text) {
      id
      text
      timestamp
    }
  }
`;

const MESSAGE_SENT = gql`
  subscription MessageSent {
    messageSent {
      id
      text
      timestamp
    }
  }
`;

const Messages = () => {
  const { data, loading } = useQuery(GET_MESSAGES);
  const { data: subscriptionData } = useSubscription(MESSAGE_SENT);
  const [messages, setMessages] = useState([]);
  const [text, setText] = useState('');
  const [sendMessage] = useMutation(SEND_MESSAGE);

  useEffect(() => {
    if (data) {
      setMessages(data.messages);
    }
  }, [data]);

  useEffect(() => {
    if (subscriptionData) {
      setMessages((prevMessages) => [...prevMessages, subscriptionData.messageSent]);
    }
  }, [subscriptionData]);

  const handleSend = () => {
    sendMessage({ variables: { text } });
    setText('');
  };

  if (loading) return <Text>Loading...</Text>;

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.text}</Text>}
      />
      <TextInput
        value={text}
        onChangeText={setText}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={handleSend} />
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <Messages />
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the React Native application, you will be able to send and receive messages in real-time. The messages will be updated instantly across all connected clients using GraphQL subscriptions.

##### Online Resources for Example 2
1. [Apollo Client Subscriptions Documentation](https://www.apollographql.com/docs/react/data/subscriptions/)
2. [Using Subscriptions with Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)

#### Example 3: Real-Time Notifications with GraphQL Subscriptions

##### Explanation
In this example, you will implement real-time notifications using GraphQL subscriptions in a React Native application. You will create a notification system where users receive instant updates when a new event occurs. This example demonstrates how to use GraphQL subscriptions to provide real-time notifications to users.

##### Example Code
```javascript
// server.js (GraphQL server setup with subscriptions)
const { ApolloServer, gql, PubSub } = require('apollo-server');
const pubsub = new PubSub();

const typeDefs = gql`
  type Notification {
    id: ID!
    message: String!
    timestamp: String!
  }

  type Query {
    notifications: [Notification!]
  }

  type Mutation {
    createNotification(message: String!): Notification!
  }

  type Subscription {
    notificationCreated: Notification!
  }
`;

const notifications = [];

const resolvers = {
  Query: {
    notifications: () => notifications,
  },
  Mutation: {
    createNotification: (_, { message }) => {
      const notification = { id: notifications.length + 1, message, timestamp: new Date().toISOString() };
      notifications.push(notification);
      pubsub.publish('NOTIFICATION_CREATED', { notificationCreated: notification });
      return notification;
    },
  },
  Subscription: {
    notificationCreated: {
      subscribe: () => pubsub.asyncIterator('NOTIFICATION_CREATED'),
    },
  },
};

const server = new ApolloServer({ typeDefs, resolvers });
server.listen().then(({ url }) => console.log(`Server ready at ${url}`));
```

```javascript
// App.js (React Native client setup)
import React, { useEffect, useState } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql, useSubscription, HttpLink, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'http://localhost:4000/',
});

const wsLink = new WebSocketLink({
  uri: `ws://localhost:4000/graphql`,


  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const GET_NOTIFICATIONS = gql`
  query GetNotifications {
    notifications {
      id
      message
      timestamp
    }
  }
`;

const CREATE_NOTIFICATION = gql`
  mutation CreateNotification($message: String!) {
    createNotification(message: $message) {
      id
      message
      timestamp
    }
  }
`;

const NOTIFICATION_CREATED = gql`
  subscription NotificationCreated {
    notificationCreated {
      id
      message
      timestamp
    }
  }
`;

const Notifications = () => {
  const { data, loading } = useQuery(GET_NOTIFICATIONS);
  const { data: subscriptionData } = useSubscription(NOTIFICATION_CREATED);
  const [notifications, setNotifications] = useState([]);
  const [message, setMessage] = useState('');
  const [createNotification] = useMutation(CREATE_NOTIFICATION);

  useEffect(() => {
    if (data) {
      setNotifications(data.notifications);
    }
  }, [data]);

  useEffect(() => {
    if (subscriptionData) {
      setNotifications((prevNotifications) => [...prevNotifications, subscriptionData.notificationCreated]);
    }
  }, [subscriptionData]);

  const handleCreate = () => {
    createNotification({ variables: { message } });
    setMessage('');
  };

  if (loading) return <Text>Loading...</Text>;

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={notifications}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.message}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a notification"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Create Notification" onPress={handleCreate} />
    </View>
  );
};

const App = () => {
  return (
    <ApolloProvider client={client}>
      <Notifications />
    </ApolloProvider>
  );
};

export default App;
```

##### Expected Output
When you run the GraphQL server and the React Native application, you will be able to create notifications that are instantly synchronized across all connected clients. Users will receive real-time notifications as new events occur.

##### Online Resources for Example 3
1. [GraphQL Subscriptions](https://www.apollographql.com/docs/apollo-server/data/subscriptions/)
2. [Apollo Client Subscriptions Documentation](https://www.apollographql.com/docs/react/data/subscriptions/)

---

## Task 15: Study Secure Storage Solutions

Secure storage is essential for protecting sensitive data in mobile applications. This involves securely storing user credentials, tokens, sensitive information, and other confidential data that should not be accessible to unauthorized users. In the context of React Native, secure storage solutions are critical because mobile devices are often susceptible to various security threats, including theft, malware, and unauthorized access. Secure storage helps ensure that even if a device is compromised, the sensitive data remains protected.

There are several libraries and approaches available for implementing secure storage in React Native applications. These include using native keychains (iOS) and keystores (Android), as well as third-party libraries like `react-native-keychain` and `react-native-sensitive-info`. These libraries provide a high level of security by encrypting the stored data and ensuring that it is only accessible through secure APIs. Understanding how to implement and use these secure storage solutions is vital for any developer aiming to build secure mobile applications.

### Online Resources

1. [React Native Security Best Practices](https://reactnative.dev/docs/security)
2. [Using Secure Storage in React Native](https://www.digitalocean.com/community/tutorials/using-secure-storage-in-react-native-with-react-native-keychain)

### Examples to Practice

#### Example 1: Using `react-native-keychain` for Secure Storage

##### Explanation
In this example, you will learn how to use the `react-native-keychain` library to store and retrieve sensitive data securely in a React Native application. The `react-native-keychain` library provides a simple API for accessing the keychain services on iOS and the keystore services on Android, making it an excellent choice for secure storage.

##### Example Code
```javascript
// Install the library: npm install react-native-keychain

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeCredentials = async () => {
    await Keychain.setGenericPassword(username, password);
    alert('Credentials stored successfully!');
  };

  const retrieveCredentials = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials) {
      setRetrievedData(`Username: ${credentials.username}, Password: ${credentials.password}`);
    } else {
      alert('No credentials stored');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={username}
        onChangeText={setUsername}
        placeholder="Username"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={password}
        onChangeText={setPassword}
        placeholder="Password"
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Credentials" onPress={storeCredentials} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to store and retrieve credentials securely. Storing the credentials will save them in the keychain/keystore, and retrieving them will display the stored username and password.

##### Online Resources for Example 1
1. [React Native Keychain GitHub](https://github.com/oblador/react-native-keychain)
2. [Using React Native Keychain](https://medium.com/@charpeni/using-keychain-in-react-native-1b9d3d6f4621)

#### Example 2: Using `react-native-sensitive-info` for Secure Storage

##### Explanation
In this example, you will use the `react-native-sensitive-info` library to securely store sensitive information in a React Native application. This library provides encryption for the stored data and ensures it is only accessible through secure APIs.

##### Example Code
```javascript
// Install the library: npm install react-native-sensitive-info

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import SInfo from 'react-native-sensitive-info';

const App = () => {
  const [key, setKey] = useState('');
  const [value, setValue] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeData = async () => {
    await SInfo.setItem(key, value, {
      sharedPreferencesName: 'mySharedPrefs',
      keychainService: 'myKeychain',
    });
    alert('Data stored successfully!');
  };

  const retrieveData = async () => {
    const data = await SInfo.getItem(key, {
      sharedPreferencesName: 'mySharedPrefs',
      keychainService: 'myKeychain',
    });
    setRetrievedData(data ? `Key: ${key}, Value: ${data}` : 'No data found');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={key}
        onChangeText={setKey}
        placeholder="Key"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={value}
        onChangeText={setValue}
        placeholder="Value"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to store and retrieve data securely. Storing the data will save it securely, and retrieving it will display the stored key and value.

##### Online Resources for Example 2
1. [React Native Sensitive Info GitHub](https://github.com/mCodex/react-native-sensitive-info)
2. [Using React Native Sensitive Info](https://medium.com/@swapnil.bhol/react-native-sensitive-info-a-practical-guide-e3c5939d4c05)

#### Example 3: Using Secure Storage with Expo Secure Store

##### Explanation
In this example, you will use Expo's Secure Store module to store and retrieve sensitive data securely in a React Native application. Expo Secure Store provides a simple API for securely storing key-value pairs on the device, using the keychain services on iOS and the keystore on Android.

##### Example Code
```javascript
// Install Expo Secure Store: expo install expo-secure-store

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [key, setKey] = useState('');
  const [value, setValue] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeData = async () => {
    await SecureStore.setItemAsync(key, value);
    alert('Data stored successfully!');
  };

  const retrieveData = async () => {
    const data = await SecureStore.getItemAsync(key);
    setRetrievedData(data ? `Key: ${key}, Value: ${data}` : 'No data found');
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={key}
        onChangeText={setKey}
        placeholder="Key"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={value}
        onChangeText={setValue}
        placeholder="Value"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to store and retrieve data securely using Expo Secure Store. Storing the data will save it securely, and retrieving it will display the stored key and value.

##### Online Resources for Example 3
1. [Expo Secure Store Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
2. [Securely Storing Data in React Native with Expo Secure Store](https://docs.expo.dev/guides/securestore/)

---

## Task 16: Implement Secure Storage with SecureStore

Secure storage is a critical aspect of mobile application development, especially when dealing with sensitive data such as user credentials, tokens, and other private information. Expo SecureStore is a module provided by Expo that enables developers to securely store key-value pairs on a device. It uses the keychain services on iOS and the keystore on Android, ensuring that data is stored in a secure and encrypted manner. This helps protect the data from unauthorized access and ensures that even if the device is compromised, the sensitive information remains secure.

Implementing secure storage with Expo SecureStore is straightforward and involves using its simple API to store, retrieve, and delete data securely. SecureStore ensures that the data is encrypted and safely stored, making it an ideal solution for handling sensitive data in React Native applications. By leveraging SecureStore, developers can enhance the security of their applications, provide better user privacy, and comply with security best practices and regulations.

### Online Resources

1. [Expo SecureStore Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
2. [Securely Storing Data in React Native with Expo Secure Store](https://docs.expo.dev/guides/securestore/)

### Examples to Practice

#### Example 1: Basic Secure Storage Operations with SecureStore

##### Explanation
In this example, you will learn how to perform basic secure storage operations using Expo SecureStore. This includes storing a key-value pair, retrieving the value, and deleting the key. These operations are fundamental for any application that needs to manage sensitive data securely.

##### Example Code
```javascript
// Install Expo Secure Store: expo install expo-secure-store

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [key, setKey] = useState('');
  const [value, setValue] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeData = async () => {
    await SecureStore.setItemAsync(key, value);
    alert('Data stored successfully!');
  };

  const retrieveData = async () => {
    const data = await SecureStore.getItemAsync(key);
    setRetrievedData(data ? `Key: ${key}, Value: ${data}` : 'No data found');
  };

  const deleteData = async () => {
    await SecureStore.deleteItemAsync(key);
    alert('Data deleted successfully!');
    setRetrievedData(null);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={key}
        onChangeText={setKey}
        placeholder="Key"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={value}
        onChangeText={setValue}
        placeholder="Value"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} style={{ marginTop: 10 }} />
      <Button title="Delete Data" onPress={deleteData} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to store, retrieve, and delete data securely using Expo SecureStore. You can enter a key and value, store them, retrieve the stored value, and delete the stored data, verifying that the operations work as expected.

##### Online Resources for Example 1
1. [Expo SecureStore Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
2. [Using SecureStore in React Native](https://blog.logrocket.com/how-to-securely-store-data-in-expo-apps-with-securestore/)

#### Example 2: Storing User Credentials Securely with SecureStore

##### Explanation
In this example, you will implement secure storage for user credentials using Expo SecureStore. This involves securely storing a user's username and password, retrieving them when needed, and ensuring that the data is only accessible through secure APIs. This is particularly useful for applications that require user authentication.

##### Example Code
```javascript
// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedCredentials, setRetrievedCredentials] = useState(null);

  const storeCredentials = async () => {
    await SecureStore.setItemAsync('username', username);
    await SecureStore.setItemAsync('password', password);
    alert('Credentials stored successfully!');
  };

  const retrieveCredentials = async () => {
    const storedUsername = await SecureStore.getItemAsync('username');
    const storedPassword = await SecureStore.getItemAsync('password');
    if (storedUsername && storedPassword) {
      setRetrievedCredentials(`Username: ${storedUsername}, Password: ${storedPassword}`);
    } else {
      alert('No credentials stored');
    }
  };

  const deleteCredentials = async () => {
    await SecureStore.deleteItemAsync('username');
    await SecureStore.deleteItemAsync('password');
    alert('Credentials deleted successfully!');
    setRetrievedCredentials(null);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={username}
        onChangeText={setUsername}
        placeholder="Username"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={password}
        onChangeText={setPassword}
        placeholder="Password"
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Credentials" onPress={storeCredentials} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} style={{ marginTop: 10 }} />
      <Button title="Delete Credentials" onPress={deleteCredentials} style={{ marginTop: 10 }} />
      {retrievedCredentials && <Text>{retrievedCredentials}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to securely store user credentials (username and password) using Expo SecureStore. You can retrieve the stored credentials to verify they are stored correctly and delete them when no longer needed.

##### Online Resources for Example 2
1. [Storing User Credentials Securely in React Native](https://www.digitalocean.com/community/tutorials/using-secure-storage-in-react-native-with-react-native-keychain)
2. [SecureStore Usage in Expo](https://docs.expo.dev/versions/latest/sdk/securestore/)

#### Example 3: Encrypting and Storing Sensitive Data with SecureStore

##### Explanation
In this example, you will learn how to securely store and retrieve encrypted sensitive data using Expo SecureStore. This includes storing sensitive information such as tokens or personal data securely and ensuring that the data remains encrypted and inaccessible to unauthorized users.

##### Example Code
```javascript
// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [dataKey, setDataKey] = useState('');
  const [dataValue, setDataValue] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeSensitiveData = async () => {
    await SecureStore.setItemAsync(dataKey, dataValue, {
      keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
    });
    alert('Sensitive data stored securely!');
  };

  const retrieveSensitiveData = async () => {
    const data = await SecureStore.getItemAsync(dataKey, {
      keychainAccessible: SecureStore.WHEN_UNLOCKED_THIS_DEVICE_ONLY,
    });
    setRetrievedData(data ? `Key: ${dataKey}, Value: ${data}` : 'No data found');
  };

  const deleteSensitiveData = async () => {
    await SecureStore.deleteItemAsync(dataKey);
    alert('Sensitive data deleted successfully!');
    setRetrievedData(null);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={dataKey}
        onChangeText={setDataKey}
        placeholder="Key"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={dataValue}
        onChangeText={setDataValue}
        placeholder="Value"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeSensitiveData} />
      <Button title="Retrieve Data" onPress={retrieveSensitiveData} style={{ marginTop: 10 }} />
      <Button title="Delete Data" onPress={deleteSensitiveData} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output


When you run the app, you will be able to securely store, retrieve, and delete encrypted sensitive data using Expo SecureStore. You can verify that the data is stored securely and remains protected from unauthorized access.

##### Online Resources for Example 3
1. [SecureStore Options and Configuration](https://docs.expo.dev/versions/latest/sdk/securestore/#securestoreoptions)
2. [Handling Sensitive Data in React Native with SecureStore](https://docs.expo.dev/guides/securestore/)

---

## Task 17: Study Data Encryption Techniques

Data encryption is a crucial technique for protecting sensitive information in mobile applications. It involves converting plain text data into an unreadable format using an encryption algorithm and a key. Only authorized parties with the correct decryption key can convert the data back to its readable form. This ensures that even if the data is intercepted by an unauthorized party, it cannot be understood or misused. In the context of React Native applications, encryption is vital for safeguarding user credentials, personal information, and other confidential data stored on the device or transmitted over networks.

There are several encryption algorithms available, including symmetric encryption (e.g., AES) and asymmetric encryption (e.g., RSA). Symmetric encryption uses the same key for both encryption and decryption, while asymmetric encryption uses a pair of public and private keys. React Native developers can leverage libraries such as `crypto-js`, `react-native-encrypted-storage`, and `react-native-keychain` to implement encryption and secure storage in their applications. Understanding these techniques allows developers to enhance the security of their applications, protect user data, and comply with data protection regulations.

### Online Resources

1. [Cryptography and Encryption](https://www.ssl2buy.com/wiki/what-is-cryptography-and-encryption)
2. [Using Encryption in React Native](https://heartbeat.fritz.ai/secure-your-react-native-apps-with-encryption-d580a0b519d5)

### Examples to Practice

#### Example 1: Encrypting and Decrypting Data with `crypto-js`

##### Explanation
In this example, you will learn how to use the `crypto-js` library to encrypt and decrypt data in a React Native application. `crypto-js` is a widely-used library that provides standard cryptographic algorithms, including AES encryption. You will encrypt sensitive data before storing it and decrypt it when needed.

##### Example Code
```javascript
// Install the library: npm install crypto-js

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import CryptoJS from 'crypto-js';

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');

  const secretKey = 'mySecretKey';

  const encryptData = () => {
    const ciphertext = CryptoJS.AES.encrypt(plainText, secretKey).toString();
    setEncryptedText(ciphertext);
  };

  const decryptData = () => {
    const bytes = CryptoJS.AES.decrypt(encryptedText, secretKey);
    const originalText = bytes.toString(CryptoJS.enc.Utf8);
    setDecryptedText(originalText);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={plainText}
        onChangeText={setPlainText}
        placeholder="Enter plain text"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Encrypt" onPress={encryptData} />
      {encryptedText ? <Text>Encrypted Text: {encryptedText}</Text> : null}
      <Button title="Decrypt" onPress={decryptData} style={{ marginTop: 10 }} />
      {decryptedText ? <Text>Decrypted Text: {decryptedText}</Text> : null}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to enter plain text, encrypt it to produce an unreadable string, and then decrypt it back to its original form. This demonstrates how to securely encrypt and decrypt data using the `crypto-js` library.

##### Online Resources for Example 1
1. [crypto-js GitHub](https://github.com/brix/crypto-js)
2. [AES Encryption and Decryption with `crypto-js`](https://www.geeksforgeeks.org/how-to-encrypt-and-decrypt-data-in-node-js/)

#### Example 2: Secure Storage with `react-native-encrypted-storage`

##### Explanation
In this example, you will use the `react-native-encrypted-storage` library to securely store encrypted data in a React Native application. This library provides secure storage solutions using encryption, ensuring that sensitive data is stored safely and can only be accessed by authorized users.

##### Example Code
```javascript
// Install the library: npm install react-native-encrypted-storage

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import EncryptedStorage from 'react-native-encrypted-storage';

const App = () => {
  const [key, setKey] = useState('');
  const [value, setValue] = useState('');
  const [retrievedData, setRetrievedData] = useState(null);

  const storeData = async () => {
    try {
      await EncryptedStorage.setItem(key, value);
      alert('Data stored successfully!');
    } catch (error) {
      console.error(error);
    }
  };

  const retrieveData = async () => {
    try {
      const data = await EncryptedStorage.getItem(key);
      setRetrievedData(data ? `Key: ${key}, Value: ${data}` : 'No data found');
    } catch (error) {
      console.error(error);
    }
  };

  const deleteData = async () => {
    try {
      await EncryptedStorage.removeItem(key);
      alert('Data deleted successfully!');
      setRetrievedData(null);
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={key}
        onChangeText={setKey}
        placeholder="Key"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={value}
        onChangeText={setValue}
        placeholder="Value"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} style={{ marginTop: 10 }} />
      <Button title="Delete Data" onPress={deleteData} style={{ marginTop: 10 }} />
      {retrievedData && <Text>{retrievedData}</Text>}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to store, retrieve, and delete encrypted data securely using `react-native-encrypted-storage`. You can enter a key and value, store them securely, retrieve the stored value, and delete the stored data.

##### Online Resources for Example 2
1. [react-native-encrypted-storage GitHub](https://github.com/emeraldsanto/react-native-encrypted-storage)
2. [Using Encrypted Storage in React Native](https://reactnativeexample.com/encrypted-storage-for-react-native-apps/)

#### Example 3: Encrypting Data with RSA using `node-forge`

##### Explanation
In this example, you will use the `node-forge` library to perform RSA encryption and decryption in a React Native application. RSA is an asymmetric encryption algorithm that uses a pair of public and private keys for encryption and decryption, respectively.

##### Example Code
```javascript
// Install the library: npm install node-forge

// App.js
import React, { useState } from 'react';
import { Text, View, TextInput, Button } from 'react-native';
import forge from 'node-forge';

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');

  const generateKeyPair = () => {
    const { publicKey, privateKey } = forge.pki.rsa.generateKeyPair(2048);
    return { publicKey, privateKey };
  };

  const { publicKey, privateKey } = generateKeyPair();

  const encryptData = () => {
    const encrypted = publicKey.encrypt(plainText, 'RSA-OAEP');
    setEncryptedText(forge.util.encode64(encrypted));
  };

  const decryptData = () => {
    const encrypted = forge.util.decode64(encryptedText);
    const decrypted = privateKey.decrypt(encrypted, 'RSA-OAEP');
    setDecryptedText(decrypted);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={plainText}
        onChangeText={setPlainText}
        placeholder="Enter plain text"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Encrypt" onPress={encryptData} />
      {encryptedText ? <Text>Encrypted Text: {encryptedText}</Text> : null}
      <Button title="Decrypt" onPress={decryptData} style={{ marginTop: 10 }} />
      {decryptedText ? <Text>Decrypted Text: {decryptedText}</Text> : null}
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to enter plain text, encrypt it using RSA, and then decrypt it back to its original form. This demonstrates how to securely encrypt and decrypt data using the RSA algorithm with the `node-forge` library.

##### Online Resources for Example

 3
1. [node-forge GitHub](https://github.com/digitalbazaar/forge)
2. [RSA Encryption and Decryption with node-forge](https://www.cryptography.io/en/latest/hazmat/primitives/asymmetric/rsa/)

---

## Task 18: Implement Data Encryption with Web Crypto API

The Web Crypto API is a powerful and flexible interface provided by modern web browsers for performing cryptographic operations. It allows developers to perform various encryption and decryption tasks, generate cryptographic keys, and securely store and manage those keys. This API supports both symmetric and asymmetric encryption, enabling a wide range of security implementations. By leveraging the Web Crypto API, developers can enhance the security of their applications by encrypting sensitive data such as user credentials, personal information, and other confidential data.

In the context of React Native, implementing the Web Crypto API requires some additional considerations since React Native does not directly support this API out of the box. Developers often rely on polyfills or compatible libraries like `react-native-crypto` or `react-native-webview` to access Web Crypto functionalities. Understanding how to integrate these tools allows developers to bring the robust security features of the Web Crypto API into their React Native applications, ensuring data is protected both at rest and in transit.

### Online Resources

1. [MDN Web Docs: Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
2. [Web Crypto API Example](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API/Examples)

### Examples to Practice

#### Example 1: Encrypting and Decrypting Data with Web Crypto API in React Native using `react-native-webview`

##### Explanation
In this example, you will learn how to use the Web Crypto API for data encryption and decryption in a React Native application via `react-native-webview`. This approach leverages a web view to execute JavaScript code that utilizes the Web Crypto API, allowing you to perform encryption and decryption tasks.

##### Example Code
```javascript
// Install the library: npm install react-native-webview

// App.js
import React, { useState, useRef } from 'react';
import { Text, View, TextInput, Button, Alert } from 'react-native';
import { WebView } from 'react-native-webview';

const App = () => {
  const webviewRef = useRef(null);
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');

  const secretKey = 'mySecretKey';

  const generateScript = (plainText, secretKey) => `
    (function() {
      const encoder = new TextEncoder();
      const keyData = encoder.encode('${secretKey}');
      const textData = encoder.encode('${plainText}');
      
      crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt'])
        .then(key => {
          const iv = window.crypto.getRandomValues(new Uint8Array(12));
          return crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, textData)
            .then(encrypted => {
              window.ReactNativeWebView.postMessage(JSON.stringify({
                iv: Array.from(iv),
                encrypted: Array.from(new Uint8Array(encrypted))
              }));
            });
        }).catch(console.error);
    })();
  `;

  const handleEncryption = () => {
    if (webviewRef.current) {
      const script = generateScript(plainText, secretKey);
      webviewRef.current.injectJavaScript(script);
    }
  };

  const handleMessage = event => {
    const data = JSON.parse(event.nativeEvent.data);
    const iv = new Uint8Array(data.iv);
    const encrypted = new Uint8Array(data.encrypted);

    // Store the encrypted text and IV
    setEncryptedText(btoa(String.fromCharCode(...encrypted)));
    Alert.alert('Encryption complete!', `IV: ${iv.toString()}\nEncrypted Text: ${encrypted.toString()}`);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={plainText}
        onChangeText={setPlainText}
        placeholder="Enter plain text"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Encrypt" onPress={handleEncryption} />
      <Text>Encrypted Text: {encryptedText}</Text>
      <WebView
        ref={webviewRef}
        style={{ height: 0, width: 0 }}
        onMessage={handleMessage}
        originWhitelist={['*']}
        javaScriptEnabled
      />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to enter plain text and encrypt it using the Web Crypto API executed within a web view. The encrypted text and IV will be displayed, demonstrating the successful encryption of the data.

##### Online Resources for Example 1
1. [Web Crypto API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
2. [react-native-webview Documentation](https://github.com/react-native-webview/react-native-webview)

#### Example 2: Decrypting Data with Web Crypto API in React Native using `react-native-webview`

##### Explanation
In this example, you will use the Web Crypto API to decrypt data that was encrypted using the same API. This involves setting up a similar `react-native-webview` component to handle the decryption process.

##### Example Code
```javascript
// App.js
import React, { useState, useRef } from 'react';
import { Text, View, TextInput, Button, Alert } from 'react-native';
import { WebView } from 'react-native-webview';

const App = () => {
  const webviewRef = useRef(null);
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [ivText, setIvText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');

  const secretKey = 'mySecretKey';

  const generateDecryptScript = (encryptedText, ivText, secretKey) => `
    (function() {
      const encoder = new TextEncoder();
      const keyData = encoder.encode('${secretKey}');
      const iv = new Uint8Array([${ivText.split(',')}]);
      const encryptedData = new Uint8Array(atob('${encryptedText}').split('').map(c => c.charCodeAt(0)));

      crypto.subtle.importKey('raw', keyData, 'AES-GCM', false, ['encrypt', 'decrypt'])
        .then(key => {
          return crypto.subtle.decrypt({ name: 'AES-GCM', iv: iv }, key, encryptedData)
            .then(decrypted => {
              const decoder = new TextDecoder();
              const decryptedText = decoder.decode(decrypted);
              window.ReactNativeWebView.postMessage(decryptedText);
            });
        }).catch(console.error);
    })();
  `;

  const handleDecryption = () => {
    if (webviewRef.current) {
      const script = generateDecryptScript(encryptedText, ivText, secretKey);
      webviewRef.current.injectJavaScript(script);
    }
  };

  const handleMessage = event => {
    setDecryptedText(event.nativeEvent.data);
    Alert.alert('Decryption complete!', `Decrypted Text: ${event.nativeEvent.data}`);
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={encryptedText}
        onChangeText={setEncryptedText}
        placeholder="Enter encrypted text"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <TextInput
        value={ivText}
        onChangeText={setIvText}
        placeholder="Enter IV"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Decrypt" onPress={handleDecryption} />
      <Text>Decrypted Text: {decryptedText}</Text>
      <WebView
        ref={webviewRef}
        style={{ height: 0, width: 0 }}
        onMessage={handleMessage}
        originWhitelist={['*']}
        javaScriptEnabled
      />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to enter the encrypted text and IV, and decrypt it using the Web Crypto API executed within a web view. The decrypted text will be displayed, demonstrating the successful decryption of the data.

##### Online Resources for Example 2
1. [Web Crypto API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
2. [react-native-webview Documentation](https://github.com/react-native-webview/react-native-webview)

#### Example 3: Secure Key Generation and Encryption/Decryption with Web Crypto API

##### Explanation
In this example, you will learn how to generate secure cryptographic keys and use them for encrypting and decrypting data with the Web Crypto API in a React Native application. This demonstrates a complete workflow of key generation, data encryption, and decryption.

##### Example Code
```javascript
// App.js
import React, { useState, useRef } from 'react';
import { Text, View, TextInput, Button, Alert } from 'react-native';
import { WebView } from 'react-native-webview';

const App = () => {
  const webviewRef = useRef(null);
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = use

State('');
  const [key, setKey] = useState('');
  const [iv, setIv] = useState('');

  const generateScript = (plainText) => `
    (async function() {
      const encoder = new TextEncoder();
      const textData = encoder.encode('${plainText}');
      const key = await crypto.subtle.generateKey(
        { name: 'AES-GCM', length: 256 },
        true,
        ['encrypt', 'decrypt']
      );

      const iv = crypto.getRandomValues(new Uint8Array(12));
      const encrypted = await crypto.subtle.encrypt({ name: 'AES-GCM', iv: iv }, key, textData);

      const exportedKey = await crypto.subtle.exportKey('jwk', key);

      window.ReactNativeWebView.postMessage(JSON.stringify({
        iv: Array.from(iv),
        encrypted: Array.from(new Uint8Array(encrypted)),
        key: exportedKey
      }));
    })();
  `;

  const handleEncryption = () => {
    if (webviewRef.current) {
      const script = generateScript(plainText);
      webviewRef.current.injectJavaScript(script);
    }
  };

  const handleDecryptionScript = (encryptedText, key, iv) => `
    (async function() {
      const decoder = new TextDecoder();
      const importedKey = await crypto.subtle.importKey('jwk', ${JSON.stringify(key)}, { name: 'AES-GCM' }, false, ['decrypt']);
      const decrypted = await crypto.subtle.decrypt({ name: 'AES-GCM', iv: new Uint8Array(${JSON.stringify(iv)}) }, importedKey, new Uint8Array(${JSON.stringify(encryptedText)}));
      const decryptedText = decoder.decode(decrypted);
      window.ReactNativeWebView.postMessage(decryptedText);
    })();
  `;

  const handleDecryption = () => {
    if (webviewRef.current) {
      const script = handleDecryptionScript(encryptedText, key, iv);
      webviewRef.current.injectJavaScript(script);
    }
  };

  const handleMessage = event => {
    const data = JSON.parse(event.nativeEvent.data);
    if (data.encrypted && data.key && data.iv) {
      setEncryptedText(data.encrypted);
      setKey(data.key);
      setIv(data.iv);
      Alert.alert('Encryption complete!', `Encrypted Text: ${data.encrypted.toString()}`);
    } else {
      setDecryptedText(data);
      Alert.alert('Decryption complete!', `Decrypted Text: ${data}`);
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <TextInput
        value={plainText}
        onChangeText={setPlainText}
        placeholder="Enter plain text"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Encrypt" onPress={handleEncryption} />
      <Text>Encrypted Text: {encryptedText.toString()}</Text>
      <Button title="Decrypt" onPress={handleDecryption} style={{ marginTop: 10 }} />
      <Text>Decrypted Text: {decryptedText}</Text>
      <WebView
        ref={webviewRef}
        style={{ height: 0, width: 0 }}
        onMessage={handleMessage}
        originWhitelist={['*']}
        javaScriptEnabled
      />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to generate a cryptographic key, encrypt plain text, and decrypt the encrypted text using the Web Crypto API executed within a web view. The encrypted text and decrypted text will be displayed, demonstrating the complete workflow of encryption and decryption using secure keys.

##### Online Resources for Example 3
1. [Generating and Using Crypto Keys](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey)
2. [Using Web Crypto API in JavaScript](https://developers.google.com/web/updates/2012/06/Introducing-the-JavaScript-Crypto-API)

---

## Task 19: Study Advanced Real-Time Communication Techniques

Advanced real-time communication techniques are essential for building interactive and responsive applications that require instant updates, such as chat applications, collaborative tools, and live streaming services. These techniques often involve the use of WebSockets, server-sent events (SSE), and real-time data synchronization methods. WebSockets provide a full-duplex communication channel over a single, long-lived connection, enabling real-time interaction between the client and the server. SSE, on the other hand, allows servers to push updates to the client over a single HTTP connection, which is simpler but less flexible compared to WebSockets.

Implementing advanced real-time communication in React Native applications can significantly enhance the user experience by providing instant feedback and updates. This can be achieved by integrating libraries like Socket.IO for WebSockets or using real-time databases like Firebase Firestore. Additionally, technologies like WebRTC are used for peer-to-peer communication, enabling real-time video, audio, and data sharing. Understanding these techniques and how to implement them effectively in React Native is crucial for developers aiming to build modern, interactive mobile applications.

### Online Resources

1. [WebSockets and Socket.IO Documentation](https://socket.io/docs/v4/)
2. [Firebase Realtime Database](https://firebase.google.com/docs/database)

### Examples to Practice

#### Example 1: Real-Time Chat Application with Socket.IO

##### Explanation
In this example, you will create a real-time chat application using Socket.IO in a React Native application. Socket.IO simplifies the process of establishing a WebSocket connection and handling real-time communication between the client and server.

##### Example Code
```javascript
// Install required packages: npm install socket.io socket.io-client express

// server.js (Node.js server setup)
const express = require('express');
const http = require('http');
const socketIo = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

io.on('connection', (socket) => {
  console.log('a user connected');
  socket.on('message', (message) => {
    io.emit('message', message);
  });
  socket.on('disconnect', () => {
    console.log('user disconnected');
  });
});

server.listen(3000, () => {
  console.log('listening on *:3000');
});
```

```javascript
// App.js (React Native client setup)
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList } from 'react-native';
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

const App = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on('message', (msg) => {
      setMessages((prevMessages) => [...prevMessages, msg]);
    });

    return () => {
      socket.off('message');
    };
  }, []);

  const sendMessage = () => {
    socket.emit('message', message);
    setMessage('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the server and the React Native app, you will be able to send and receive messages in real-time. The messages will be displayed instantly across all connected clients using Socket.IO.

##### Online Resources for Example 1
1. [Socket.IO Documentation](https://socket.io/docs/v4/)
2. [Building a Real-Time Chat App with Socket.IO](https://www.freecodecamp.org/news/how-to-create-a-real-time-chat-app-with-reactjs-and-nodejs-a8d069e668fd/)

#### Example 2: Real-Time Notifications with Firebase Firestore

##### Explanation
In this example, you will use Firebase Firestore to implement real-time notifications in a React Native application. Firestore provides real-time data synchronization, making it ideal for applications that require instant updates.

##### Example Code
```javascript
// Install required packages: npm install @react-native-firebase/app @react-native-firebase/firestore

// firebase.js
import firestore from '@react-native-firebase/firestore';

export const notificationsCollection = firestore().collection('notifications');

// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { notificationsCollection } from './firebase';

const App = () => {
  const [message, setMessage] = useState('');
  const [notifications, setNotifications] = useState([]);

  useEffect(() => {
    const unsubscribe = notificationsCollection.onSnapshot((snapshot) => {
      const newNotifications = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setNotifications(newNotifications);
    });

    return () => unsubscribe();
  }, []);

  const sendNotification = async () => {
    await notificationsCollection.add({
      message,
      timestamp: firestore.FieldValue.serverTimestamp(),
    });
    setMessage('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={notifications}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <Text>{item.message}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a notification"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendNotification} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send and receive notifications in real-time using Firebase Firestore. Notifications will be displayed instantly across all connected clients.

##### Online Resources for Example 2
1. [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)
2. [Using Firestore with React Native](https://rnfirebase.io/firestore/usage)

#### Example 3: Real-Time Video Communication with WebRTC

##### Explanation
In this example, you will implement real-time video communication using WebRTC in a React Native application. WebRTC provides APIs for peer-to-peer communication, enabling real-time video, audio, and data sharing between clients.

##### Example Code
```javascript
// Install required packages: npm install react-native-webrtc

// App.js
import React, { useRef, useEffect, useState } from 'react';
import { View, Button } from 'react-native';
import { RTCView, mediaDevices } from 'react-native-webrtc';

const App = () => {
  const [localStream, setLocalStream] = useState(null);
  const [remoteStream, setRemoteStream] = useState(null);
  const peerConnectionRef = useRef(null);

  useEffect(() => {
    const startLocalStream = async () => {
      const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
      setLocalStream(stream);
    };

    startLocalStream();

    // Cleanup
    return () => {
      if (localStream) {
        localStream.getTracks().forEach((track) => track.stop());
      }
    };
  }, []);

  const startCall = () => {
    // Initialize peer connection and set up event handlers here
    // This is a simplified example. In a real app, you would also handle signaling and remote peer connection.
  };

  return (
    <View style={{ flex: 1 }}>
      {localStream && (
        <RTCView
          streamURL={localStream.toURL()}
          style={{ width: '100%', height: '50%' }}
        />
      )}
      {remoteStream && (
        <RTCView
          streamURL={remoteStream.toURL()}
          style={{ width: '100%', height: '50%' }}
        />
      )}
      <Button title="Start Call" onPress={startCall} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to start the local video stream and display it. The remote video stream functionality needs to be implemented for a complete peer-to-peer video call setup.

##### Online Resources for Example 3
1. [WebRTC API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)
2. [Using WebRTC with React Native](https://www.html5rocks.com/en/tutorials/webrtc/basics/)

---

## Task 20: Implement Real-Time Notifications with Firebase

Real-time notifications are crucial for providing users with timely updates and keeping them engaged with your application. Firebase offers a robust solution for implementing real-time notifications through its Cloud Messaging (FCM) and Firestore services. Firebase Cloud Messaging enables you to send notifications to users' devices, even when the app is not running, while Firestore provides real-time database capabilities, allowing you to sync data across devices instantly.

Using Firebase for real-time notifications in a React Native application involves setting up Firebase Cloud Messaging to handle the delivery of notifications and configuring Firestore to sync data changes in real-time. This combination ensures that users receive immediate updates about relevant events, improving user experience and engagement. By leveraging Firebase's infrastructure, developers can implement scalable and reliable notification systems without worrying about server maintenance or scaling issues.

### Online Resources

1. [Firebase Cloud Messaging Documentation](https://firebase.google.com/docs/cloud-messaging)
2. [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)

### Examples to Practice

#### Example 1: Setting Up Firebase Cloud Messaging in React Native

##### Explanation
In this example, you will set up Firebase Cloud Messaging (FCM) in a React Native application. FCM allows you to send notifications to your users' devices, keeping them informed about important updates. You will configure FCM in your project and handle incoming notifications.

##### Example Code
```javascript
// Install required packages: npm install @react-native-firebase/app @react-native-firebase/messaging

// firebase.js
import messaging from '@react-native-firebase/messaging';

// Request permission to send notifications
async function requestUserPermission() {
  const authStatus = await messaging().requestPermission();
  const enabled = authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }
}

export { requestUserPermission };

// App.js
import React, { useEffect } from 'react';
import { Alert, View, Text } from 'react-native';
import messaging from '@react-native-firebase/messaging';
import { requestUserPermission } from './firebase';

const App = () => {
  useEffect(() => {
    requestUserPermission();

    const unsubscribe = messaging().onMessage(async remoteMessage => {
      Alert.alert('A new FCM message arrived!', JSON.stringify(remoteMessage));
    });

    return unsubscribe;
  }, []);

  return (
    <View style={{ padding: 20 }}>
      <Text>Real-Time Notifications with Firebase Cloud Messaging</Text>
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, it will request permission to send notifications. If permission is granted, the app will display an alert when a new FCM message arrives. This demonstrates how to set up and handle notifications with Firebase Cloud Messaging in a React Native application.

##### Online Resources for Example 1
1. [Firebase Cloud Messaging Setup in React Native](https://rnfirebase.io/messaging/usage)
2. [Handling FCM Messages in React Native](https://firebase.google.com/docs/cloud-messaging/android/receive)

#### Example 2: Sending Real-Time Notifications with Firestore

##### Explanation
In this example, you will use Firebase Firestore to send real-time notifications in a React Native application. Firestore's real-time capabilities allow you to sync data changes across devices instantly. You will configure Firestore and set up listeners to receive real-time updates.

##### Example Code
```javascript
// Install required packages: npm install @react-native-firebase/app @react-native-firebase/firestore

// firebase.js
import firestore from '@react-native-firebase/firestore';

export const notificationsCollection = firestore().collection('notifications');

// App.js
import React, { useState, useEffect } from 'react';
import { Text, View, TextInput, Button, FlatList } from 'react-native';
import { notificationsCollection } from './firebase';

const App = () => {
  const [message, setMessage] = useState('');
  const [notifications, setNotifications] = useState([]);

  useEffect(() => {
    const unsubscribe = notificationsCollection.onSnapshot((snapshot) => {
      const newNotifications = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setNotifications(newNotifications);
    });

    return () => unsubscribe();
  }, []);

  const sendNotification = async () => {
    await notificationsCollection.add({
      message,
      timestamp: firestore.FieldValue.serverTimestamp(),
    });
    setMessage('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={notifications}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <Text>{item.message}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a notification"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendNotification} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send notifications by adding messages to the Firestore collection. The messages will be displayed in real-time across all connected clients, demonstrating Firestore's real-time data synchronization capabilities.

##### Online Resources for Example 2
1. [Firestore Realtime Database](https://firebase.google.com/docs/firestore)
2. [Using Firestore with React Native](https://rnfirebase.io/firestore/usage)

#### Example 3: Combining FCM and Firestore for Enhanced Real-Time Notifications

##### Explanation
In this example, you will combine Firebase Cloud Messaging (FCM) and Firestore to create a comprehensive real-time notification system in a React Native application. FCM will be used to deliver push notifications, while Firestore will handle real-time data synchronization.

##### Example Code
```javascript
// Install required packages: npm install @react-native-firebase/app @react-native-firebase/messaging @react-native-firebase/firestore

// firebase.js
import messaging from '@react-native-firebase/messaging';
import firestore from '@react-native-firebase/firestore';

export const notificationsCollection = firestore().collection('notifications');

// Request permission to send notifications
async function requestUserPermission() {
  const authStatus = await messaging().requestPermission();
  const enabled = authStatus === messaging.AuthorizationStatus.AUTHORIZED || authStatus === messaging.AuthorizationStatus.PROVISIONAL;

  if (enabled) {
    console.log('Authorization status:', authStatus);
  }
}

export { requestUserPermission };

// App.js
import React, { useState, useEffect } from 'react';
import { Alert, View, Text, TextInput, Button, FlatList } from 'react-native';
import messaging from '@react-native-firebase/messaging';
import { notificationsCollection, requestUserPermission } from './firebase';

const App = () => {
  const [message, setMessage] = useState('');
  const [notifications, setNotifications] = useState([]);

  useEffect(() => {
    requestUserPermission();

    const unsubscribe = messaging().onMessage(async remoteMessage => {
      Alert.alert('A new FCM message arrived!', JSON.stringify(remoteMessage));
    });

    const unsubscribeFirestore = notificationsCollection.onSnapshot((snapshot) => {
      const newNotifications = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setNotifications(newNotifications);
    });

    return () => {
      unsubscribe();
      unsubscribeFirestore();
    };
  }, []);

  const sendNotification = async () => {
    await notificationsCollection.add({
      message,
      timestamp: firestore.FieldValue.serverTimestamp(),
    });
    setMessage('');
  };

  return (
    <View style={{ padding: 20 }}>
      <FlatList
        data={notifications}
        keyExtractor={(item) => item.id}
        renderItem={({ item }) => <Text>{item.message}</Text>}
      />
      <TextInput
        value={message}
        onChangeText={setMessage}
        placeholder="Type a notification"
        style={{ borderWidth: 1, padding: 10, marginBottom: 10 }}
      />
      <Button title="Send" onPress={sendNotification} />
    </View>
  );
};

export default App;
```

##### Expected Output
When you run the app, you will be able to send and receive real-time notifications using both FCM and Firestore. Push notifications will alert users even when the app is in the background, while Firestore will keep the notification list updated in real-time when the app is in the foreground.

##### Online Resources for Example 3
1. [Combining FCM and Firestore](https://medium.com/@elvis.gumbo1/firebase-cloud-messaging-in-react-native-using-expo-and-firestore-9257478b1d5a)
2. [React Native Firebase Documentation](https://rnfirebase.io/)

---