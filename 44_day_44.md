### Task 1: Study Real-Time Communication Techniques for Cross-Platform Development using React Native

#### Task 1: Understanding WebSockets in React Native

**Explanation:**
WebSockets provide a full-duplex communication channel over a single, long-lived connection, enabling real-time interaction between a client and a server. Unlike traditional HTTP requests, which are one-way and require the client to poll the server for updates, WebSockets allow for continuous two-way communication. This makes WebSockets particularly useful for applications that need frequent updates from the server, such as chat applications, live notifications, and real-time data feeds.

In React Native, implementing WebSockets involves using the built-in `WebSocket` API, which is supported on both iOS and Android. The API allows you to open a connection to a WebSocket server, send messages to the server, and receive messages from the server. By leveraging WebSockets in React Native, developers can create applications that provide a seamless and responsive user experience.

**Online Resources:**
- [MDN Web Docs: WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
- [WebSocket.org: Introduction](https://www.websocket.org/aboutwebsocket.html)

**Examples to Practice:**

1. **Basic WebSocket Connection:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';

   const App = () => {
     const [message, setMessage] = useState('');
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://echo.websocket.org');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setMessage(event.data);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection) {
         connection.send('Hello WebSocket');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Send Message" onPress={sendMessage} />
         <Text>Message from server: {message}</Text>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates a basic WebSocket connection in React Native. The `WebSocket` API is used to open a connection to the echo server at `ws://echo.websocket.org`. When the connection is open, a message is sent to the server when the button is pressed. The message is echoed back by the server and displayed on the screen. The WebSocket connection is closed when the component is unmounted.

2. **Implementing a Chat Application:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button, TextInput, FlatList, Text } from 'react-native';

   const App = () => {
     const [message, setMessage] = useState('');
     const [messages, setMessages] = useState([]);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://chat.websocket.org');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setMessages((prevMessages) => [...prevMessages, event.data]);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection && message) {
         connection.send(message);
         setMessage('');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={messages}
           renderItem={({ item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={message}
           onChangeText={setMessage}
           placeholder="Type a message"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Send Message" onPress={sendMessage} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example implements a simple chat application using WebSockets in React Native. The application connects to a WebSocket server and allows users to send and receive messages. Messages are displayed in a list using the `FlatList` component. The `TextInput` component is used to input messages, and the `Button` component sends the message to the server. The received messages are appended to the list and displayed in real-time.

3. **Real-Time Notifications:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';

   const App = () => {
     const [notifications, setNotifications] = useState([]);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://notifications.websocket.org');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setNotifications((prevNotifications) => [...prevNotifications, event.data]);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const requestNotification = () => {
       if (connection) {
         connection.send('Request Notification');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Request Notification" onPress={requestNotification} />
         <FlatList
           data={notifications}
           renderItem={({ item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates real-time notifications using WebSockets in React Native. The application connects to a WebSocket server and listens for incoming notifications. Users can request a notification by pressing a button, which sends a message to the server. Received notifications are displayed in a list using the `FlatList` component. This setup provides a way to deliver real-time updates to users.

**Online Resources:**
- [Building a Chat App with WebSocket](https://www.smashingmagazine.com/2020/05/realtime-chat-widget-websockets/)
- [WebSockets in React Native](https://blog.reactnativecoach.com/implementing-websockets-in-react-native-5f5a1a01b0c5)

#### Task 2: Using Socket.IO for Real-Time Communication

**Explanation:**
Socket.IO is a library that enables real-time, bidirectional communication between web clients and servers. It abstracts the complexity of WebSockets and provides additional features like automatic reconnection, broadcasting to multiple clients, and support for different transport protocols. Socket.IO is widely used in applications that require real-time updates, such as chat apps, live notifications, and collaborative tools.

Socket.IO consists of two parts: a server-side library for Node.js and a client-side library for the browser and React Native. The server sets up a Socket.IO instance that listens for connections, and the client connects to this instance using the Socket.IO client library. Messages can be sent and received using event-based APIs, making it easy to implement real-time communication features in your application.

**Online Resources:**
- [Socket.IO Documentation](https://socket.io/docs/)
- [Getting Started with Socket.IO](https://socket.io/get-started/)

**Examples to Practice:**

1. **Basic Socket.IO Server and Client:**
   ```javascript
   // Server (Node.js with Socket.IO)
   const express = require('express');
   const http = require('http');
   const socketIo = require('socket.io');

   const app = express();
   const server = http.createServer(app);
   const io = socketIo(server);

   io.on('connection', (socket) => {
     console.log('A user connected');
     socket.emit('welcome', 'Welcome to Socket.IO server');

     socket.on('message', (message) => {
       console.log('Received:', message);
       socket.emit('response', `Echo: ${message}`);
     });

     socket.on('disconnect', () => {
       console.log('User disconnected');
     });
   });

   server.listen(3000, () => {
     console.log('Socket.IO server is running on http://localhost:3000');
   });
   ```

   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';
   import io from 'socket.io-client';

   const App = () => {
     const [message, setMessage] = useState('');
     const socket = useRef(null);

     useEffect(() => {
       socket.current = io('http://localhost:3000');

       socket.current.on('connect', () => {
         console.log('Connected to Socket.IO server');
       });

       socket.current.on('welcome', (data) => {
         setMessage(data);
       });

       socket.current.on('response', (data) => {
         setMessage(data);
       });

       return () => {
         socket.current.disconnect();
       };
     }, []);

     const sendMessage = () => {
       socket.current.emit('message', 'Hello Socket.IO');
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Send Message" onPress={sendMessage} />
         <Text>Message from server: {message}</Text>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example sets up a basic Socket.IO server and client in React Native. The server listens for connections and handles messages from clients. The client connects to the server using the `socket.io-client` library, sends a message when the button is pressed, and displays the response from the server. This setup provides a foundation for real-time communication using Socket.IO.

2. **Implementing a Real-Time Chat Application:**
   ```javascript
   // Server (Node.js with Socket.IO)
   const express = require('express');
   const http = require('http');
   const socketIo = require('socket.io');

   const app = express();
   const server = http.createServer(app);
   const io = socketIo(server);

   io.on('connection', (socket) => {
     console.log('A user connected');

     socket.on('message', (message) => {
       io.emit('message', message);
     });

     socket.on('disconnect', () => {
       console.log('User disconnected');
     });
   });

   server.listen(3000, () => {
     console.log('Socket.IO server is running on http://localhost:3000');
   });
   ```

   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, FlatList, Text } from 'react-native';
   import io from 'socket.io-client';

   const App = () => {
     const [message, setMessage] = useState('');
     const [messages, setMessages] = useState([]);
     const socket = useRef(null);

     useEffect(() => {
       socket.current = io('http://localhost:3000');

       socket.current.on('connect', () => {
         console.log('Connected to Socket.IO server');
       });

       socket.current.on('message', (message) => {
         setMessages((prevMessages) => [...prevMessages, message]);
       });

       return () => {
         socket.current.disconnect();
       };
     }, []);

     const sendMessage = () => {
       if (message) {
         socket.current.emit('message', message);
         setMessage('');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={messages}
           renderItem={({ item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={message}
           onChangeText={setMessage}
           placeholder="Type a message"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Send Message" onPress={sendMessage} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example implements a real-time chat application using Socket.IO in React Native. The server broadcasts received messages to all connected clients. The client connects to the server, sends messages using the `TextInput` component, and displays received messages in a list using the `FlatList` component. This setup allows multiple users to chat in real-time.

3. **Real-Time Collaboration with Presence Detection:**
   ```javascript
   // Server (Node.js with Socket.IO)
   const express = require('express');
   const http = require('http');
   const socketIo = require('socket.io');

   const app = express();
   const server = http.createServer(app);
   const io = socketIo(server);

   const users = {};

   io.on('connection', (socket) => {
     console.log('A user connected');

     socket.on('join', (username) => {
       users[socket.id] = username;
       io.emit('updateUsers', Object.values(users));
     });

     socket.on('disconnect', () => {
       delete users[socket.id];
       io.emit('updateUsers', Object.values(users));
       console.log('User disconnected');
     });
   });

   server.listen(3000, () => {
     console.log('Socket.IO server is running on http://localhost:3000');
   });
   ```

   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, FlatList, Text } from 'react-native';
   import io from 'socket.io-client';

   const App = () => {
     const [username, setUsername] = useState('');
     const [users, setUsers] = useState([]);
     const socket = useRef(null);

     useEffect(() => {
       socket.current = io('http://localhost:3000');

       socket.current.on('connect', () => {
         console.log('Connected to Socket.IO server');
       });

       socket.current.on('updateUsers', (users) => {
         setUsers(users);
       });

       return () => {
         socket.current.disconnect();
       };
     }, []);

     const joinChat = () => {
       if (username) {
         socket.current.emit('join', username);
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={users}
           renderItem={({ item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={username}
           onChangeText={setUsername}
           placeholder="Enter your username"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Join Chat" onPress={joinChat} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates real-time collaboration with presence detection using Socket.IO in React Native. The server maintains a list of connected users and broadcasts updates to all clients. The client connects to the server, sends the username upon joining, and displays the list of active users in real-time. This setup is useful for collaborative applications where user presence needs to be tracked.

**Online Resources:**
- [Socket.IO Rooms and Namespaces](https://socket.io/docs/v4/rooms)
- [Socket.IO Real-Time Apps](https://developer.okta.com/blog/2018/06/20/socket-io-chat-app)

#### Task 3: Implementing Real-Time Data Sync with Firebase

**Explanation:**
Firebase Realtime Database is a cloud-hosted NoSQL database that lets you store and sync data between your users in real-time. The Firebase Realtime Database synchronizes application state across clients in real-time and remains available even when your app goes offline. This makes it an excellent choice for building collaborative applications, real-time updates, and instant notifications.

Using Firebase in React Native involves setting up a Firebase project, adding the Firebase configuration to your React Native app, and using Firebase's SDK to interact with the database. With Firebase, you can easily read and write data, listen for real-time updates, and manage user authentication, providing a comprehensive solution for building real-time applications.

**Online Resources:**
- [Firebase Realtime Database Documentation](https://firebase.google.com/docs/database)
- [React Native Firebase Documentation](https://rnfirebase.io/)

**Examples to Practice:**

1. **Setting Up Firebase in React Native:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, FlatList, Text } from 'react-native';
   import firebase from 'firebase/app';
   import 'firebase/database';

   const firebaseConfig = {
     apiKey: "YOUR_API_KEY",
     authDomain: "YOUR_AUTH_DOMAIN",
     databaseURL: "YOUR_DATABASE_URL",
     projectId: "YOUR_PROJECT_ID",
     storageBucket: "YOUR_STORAGE_BUCKET",
     messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
     appId: "YOUR_APP_ID"
   };

   if (!firebase.apps.length) {
     firebase.initializeApp(firebaseConfig);
   }

   const App = () => {
     const [message, setMessage] = useState('');
     const [messages, setMessages] = useState([]);

     useEffect(() => {
       const messagesRef = firebase.database().ref('messages');
       messagesRef.on('value', (snapshot) => {
         const data = snapshot.val();
         const messagesList = data ? Object.values(data) : [];
         setMessages(messagesList);
       });

       return () => {
         messagesRef.off();
       };
     }, []);

     const sendMessage = () => {
       if (message) {
         const messagesRef = firebase.database().ref('messages');
         messagesRef.push(message);
         setMessage('');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={messages}
           renderItem={({item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={message}
           onChangeText={setMessage}
           placeholder="Type a message"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Send Message" onPress={sendMessage} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example sets up Firebase in a React Native app and implements a simple messaging feature using Firebase Realtime Database. The application connects to Firebase, listens for real-time updates to the `messages` node, and displays the messages in a list. Users can send messages using the `TextInput` component, which are then pushed to the Firebase database.

2. **Real-Time Task Management:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, FlatList, Text, CheckBox } from 'react-native';
   import firebase from 'firebase/app';
   import 'firebase/database';

   const firebaseConfig = {
     apiKey: "YOUR_API_KEY",
     authDomain: "YOUR_AUTH_DOMAIN",
     databaseURL: "YOUR_DATABASE_URL",
     projectId: "YOUR_PROJECT_ID",
     storageBucket: "YOUR_STORAGE_BUCKET",
     messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
     appId: "YOUR_APP_ID"
   };

   if (!firebase.apps.length) {
     firebase.initializeApp(firebaseConfig);
   }

   const App = () => {
     const [task, setTask] = useState('');
     const [tasks, setTasks] = useState([]);

     useEffect(() => {
       const tasksRef = firebase.database().ref('tasks');
       tasksRef.on('value', (snapshot) => {
         const data = snapshot.val();
         const tasksList = data ? Object.values(data) : [];
         setTasks(tasksList);
       });

       return () => {
         tasksRef.off();
       };
     }, []);

     const addTask = () => {
       if (task) {
         const tasksRef = firebase.database().ref('tasks');
         tasksRef.push({ title: task, completed: false });
         setTask('');
       }
     };

     const toggleTaskCompletion = (taskId, completed) => {
       const taskRef = firebase.database().ref(`tasks/${taskId}`);
       taskRef.update({ completed: !completed });
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={tasks}
           renderItem={({ item }) => (
             <View style={{ flexDirection: 'row', alignItems: 'center' }}>
               <CheckBox value={item.completed} onValueChange={() => toggleTaskCompletion(item.id, item.completed)} />
               <Text>{item.title}</Text>
             </View>
           )}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={task}
           onChangeText={setTask}
           placeholder="Add a task"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Add Task" onPress={addTask} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example implements a real-time task management application using Firebase Realtime Database in React Native. The application connects to Firebase, listens for updates to the `tasks` node, and displays the tasks in a list. Users can add tasks and toggle their completion status. The task list is updated in real-time across all clients connected to the database.

3. **Collaborative Drawing Board:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';
   import { Svg, Polyline } from 'react-native-svg';
   import firebase from 'firebase/app';
   import 'firebase/database';

   const firebaseConfig = {
     apiKey: "YOUR_API_KEY",
     authDomain: "YOUR_AUTH_DOMAIN",
     databaseURL: "YOUR_DATABASE_URL",
     projectId: "YOUR_PROJECT_ID",
     storageBucket: "YOUR_STORAGE_BUCKET",
     messagingSenderId: "YOUR_MESSAGING_SENDER_ID",
     appId: "YOUR_APP_ID"
   };

   if (!firebase.apps.length) {
     firebase.initializeApp(firebaseConfig);
   }

   const App = () => {
     const [lines, setLines] = useState([]);
     const [currentLine, setCurrentLine] = useState([]);

     useEffect(() => {
       const linesRef = firebase.database().ref('lines');
       linesRef.on('value', (snapshot) => {
         const data = snapshot.val();
         const linesList = data ? Object.values(data) : [];
         setLines(linesList);
       });

       return () => {
         linesRef.off();
       };
     }, []);

     const handleTouchMove = (event) => {
       const { locationX, locationY } = event.nativeEvent;
       setCurrentLine([...currentLine, `${locationX},${locationY}`]);
     };

     const handleTouchEnd = () => {
       if (currentLine.length > 0) {
         const linesRef = firebase.database().ref('lines');
         linesRef.push(currentLine);
         setCurrentLine([]);
       }
     };

     return (
       <View style={{ flex: 1 }}>
         <Svg
           style={{ flex: 1 }}
           onTouchMove={handleTouchMove}
           onTouchEnd={handleTouchEnd}
         >
           {lines.map((line, index) => (
             <Polyline key={index} points={line.join(' ')} stroke="black" strokeWidth="3" />
           ))}
           <Polyline points={currentLine.join(' ')} stroke="black" strokeWidth="3" />
         </Svg>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example implements a collaborative drawing board using Firebase Realtime Database in React Native. The application listens for updates to the `lines` node and displays the lines on an SVG canvas. Users can draw on the canvas by touching and moving their finger, and the drawing is synchronized in real-time across all clients connected to the database. The current drawing line is added to the Firebase database when the touch ends, and the lines are updated in real-time for all users.

**Online Resources:**
- [Firebase Realtime Database](https://firebase.google.com/docs/database)
- [React Native Firebase Documentation](https://rnfirebase.io/)


### Task 2: Implement WebSockets for Real-Time Updates in React Native

#### Task 1: Setting Up a WebSocket Server

**Explanation:**
Setting up a WebSocket server involves creating an endpoint that clients can connect to for real-time communication. WebSockets provide a full-duplex communication channel over a single, long-lived connection, which is more efficient than traditional HTTP requests for real-time updates. A WebSocket server listens for incoming client connections, processes messages sent by clients, and sends messages back to clients. This setup is commonly used in applications that require instant data updates, such as live chat, real-time notifications, and collaborative tools.

To implement a WebSocket server in Node.js, you can use the `ws` library, a simple and efficient library for WebSocket communication. The server listens on a specified port and handles connection, message, and disconnection events. Once a connection is established, the server and client can exchange messages in real-time, enabling instant updates and interactive communication.

**Online Resources:**
- [WebSocket API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [Node.js WebSocket Tutorial](https://www.websocket.org/echo.html)

**Examples to Practice:**

1. **Basic WebSocket Server:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   server.on('connection', (ws) => {
     console.log('New client connected');
     ws.send('Welcome to WebSocket server');

     ws.on('message', (message) => {
       console.log('Received:', message);
       ws.send(`Echo: ${message}`);
     });

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';

   const App = () => {
     const [message, setMessage] = useState('');
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setMessage(event.data);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection) {
         connection.send('Hello WebSocket');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Send Message" onPress={sendMessage} />
         <Text>Message from server: {message}</Text>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example sets up a basic WebSocket server using Node.js and the `ws` library. The server listens for client connections on port 8080, sends a welcome message to connected clients, echoes received messages back to the clients, and logs connection and disconnection events. The client-side code connects to the server, sends a message upon connection, and logs messages received from the server.

2. **Broadcasting Messages to All Connected Clients:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   server.on('connection', (ws) => {
     console.log('New client connected');
     ws.send('Welcome to WebSocket server');

     ws.on('message', (message) => {
       console.log('Received:', message);
       server.clients.forEach((client) => {
         if (client.readyState === WebSocket.OPEN) {
           client.send(message);
         }
       });
     });

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';

   const App = () => {
     const [messages, setMessages] = useState([]);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setMessages((prevMessages) => [...prevMessages, event.data]);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection) {
         connection.send('Hello Everyone');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Send Message" onPress={sendMessage} />
         {messages.map((message, index) => (
           <Text key={index}>{message}</Text>
         ))}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example extends the basic WebSocket server to broadcast messages to all connected clients. When a client sends a message, the server iterates over all connected clients and sends the message to each one. This setup is useful for applications like chat rooms or live notifications where updates need to be shared with all users.

3. **Handling JSON Messages:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   server.on('connection', (ws) => {
     console.log('New client connected');
     ws.send(JSON.stringify({ type: 'welcome', message: 'Welcome to WebSocket server' }));

     ws.on('message', (message) => {
       console.log('Received:', message);
       const data = JSON.parse(message);
       ws.send(JSON.stringify({ type: 'response', message: `Echo: ${data.message}` }));
     });

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text, TextInput } from 'react-native';

   const App = () => {
     const [message, setMessage] = useState('');
     const [messages, setMessages] = useState([]);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         const data = JSON.parse(event.data);
         setMessages((prevMessages) => [...prevMessages, data.message]);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection) {
         connection.send(JSON.stringify({ type: 'message', message }));
         setMessage('');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <TextInput
           value={message}
           onChangeText={setMessage}
           placeholder="Type a message"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Send Message" onPress={sendMessage} />
         {messages.map((message, index) => (
           <Text key={index}>{message}</Text>
         ))}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates handling JSON messages in a WebSocket connection. The server and client exchange messages as JSON objects. The server parses incoming JSON messages, processes them, and sends back a JSON response. This approach is useful for applications that need to exchange structured data.

**Online Resources:**
- [WebSocket Programming with Node.js](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
- [WebSockets in the Wild](https://websockets.readthedocs.io/en/stable/)

#### Task 2: Implementing Real-Time Updates with WebSockets

**Explanation:**
Real-time updates with WebSockets enable instant data synchronization between the server and connected clients. This capability is crucial for applications like live sports scores, stock market updates, and collaborative tools where users need to see changes immediately. WebSockets maintain a persistent connection, allowing the server to push updates to clients without the need for repeated HTTP requests.

To implement real-time updates, the server sends updates to all connected clients whenever data changes. The clients listen for these updates and update their UI accordingly. This approach reduces latency and network overhead

 compared to traditional polling methods. Real-time updates improve user experience by providing timely and synchronized information across all connected clients.

**Online Resources:**
- [Real-Time WebSocket Examples](https://www.websocket.org/demos.html)
- [Building Real-Time Web Applications](https://www.toptal.com/nodejs/nodejs-socket-io-real-time-web-applications)

**Examples to Practice:**

1. **Real-Time Counter Update:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   let counter = 0;

   server.on('connection', (ws) => {
     console.log('New client connected');
     ws.send(JSON.stringify({ type: 'counter', value: counter }));

     ws.on('message', (message) => {
       const data = JSON.parse(message);
       if (data.type === 'increment') {
         counter += 1;
         server.clients.forEach((client) => {
           if (client.readyState === WebSocket.OPEN) {
             client.send(JSON.stringify({ type: 'counter', value: counter }));
           }
         });
       }
     });

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, Button, Text } from 'react-native';

   const App = () => {
     const [counter, setCounter] = useState(0);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         const data = JSON.parse(event.data);
         if (data.type === 'counter') {
           setCounter(data.value);
         }
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const incrementCounter = () => {
       if (connection) {
         connection.send(JSON.stringify({ type: 'increment' }));
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <Button title="Increment Counter" onPress={incrementCounter} />
         <Text>Counter: {counter}</Text>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example sets up a WebSocket server to handle a real-time counter. The server maintains a counter value and broadcasts updates to all connected clients whenever the counter is incremented. The client-side code connects to the server, listens for counter updates, and updates the displayed counter value. Clients can increment the counter by sending an `increment` message to the server.

2. **Real-Time Chat Application:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   server.on('connection', (ws) => {
     console.log('New client connected');

     ws.on('message', (message) => {
       console.log('Received:', message);
       server.clients.forEach((client) => {
         if (client.readyState === WebSocket.OPEN) {
           client.send(message);
         }
       });
     });

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, FlatList, Text } from 'react-native';

   const App = () => {
     const [message, setMessage] = useState('');
     const [messages, setMessages] = useState([]);
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         setMessages((prevMessages) => [...prevMessages, event.data]);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     const sendMessage = () => {
       if (connection && message) {
         connection.send(message);
         setMessage('');
       }
     };

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={messages}
           renderItem={({ item }) => <Text>{item}</Text>}
           keyExtractor={(item, index) => index.toString()}
         />
         <TextInput
           value={message}
           onChangeText={setMessage}
           placeholder="Type a message"
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, width: '80%', marginBottom: 10 }}
         />
         <Button title="Send Message" onPress={sendMessage} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates a simple real-time chat application using WebSockets. The server broadcasts received messages to all connected clients. The client-side code connects to the server, sends messages using the `TextInput` component, and displays received messages in a list using the `FlatList` component. This setup enables real-time communication between multiple clients in a chat room.

3. **Real-Time Stock Price Updates:**
   ```javascript
   // Server (Node.js with ws library)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   const stockPrices = {
     AAPL: 150,
     GOOGL: 2800,
     AMZN: 3400,
   };

   function updateStockPrices() {
     Object.keys(stockPrices).forEach((symbol) => {
       stockPrices[symbol] += (Math.random() - 0.5) * 10;
     });
   }

   setInterval(() => {
     updateStockPrices();
     server.clients.forEach((client) => {
       if (client.readyState === WebSocket.OPEN) {
         client.send(JSON.stringify(stockPrices));
       }
     });
   }, 5000);

   server.on('connection', (ws) => {
     console.log('New client connected');
     ws.send(JSON.stringify(stockPrices));

     ws.on('close', () => {
       console.log('Client disconnected');
     });
   });

   console.log('WebSocket server is running on ws://localhost:8080');
   ```

   ```javascript
   // Client (React Native)
   import React, { useState, useEffect } from 'react';
   import { View, FlatList, Text } from 'react-native';

   const App = () => {
     const [stockPrices, setStockPrices] = useState({});
     const [connection, setConnection] = useState(null);

     useEffect(() => {
       const ws = new WebSocket('ws://localhost:8080');

       ws.onopen = () => {
         console.log('Connected to WebSocket server');
         setConnection(ws);
       };

       ws.onmessage = (event) => {
         const data = JSON.parse(event.data);
         setStockPrices(data);
       };

       ws.onclose = () => {
         console.log('Disconnected from WebSocket server');
       };

       return () => {
         ws.close();
       };
     }, []);

     return (
       <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
         <FlatList
           data={Object.keys(stockPrices)}
           renderItem={({ item }) => (
             <Text>
               {item}: {stockPrices[item].toFixed(2)}
             </Text>
           )}
           keyExtractor={(item) => item}
         />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example implements real-time stock price updates using WebSockets. The server maintains stock prices and updates them at regular intervals. The updated prices are broadcast to all connected clients. The client-side code connects to the server, listens for stock price updates, and displays the prices in a list using the `FlatList` component. This setup provides real-time updates for stock prices, simulating a live market feed.

**Online Resources:**
- [Real-Time Applications with WebSockets](https://ably.com/concepts/websockets)
- [Building a Real-Time Chat App with WebSockets](https://www.smashingmagazine.com/2020/05/realtime-chat-widget-websockets/)


### Task 3: Study Video Calling APIs for Cross-Platform Development using React Native

#### Task 1: Understanding WebRTC in React Native

**Explanation:**
WebRTC (Web Real-Time Communication) is an open-source project that provides real-time communication capabilities through simple APIs. WebRTC allows web applications to access the device's camera and microphone to enable audio and video communication between peers. It is widely used for creating video calling applications, online gaming, and other real-time communication tools.

In React Native, implementing WebRTC involves using libraries like `react-native-webrtc`, which provides a comprehensive set of tools to access the device's camera and microphone, manage peer-to-peer connections, and handle media streams. By leveraging WebRTC in React Native, developers can create robust cross-platform video calling applications that work seamlessly on both iOS and Android.

**Online Resources:**
- [WebRTC Overview](https://webrtc.org/getting-started/overview)
- [React Native WebRTC GitHub Repository](https://github.com/react-native-webrtc/react-native-webrtc)

**Examples to Practice:**

1. **Setting Up WebRTC in React Native:**
   ```javascript
   // App.js
   import React, { useState, useRef } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView } from 'react-native-webrtc';

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const localStreamRef = useRef(null);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       localStreamRef.current = stream;
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '100%', height: '100%' }} />}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates setting up a local video stream using WebRTC in React Native. The `mediaDevices.getUserMedia` function is used to access the device's camera and microphone, and the stream is displayed using the `RTCView` component. The `localStream` state holds the media stream, and a button allows users to start the local stream.

2. **Implementing WebRTC Signaling with WebSocket:**
   ```javascript
   // SignalingServer.js (Node.js)
   const WebSocket = require('ws');
   const server = new WebSocket.Server({ port: 8080 });

   server.on('connection', (ws) => {
     ws.on('message', (message) => {
       server.clients.forEach((client) => {
         if (client !== ws && client.readyState === WebSocket.OPEN) {
           client.send(message);
         }
       });
     });
   });

   console.log('Signaling server is running on ws://localhost:8080');
   ```

   ```javascript
   // App.js
   import React, { useState, useRef, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView, RTCPeerConnection } from 'react-native-webrtc';

   const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
   const peerConnection = new RTCPeerConnection(configuration);

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const [remoteStream, setRemoteStream] = useState(null);
     const signalingServer = useRef(new WebSocket('ws://localhost:8080'));

     useEffect(() => {
       signalingServer.current.onmessage = (message) => {
         const data = JSON.parse(message.data);
         if (data.type === 'offer') {
           peerConnection.setRemoteDescription(new RTCSessionDescription(data));
           peerConnection.createAnswer().then((answer) => {
             peerConnection.setLocalDescription(answer);
             signalingServer.current.send(JSON.stringify(answer));
           });
         } else if (data.type === 'answer') {
           peerConnection.setRemoteDescription(new RTCSessionDescription(data));
         } else if (data.candidate) {
           peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
         }
       };

       peerConnection.onicecandidate = (event) => {
         if (event.candidate) {
           signalingServer.current.send(JSON.stringify(event.candidate));
         }
       };

       peerConnection.onaddstream = (event) => {
         setRemoteStream(event.stream);
       };
     }, []);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       peerConnection.addStream(stream);
     };

     const createOffer = () => {
       peerConnection.createOffer().then((offer) => {
         peerConnection.setLocalDescription(offer);
         signalingServer.current.send(JSON.stringify(offer));
       });
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         <Button title="Create Offer" onPress={createOffer} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '50%', height: '50%' }} />}
         {remoteStream && <RTCView streamURL={remoteStream.toURL()} style={{ width: '50%', height: '50%' }} />}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example adds signaling using WebSocket to exchange SDP offers, answers, and ICE candidates between peers. The signaling server relays messages between clients. The `peerConnection` is configured with STUN servers for NAT traversal. When a local stream is started, it is added to the `peerConnection`, and users can create an offer to initiate the connection. The remote stream is displayed when received from the peer.

3. **Handling Multiple Video Streams in a Group Call:**
   ```javascript
   // App.js
   import React, { useState, useRef, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView, RTCPeerConnection } from 'react-native-webrtc';

   const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
   const peerConnections = {};

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const [remoteStreams, setRemoteStreams] = useState([]);
     const signalingServer = useRef(new WebSocket('ws://localhost:8080'));

     useEffect(() => {
       signalingServer.current.onmessage = (message) => {
         const data = JSON.parse(message.data);
         if (data.type === 'offer') {
           const peerConnection = new RTCPeerConnection(configuration);
           peerConnections[data.from] = peerConnection;

           peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
           peerConnection.createAnswer().then((answer) => {
             peerConnection.setLocalDescription(answer);
             signalingServer.current.send(JSON.stringify({ ...answer, to: data.from }));
           });

           peerConnection.onicecandidate = (event) => {
             if (event.candidate) {
               signalingServer.current.send(JSON.stringify({ candidate: event.candidate, to: data.from }));
             }
           };

           peerConnection.onaddstream = (event) => {
             setRemoteStreams((prevStreams) => [...prevStreams, event.stream]);
           };
         } else if (data.type === 'answer') {
           const peerConnection = peerConnections[data.from];
           peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
         } else if (data.candidate) {
           const peerConnection = peerConnections[data.from];
           peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
         }
       };
     }, []);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       Object.values(peerConnections).forEach((pc) => {
         pc.addStream(stream);
       });
     };

     const createOffer = (peerId) => {
       const peerConnection = new RTCPeerConnection(configuration);
       peerConnections[peerId] = peerConnection;

       peerConnection.onicecandidate = (event) => {
         if (event.candidate) {
           signalingServer.current.send(JSON.stringify({ candidate: event.candidate, to: peerId }));
         }
       };

       peerConnection.onaddstream = (event) => {
         setRemoteStreams((prevStreams) => [...prevStreams, event.stream]);
       };

       peerConnection.addStream(localStream);

       peerConnection.createOffer().then((offer) => {
         peerConnection.setLocalDescription(offer);
         signalingServer.current.send(JSON.stringify({ ...offer, to: peerId }));
       });
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         <Button title="Create Offer" onPress={() => createOffer('peer1')} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '50%', height: '50%' }} />}
         {remoteStreams.map((stream, index) => (
           <RTCView key={index} streamURL={stream.toURL()} style={{ width: '50%', height: '50%' }} />
         ))}
       </View>
     );
   };



   export default App;
   ```

   **Explanation:**
   This example demonstrates handling multiple video streams in a WebRTC setup. It includes the ability to join a signaling server and receive offers from other peers. Each time an offer is received, a new `RTCPeerConnection` is created, and the remote video stream is added to the `remoteStreams` array. This setup allows multiple video streams to be displayed simultaneously, simulating a multi-participant video call.

**Online Resources:**
- [WebRTC Multi-Party Video Chat](https://www.tutorialspoint.com/webrtc/webrtc_multiparty_video_chat.htm)
- [WebRTC Signaling](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)

#### Task 2: Integrating with Third-Party Video Calling APIs

**Explanation:**
Third-party video calling APIs, such as those provided by Twilio, Agora, and Vonage, offer robust solutions for integrating video communication features into your applications. These APIs abstract the complexities of WebRTC and provide additional features like advanced analytics, recording, and cross-platform support. By using these services, developers can quickly add video calling capabilities to their applications without needing to manage the underlying infrastructure.

Integrating with a third-party API typically involves setting up an account, obtaining API keys, and using the provided SDKs to implement video calling features. These services often come with detailed documentation, sample code, and support to help developers get started. They also provide scalability and reliability, making them suitable for production applications.

**Online Resources:**
- [Twilio Video API Documentation](https://www.twilio.com/docs/video)
- [Agora Video SDK Documentation](https://docs.agora.io/en/Video)

**Examples to Practice:**

1. **Twilio Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { TwilioVideo } from 'twilio-video';

   const App = () => {
     const [room, setRoom] = useState(null);

     const connectToRoom = async () => {
       const token = 'YOUR_TWILIO_ACCESS_TOKEN'; // Replace with a valid Twilio token
       const videoRoom = await TwilioVideo.connect(token, { name: 'TestRoom' });
       setRoom(videoRoom);
     };

     useEffect(() => {
       if (room) {
         room.on('participantConnected', (participant) => {
           console.log('Participant connected:', participant.identity);
         });

         room.on('participantDisconnected', (participant) => {
           console.log('Participant disconnected:', participant.identity);
         });

         return () => {
           room.disconnect();
         };
       }
     }, [room]);

     return (
       <View style={{ flex: 1 }}>
         <Button title="Connect to Room" onPress={connectToRoom} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Twilio Video into a React Native application. The `TwilioVideo.connect` function is used to join a video room using a Twilio access token. The room's participants' connection and disconnection events are handled using event listeners. This setup allows users to join a video call and receive real-time updates about participant activity.

2. **Agora Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import RtcEngine from 'react-native-agora';

   const appId = 'YOUR_AGORA_APP_ID'; // Replace with your Agora App ID

   const App = () => {
     const [engine, setEngine] = useState(null);

     useEffect(() => {
       const init = async () => {
         const agoraEngine = await RtcEngine.create(appId);
         setEngine(agoraEngine);

         agoraEngine.addListener('UserJoined', (uid, elapsed) => {
           console.log('User joined:', uid);
         });

         agoraEngine.addListener('UserOffline', (uid, reason) => {
           console.log('User offline:', uid);
         });

         await agoraEngine.enableVideo();
       };

       init();

       return () => {
         if (engine) {
           engine.leaveChannel();
           engine.destroy();
         }
       };
     }, []);

     const joinChannel = async () => {
       await engine.joinChannel(null, 'TestChannel', null, 0);
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Join Channel" onPress={joinChannel} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Agora Video into a React Native application. The `RtcEngine.create` function initializes the Agora engine with the provided App ID. Event listeners are added to handle user join and leave events. The `joinChannel` function allows users to join a video channel. This setup enables video communication using Agora's services.

3. **Vonage Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { OTSession, OTPublisher, OTSubscriber } from 'opentok-react-native';

   const apiKey = 'YOUR_VONAGE_API_KEY'; // Replace with your Vonage API Key
   const sessionId = 'YOUR_VONAGE_SESSION_ID'; // Replace with your Vonage Session ID
   const token = 'YOUR_VONAGE_TOKEN'; // Replace with your Vonage Token

   const App = () => {
     const [connected, setConnected] = useState(false);

     useEffect(() => {
       if (connected) {
         console.log('Connected to session');
       }
     }, [connected]);

     return (
       <View style={{ flex: 1 }}>
         <OTSession apiKey={apiKey} sessionId={sessionId} token={token} onConnect={() => setConnected(true)}>
           {connected && <OTPublisher />}
           {connected && <OTSubscriber />}
         </OTSession>
         <Button title="Connect to Session" onPress={() => setConnected(true)} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Vonage Video into a React Native application. The `OTSession` component manages the connection to the Vonage session using the provided API key, session ID, and token. The `OTPublisher` and `OTSubscriber` components are used to handle video publishing and subscribing, respectively. This setup allows users to connect to a video session and start video communication.

**Online Resources:**
- [Twilio Video API Documentation](https://www.twilio.com/docs/video)
- [Agora Video SDK Documentation](https://docs.agora.io/en/Video)
- [Vonage Video API Documentation](https://www.vonage.com/communications-apis/video/)

### Task 4: Integrate Video Calling with WebRTC for Cross-Platform Development using React Native

#### Task 1: Setting Up WebRTC in React Native

**Explanation:**
WebRTC (Web Real-Time Communication) is a powerful technology that enables peer-to-peer audio, video, and data sharing directly between browsers and mobile applications. It is particularly useful for building applications like video calling, live streaming, and real-time gaming. For React Native, `react-native-webrtc` is the primary library used to integrate WebRTC functionality. This library provides access to the device's camera and microphone, and handles the creation of peer-to-peer connections and media streams.

Setting up WebRTC in React Native involves several steps: installing the `react-native-webrtc` library, configuring permissions for camera and microphone access, and initializing the media stream and peer connection. These steps lay the foundation for building more complex video calling functionalities.

**Online Resources:**
- [WebRTC Overview](https://webrtc.org/getting-started/overview)
- [React Native WebRTC GitHub Repository](https://github.com/react-native-webrtc/react-native-webrtc)

**Examples to Practice:**

1. **Basic WebRTC Setup:**
   ```javascript
   // App.js
   import React, { useState, useRef } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView } from 'react-native-webrtc';

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const localStreamRef = useRef(null);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       localStreamRef.current = stream;
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '100%', height: '100%' }} />}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example sets up a basic WebRTC environment in React Native. The `mediaDevices.getUserMedia` function is used to access the device's camera and microphone, creating a local media stream. The `RTCView` component from `react-native-webrtc` is used to display the video stream. This setup is essential for testing and verifying that WebRTC is correctly configured in the React Native application.

2. **Creating a WebRTC Peer Connection:**
   ```javascript
   // App.js
   import React, { useState, useRef, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView, RTCPeerConnection } from 'react-native-webrtc';

   const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
   const peerConnection = new RTCPeerConnection(configuration);

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const [remoteStream, setRemoteStream] = useState(null);
     const signalingServer = useRef(new WebSocket('ws://localhost:8080'));

     useEffect(() => {
       signalingServer.current.onmessage = (message) => {
         const data = JSON.parse(message.data);
         if (data.type === 'offer') {
           peerConnection.setRemoteDescription(new RTCSessionDescription(data));
           peerConnection.createAnswer().then((answer) => {
             peerConnection.setLocalDescription(answer);
             signalingServer.current.send(JSON.stringify(answer));
           });
         } else if (data.type === 'answer') {
           peerConnection.setRemoteDescription(new RTCSessionDescription(data));
         } else if (data.candidate) {
           peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
         }
       };

       peerConnection.onicecandidate = (event) => {
         if (event.candidate) {
           signalingServer.current.send(JSON.stringify(event.candidate));
         }
       };

       peerConnection.onaddstream = (event) => {
         setRemoteStream(event.stream);
       };
     }, []);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       peerConnection.addStream(stream);
     };

     const createOffer = () => {
       peerConnection.createOffer().then((offer) => {
         peerConnection.setLocalDescription(offer);
         signalingServer.current.send(JSON.stringify(offer));
       });
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         <Button title="Create Offer" onPress={createOffer} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '50%', height: '50%' }} />}
         {remoteStream && <RTCView streamURL={remoteStream.toURL()} style={{ width: '50%', height: '50%' }} />}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates how to create a WebRTC peer connection in React Native. It uses a WebSocket server for signaling to exchange SDP offers, answers, and ICE candidates. The `peerConnection` is configured with a STUN server to handle NAT traversal. The `startLocalStream` function initializes the local media stream, and the `createOffer` function initiates the connection by creating and sending an SDP offer.

3. **Handling Multiple Video Streams:**
   ```javascript
   // App.js
   import React, { useState, useRef, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { mediaDevices, RTCView, RTCPeerConnection } from 'react-native-webrtc';

   const configuration = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] };
   const peerConnections = {};

   const App = () => {
     const [localStream, setLocalStream] = useState(null);
     const [remoteStreams, setRemoteStreams] = useState([]);
     const signalingServer = useRef(new WebSocket('ws://localhost:8080'));

     useEffect(() => {
       signalingServer.current.onmessage = (message) => {
         const data = JSON.parse(message.data);
         if (data.type === 'offer') {
           const peerConnection = new RTCPeerConnection(configuration);
           peerConnections[data.from] = peerConnection;

           peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
           peerConnection.createAnswer().then((answer) => {
             peerConnection.setLocalDescription(answer);
             signalingServer.current.send(JSON.stringify({ ...answer, to: data.from }));
           });

           peerConnection.onicecandidate = (event) => {
             if (event.candidate) {
               signalingServer.current.send(JSON.stringify({ candidate: event.candidate, to: data.from }));
             }
           };

           peerConnection.onaddstream = (event) => {
             setRemoteStreams((prevStreams) => [...prevStreams, event.stream]);
           };
         } else if (data.type === 'answer') {
           const peerConnection = peerConnections[data.from];
           peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
         } else if (data.candidate) {
           const peerConnection = peerConnections[data.from];
           peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
         }
       };
     }, []);

     const startLocalStream = async () => {
       const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
       setLocalStream(stream);
       Object.values(peerConnections).forEach((pc) => {
         pc.addStream(stream);
       });
     };

     const createOffer = (peerId) => {
       const peerConnection = new RTCPeerConnection(configuration);
       peerConnections[peerId] = peerConnection;

       peerConnection.onicecandidate = (event) => {
         if (event.candidate) {
           signalingServer.current.send(JSON.stringify({ candidate: event.candidate, to: peerId }));
         }
       };

       peerConnection.onaddstream = (event) => {
         setRemoteStreams((prevStreams) => [...prevStreams, event.stream]);
       };

       peerConnection.addStream(localStream);

       peerConnection.createOffer().then((offer) => {
         peerConnection.setLocalDescription(offer);
         signalingServer.current.send(JSON.stringify({ ...offer, to: peerId }));
       });
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Start Local Stream" onPress={startLocalStream} />
         <Button title="Create Offer" onPress={() => createOffer('peer1')} />
         {localStream && <RTCView streamURL={localStream.toURL()} style={{ width: '50%', height: '50%' }} />}
         {remoteStreams.map((stream, index) => (
           <RTCView key={index} streamURL={stream.toURL()} style={{ width: '50%', height: '50%' }} />
         ))}
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example handles multiple video streams in a WebRTC setup, allowing for multi-participant video calls. Each participant is assigned a peer connection, and streams are added to the connections. The WebSocket server handles signaling for multiple peers, exchanging offers, answers, and ICE candidates. The `RTCView` components display the local and remote video streams, supporting multi-participant video calls.

**Online Resources:**
- [WebRTC Multi-Party Video Chat

](https://www.tutorialspoint.com/webrtc/webrtc_multiparty_video_chat.htm)
- [WebRTC Signaling](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API/Signaling_and_video_calling)

#### Task 2: Integrating WebRTC with Third-Party APIs

**Explanation:**
Third-party video calling APIs, such as those provided by Twilio, Agora, and Vonage, offer robust solutions for integrating video communication features into your applications. These APIs abstract the complexities of WebRTC and provide additional features like advanced analytics, recording, and cross-platform support. By using these services, developers can quickly add video calling capabilities to their applications without needing to manage the underlying infrastructure.

Integrating with a third-party API typically involves setting up an account, obtaining API keys, and using the provided SDKs to implement video calling features. These services often come with detailed documentation, sample code, and support to help developers get started. They also provide scalability and reliability, making them suitable for production applications.

**Online Resources:**
- [Twilio Video API Documentation](https://www.twilio.com/docs/video)
- [Agora Video SDK Documentation](https://docs.agora.io/en/Video)

**Examples to Practice:**

1. **Twilio Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { TwilioVideo } from 'twilio-video';

   const App = () => {
     const [room, setRoom] = useState(null);

     const connectToRoom = async () => {
       const token = 'YOUR_TWILIO_ACCESS_TOKEN'; // Replace with a valid Twilio token
       const videoRoom = await TwilioVideo.connect(token, { name: 'TestRoom' });
       setRoom(videoRoom);
     };

     useEffect(() => {
       if (room) {
         room.on('participantConnected', (participant) => {
           console.log('Participant connected:', participant.identity);
         });

         room.on('participantDisconnected', (participant) => {
           console.log('Participant disconnected:', participant.identity);
         });

         return () => {
           room.disconnect();
         };
       }
     }, [room]);

     return (
       <View style={{ flex: 1 }}>
         <Button title="Connect to Room" onPress={connectToRoom} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Twilio Video into a React Native application. The `TwilioVideo.connect` function is used to join a video room using a Twilio access token. The room's participants' connection and disconnection events are handled using event listeners. This setup allows users to join a video call and receive real-time updates about participant activity.

2. **Agora Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import RtcEngine from 'react-native-agora';

   const appId = 'YOUR_AGORA_APP_ID'; // Replace with your Agora App ID

   const App = () => {
     const [engine, setEngine] = useState(null);

     useEffect(() => {
       const init = async () => {
         const agoraEngine = await RtcEngine.create(appId);
         setEngine(agoraEngine);

         agoraEngine.addListener('UserJoined', (uid, elapsed) => {
           console.log('User joined:', uid);
         });

         agoraEngine.addListener('UserOffline', (uid, reason) => {
           console.log('User offline:', uid);
         });

         await agoraEngine.enableVideo();
       };

       init();

       return () => {
         if (engine) {
           engine.leaveChannel();
           engine.destroy();
         }
       };
     }, []);

     const joinChannel = async () => {
       await engine.joinChannel(null, 'TestChannel', null, 0);
     };

     return (
       <View style={{ flex: 1 }}>
         <Button title="Join Channel" onPress={joinChannel} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Agora Video into a React Native application. The `RtcEngine.create` function initializes the Agora engine with the provided App ID. Event listeners are added to handle user join and leave events. The `joinChannel` function allows users to join a video channel. This setup enables video communication using Agora's services.

3. **Vonage Video Integration:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, Button } from 'react-native';
   import { OTSession, OTPublisher, OTSubscriber } from 'opentok-react-native';

   const apiKey = 'YOUR_VONAGE_API_KEY'; // Replace with your Vonage API Key
   const sessionId = 'YOUR_VONAGE_SESSION_ID'; // Replace with your Vonage Session ID
   const token = 'YOUR_VONAGE_TOKEN'; // Replace with your Vonage Token

   const App = () => {
     const [connected, setConnected] = useState(false);

     useEffect(() => {
       if (connected) {
         console.log('Connected to session');
       }
     }, [connected]);

     return (
       <View style={{ flex: 1 }}>
         <OTSession apiKey={apiKey} sessionId={sessionId} token={token} onConnect={() => setConnected(true)}>
           {connected && <OTPublisher />}
           {connected && <OTSubscriber />}
         </OTSession>
         <Button title="Connect to Session" onPress={() => setConnected(true)} />
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates integrating Vonage Video into a React Native application. The `OTSession` component manages the connection to the Vonage session using the provided API key, session ID, and token. The `OTPublisher` and `OTSubscriber` components are used to handle video publishing and subscribing, respectively. This setup allows users to connect to a video session and start video communication.

**Online Resources:**
- [Twilio Video API Documentation](https://www.twilio.com/docs/video)
- [Agora Video SDK Documentation](https://docs.agora.io/en/Video)
- [Vonage Video API Documentation](https://www.vonage.com/communications-apis/video/)

### Task 5: Study Offline-First Design Principles for Cross-Platform Development using React Native

#### Task 1: Understanding Offline-First Design Principles

**Explanation:**
Offline-first design is a paradigm that prioritizes offline functionality in applications. The core idea is to ensure that an application remains fully functional even when there is no internet connectivity. This approach improves the user experience by providing uninterrupted access to application features, data, and content. It also enhances performance and reliability by reducing dependency on network availability.

Implementing an offline-first approach typically involves strategies like local storage, data synchronization, and intelligent caching. Technologies such as IndexedDB, Service Workers, and libraries like Redux Offline and SQLite are often used to support offline functionality. By caching data locally and synchronizing it with a remote server when connectivity is available, developers can create resilient applications that provide a seamless user experience regardless of network conditions.

**Online Resources:**
- [Offline-First Web Development](https://offlinefirst.org/)
- [MDN Web Docs: Offline Web Applications](https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Offline_Service_workers)

**Examples to Practice:**

1. **Local Storage with AsyncStorage:**
   ```javascript
   // App.js
   import React, { useState, useEffect } from 'react';
   import { View, TextInput, Button, Text } from 'react-native';
   import AsyncStorage from '@react-native-async-storage/async-storage';

   const App = () => {
     const [data, setData] = useState('');
     const [storedData, setStoredData] = useState('');

     useEffect(() => {
       const fetchData = async () => {
         const value = await AsyncStorage.getItem('myData');
         if (value !== null) {
           setStoredData(value);
         }
       };

       fetchData();
     }, []);

     const saveData = async () => {
       await AsyncStorage.setItem('myData', data);
       setStoredData(data);
     };

     return (
       <View style={{ padding: 20 }}>
         <TextInput
           placeholder="Enter some data"
           value={data}
           onChangeText={setData}
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
         />
         <Button title="Save Data" onPress={saveData} />
         <Text>Stored Data: {storedData}</Text>
       </View>
     );
   };

   export default App;
   ```

   **Explanation:**
   This example demonstrates how to use AsyncStorage for local storage in a React Native application. AsyncStorage is a simple, asynchronous, unencrypted, persistent key-value storage system that is global to the app. The application allows users to input data, save it locally using AsyncStorage, and retrieve the stored data even after restarting the app. This approach ensures data persistence and offline accessibility.

2. **Offline Data Synchronization with Redux Persist:**
   ```javascript
   // App.js
   import React from 'react';
   import { Provider } from 'react-redux';
   import { createStore } from 'redux';
   import { PersistGate } from 'redux-persist/integration/react';
   import { persistStore, persistReducer } from 'redux-persist';
   import storage from 'redux-persist/lib/storage';
   import rootReducer from './reducers';
   import AppContent from './AppContent';

   const persistConfig = {
     key: 'root',
     storage,
   };

   const persistedReducer = persistReducer(persistConfig, rootReducer);
   const store = createStore(persistedReducer);
   const persistor = persistStore(store);

   const App = () => (
     <Provider store={store}>
       <PersistGate loading={null} persistor={persistor}>
         <AppContent />
       </PersistGate>
     </Provider>
   );

   export default App;
   ```

   ```javascript
   // AppContent.js
   import React, { useState } from 'react';
   import { View, TextInput, Button, Text } from 'react-native';
   import { useDispatch, useSelector } from 'react-redux';

   const AppContent = () => {
     const [input, setInput] = useState('');
     const dispatch = useDispatch();
     const storedData = useSelector(state => state.data);

     const saveData = () => {
       dispatch({ type: 'SAVE_DATA', payload: input });
     };

     return (
       <View style={{ padding: 20 }}>
         <TextInput
           placeholder="Enter some data"
           value={input}
           onChangeText={setInput}
           style={{ height: 40, borderColor: 'gray', borderWidth: 1, marginBottom: 10 }}
         />
         <Button title="Save Data" onPress={saveData} />
         <Text>Stored Data: {storedData}</Text>
       </View>
     );
   };

   export default AppContent;
   ```

   ```javascript
   // reducers.js
   const initialState = {
     data: '',
   };

   const rootReducer = (state = initialState, action) => {
     switch (action.type) {
       case 'SAVE_DATA':
         return { ...state, data: action.payload };
       default:
         return state;
     }
   };

   export default rootReducer;
   ```

   **Explanation:**
   This example shows how to use Redux Persist for offline data synchronization in a React Native application. Redux Persist is a library that automatically persists and rehydrates Redux state, ensuring that the state is saved to local storage and reloaded when the app restarts. The application uses Redux for state management, and the persisted state is displayed even after restarting the app. This approach ensures data persistence and offline accessibility.

3. **Caching API Responses with React Query:**
   ```javascript
   // App.js
   import React from 'react';
   import { QueryClient, QueryClientProvider, useQuery } from 'react-query';
   import { View, Text, Button } from 'react-native';
   import AsyncStorage from '@react-native-async-storage/async-storage';

   const queryClient = new QueryClient({
     defaultOptions: {
       queries: {
         cacheTime: 1000 * 60 * 5,
         refetchOnWindowFocus: false,
         staleTime: 1000 * 60 * 1,
         storage: AsyncStorage,
       },
     },
   });

   const fetchData = async () => {
     const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
     return response.json();
   };

   const DataComponent = () => {
     const { data, refetch } = useQuery('fetchData', fetchData);

     return (
       <View style={{ padding: 20 }}>
         <Text>Data: {JSON.stringify(data)}</Text>
         <Button title="Refetch Data" onPress={refetch} />
       </View>
     );
   };

   const App = () => (
     <QueryClientProvider client={queryClient}>
       <DataComponent />
     </QueryClientProvider>
   );

   export default App;
   ```

   **Explanation:**
   This example demonstrates how to use React Query to cache API responses in a React Native application. React Query is a library for fetching, caching, and synchronizing server state in React applications. The example fetches data from a placeholder API and caches the response using AsyncStorage. The cached data is displayed even when the app is offline, and users can manually refetch the data. This approach ensures efficient data fetching and offline accessibility.

**Online Resources:**
- [Redux Persist Documentation](https://github.com/rt2zz/redux-persist)
- [React Query Documentation](https://react-query.tanstack.com/)

