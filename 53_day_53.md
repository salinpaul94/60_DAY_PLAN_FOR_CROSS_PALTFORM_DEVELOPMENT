### Task 1: Reviewing Redux Saga for Complex State Management

#### Overview of Redux Saga
Redux Saga is a library that helps to manage side effects in Redux applications. Side effects can include things like asynchronous operations, accessing the browser cache, and interacting with the browser's API. Redux Saga uses generator functions to make the side effects easier to manage, more readable, and testable. It allows developers to handle complex asynchronous flows in a more straightforward manner by providing a simple way to execute, cancel, and handle side effects.

The primary advantage of Redux Saga is its ability to handle more complex scenarios than what can be easily managed with Redux Thunk or other middleware. With Redux Saga, you can listen to Redux actions, call API endpoints, dispatch new actions, and manage the application's state in response to side effects. This makes it a powerful tool for applications with intricate side effects or real-time updates.

#### Resources to Learn Redux Saga
1. [Redux-Saga Official Documentation](https://redux-saga.js.org/)
2. [Redux Saga Tutorial by Toptal](https://www.toptal.com/react/react-native-redux-saga-tutorial)

### Example 1: Basic Redux Saga Implementation
#### Explanation
In this example, we will create a simple Redux Saga to handle an asynchronous API call to fetch user data. This example demonstrates the core concepts of Redux Saga, such as `takeEvery`, `call`, and `put`.

We will define a saga that listens for a `FETCH_USER` action, makes an API call to fetch user data, and then dispatches either a `FETCH_USER_SUCCESS` or `FETCH_USER_FAILURE` action based on the API response. This helps in understanding the basic structure of a saga and how to manage asynchronous flows.

#### Code
```javascript
// actions.js
export const FETCH_USER = 'FETCH_USER';
export const FETCH_USER_SUCCESS = 'FETCH_USER_SUCCESS';
export const FETCH_USER_FAILURE = 'FETCH_USER_FAILURE';

export const fetchUser = () => ({
  type: FETCH_USER
});

export const fetchUserSuccess = user => ({
  type: FETCH_USER_SUCCESS,
  payload: user
});

export const fetchUserFailure = error => ({
  type: FETCH_USER_FAILURE,
  payload: error
});

// api.js
export const fetchUserData = () => {
  return fetch('https://jsonplaceholder.typicode.com/users/1')
    .then(response => response.json())
    .catch(error => { throw error });
};

// sagas.js
import { call, put, takeEvery } from 'redux-saga/effects';
import { FETCH_USER, fetchUserSuccess, fetchUserFailure } from './actions';
import { fetchUserData } from './api';

function* fetchUserSaga() {
  try {
    const user = yield call(fetchUserData);
    yield put(fetchUserSuccess(user));
  } catch (error) {
    yield put(fetchUserFailure(error));
  }
}

export default function* rootSaga() {
  yield takeEvery(FETCH_USER, fetchUserSaga);
}

// reducers.js
import { FETCH_USER_SUCCESS, FETCH_USER_FAILURE } from './actions';

const initialState = {
  user: null,
  error: null
};

export const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_USER_SUCCESS:
      return { ...state, user: action.payload, error: null };
    case FETCH_USER_FAILURE:
      return { ...state, user: null, error: action.payload };
    default:
      return state;
  }
};

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { userReducer } from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(userReducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);

export default store;
```

#### Expected Output
When the `FETCH_USER` action is dispatched, the saga will make an API call to fetch user data. If the call is successful, the `FETCH_USER_SUCCESS` action will be dispatched with the user data. If the call fails, the `FETCH_USER_FAILURE` action will be dispatched with an error message. The application's state will be updated accordingly to reflect the success or failure of the API call.

#### Resources to Practice Redux Saga
1. [Learn Redux-Saga with React: Step-by-Step Guide](https://levelup.gitconnected.com/learn-redux-saga-with-react-js-5e6d65e1b45c)
2. [Redux Saga Advanced Concepts](https://redux-saga.js.org/docs/advanced/advanced)

### Example 2: Handling Multiple API Requests
#### Explanation
In this example, we will extend our basic saga to handle multiple API requests. We will create a saga that listens for a `FETCH_MULTIPLE_USERS` action, makes API calls to fetch data for multiple users, and then dispatches actions based on the responses.

This example demonstrates how to handle multiple concurrent API requests and aggregate their results. It introduces the `all` effect from Redux Saga, which allows us to run multiple sagas in parallel and wait for all of them to complete before proceeding.

#### Code
```javascript
// actions.js
export const FETCH_MULTIPLE_USERS = 'FETCH_MULTIPLE_USERS';
export const FETCH_MULTIPLE_USERS_SUCCESS = 'FETCH_MULTIPLE_USERS_SUCCESS';
export const FETCH_MULTIPLE_USERS_FAILURE = 'FETCH_MULTIPLE_USERS_FAILURE';

export const fetchMultipleUsers = () => ({
  type: FETCH_MULTIPLE_USERS
});

export const fetchMultipleUsersSuccess = users => ({
  type: FETCH_MULTIPLE_USERS_SUCCESS,
  payload: users
});

export const fetchMultipleUsersFailure = error => ({
  type: FETCH_MULTIPLE_USERS_FAILURE,
  payload: error
});

// api.js
export const fetchMultipleUserData = (ids) => {
  return Promise.all(ids.map(id => fetch(`https://jsonplaceholder.typicode.com/users/${id}`)
    .then(response => response.json())))
    .catch(error => { throw error });
};

// sagas.js
import { call, put, takeEvery, all } from 'redux-saga/effects';
import { FETCH_MULTIPLE_USERS, fetchMultipleUsersSuccess, fetchMultipleUsersFailure } from './actions';
import { fetchMultipleUserData } from './api';

function* fetchMultipleUsersSaga() {
  try {
    const users = yield call(fetchMultipleUserData, [1, 2, 3]);
    yield put(fetchMultipleUsersSuccess(users));
  } catch (error) {
    yield put(fetchMultipleUsersFailure(error));
  }
}

export default function* rootSaga() {
  yield all([
    takeEvery(FETCH_MULTIPLE_USERS, fetchMultipleUsersSaga)
  ]);
}

// reducers.js
import { FETCH_MULTIPLE_USERS_SUCCESS, FETCH_MULTIPLE_USERS_FAILURE } from './actions';

const initialState = {
  users: [],
  error: null
};

export const usersReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_MULTIPLE_USERS_SUCCESS:
      return { ...state, users: action.payload, error: null };
    case FETCH_MULTIPLE_USERS_FAILURE:
      return { ...state, users: [], error: action.payload };
    default:
      return state;
  }
};

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { usersReducer } from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(usersReducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);

export default store;
```

#### Expected Output
When the `FETCH_MULTIPLE_USERS` action is dispatched, the saga will make multiple API calls to fetch data for users with IDs 1, 2, and 3. If all calls are successful, the `FETCH_MULTIPLE_USERS_SUCCESS` action will be dispatched with the users' data. If any call fails, the `FETCH_MULTIPLE_USERS_FAILURE` action will be dispatched with an error message. The application's state will be updated to reflect the aggregated results of the API calls.

### Example 3: Cancelling Ongoing API Requests
#### Explanation
In this example, we will create a saga that handles cancelling ongoing API requests. This is useful in scenarios where a user might navigate away from a page or initiate another action that makes the current request irrelevant. We will introduce the `takeLatest` effect from Redux Saga to ensure only the latest API request is active, and any previous requests are cancelled.

This example demonstrates how to manage cancellation of ongoing side effects using Redux Saga. It helps to understand how to improve the efficiency of the application by avoiding unnecessary network requests and handling user interactions gracefully.

#### Code
```javascript
// actions.js
export const CANCEL_FETCH_USER = 'CANCEL_FETCH_USER';

export const cancelFetchUser = () => ({
  type: CANCEL_FETCH_USER
});

// sagas.js
import { call, put, takeLatest, cancelled } from 'redux-saga/effects';
import { FETCH_USER, fetchUserSuccess, fetchUserFailure, CANCEL_FETCH_USER } from './actions';
import { fetchUserData } from './api';

function* fetchUserSaga() {
  try {
    const user = yield call(fetchUserData);
    yield put(fetchUserSuccess(user));
  } catch (error) {
    yield put(fetchUserFailure(error));
  } finally {
    if (yield cancelled()) {
      console.log('Fetch user saga cancelled');
    }
  }
}

export default function* rootSaga() {
  yield takeLatest(FETCH_USER, fetchUserSaga);
}

// components/FetchUserButton.js
import React from 'react';
import { useDispatch } from 'react-redux';
import { fetchUser, cancelFetchUser } from '../actions';

const FetchUserButton = () => {
  const dispatch = useDispatch();

  const handleFetchUser = () => {
    dispatch

(fetchUser());
  };

  const handleCancelFetchUser = () => {
    dispatch(cancelFetchUser());
  };

  return (
    <div>
      <button onClick={handleFetchUser}>Fetch User</button>
      <button onClick={handleCancelFetchUser}>Cancel Fetch</button>
    </div>
  );
};

export default FetchUserButton;
```

#### Expected Output
When the `FETCH_USER` action is dispatched, the saga will start an API call to fetch user data. If the `CANCEL_FETCH_USER` action is dispatched before the API call completes, the saga will cancel the ongoing request, and the console will log "Fetch user saga cancelled." The application's state will reflect the cancellation, and no further actions will be dispatched.

#### Resources to Practice Redux Saga with Cancellation
1. [Redux-Saga Cancellation](https://redux-saga.js.org/docs/advanced/Cancellation/)
2. [Managing Side Effects with Redux-Saga](https://blog.logrocket.com/managing-side-effects-with-redux-saga/)

---

### Task 2: Integrate Redux Saga for Asynchronous Operations

#### Overview of Redux Saga
Redux Saga is a middleware library designed to handle side effects in Redux applications. Side effects can include operations like asynchronous API calls, data fetching, and more complex scenarios like synchronous flows or real-time updates. Redux Saga uses generator functions to control the flow of side effects, making the code more predictable and easier to test.

The main advantage of using Redux Saga is its ability to manage complex asynchronous operations in a clean and maintainable way. It helps in decoupling side effect logic from the UI and other business logic, promoting better code organization. By using Redux Saga, developers can handle side effects declaratively, making the code more readable and easier to debug.

#### Resources to Learn Redux Saga
1. [Redux-Saga Official Documentation](https://redux-saga.js.org/)
2. [Redux Saga Beginner Tutorial](https://redux-saga.js.org/docs/introduction/BeginnerTutorial)

### Example 1: Basic API Call with Redux Saga
#### Explanation
In this example, we will set up a basic Redux Saga to handle an asynchronous API call to fetch data from a public API. This example demonstrates the core concepts of Redux Saga, including the `takeEvery`, `call`, and `put` effects.

The saga will listen for a `FETCH_DATA_REQUEST` action, call an API to fetch data, and then dispatch either a `FETCH_DATA_SUCCESS` or `FETCH_DATA_FAILURE` action based on the API response. This will help you understand the basic structure of a saga and how to manage asynchronous operations using Redux Saga.

#### Code
```javascript
// actions.js
export const FETCH_DATA_REQUEST = 'FETCH_DATA_REQUEST';
export const FETCH_DATA_SUCCESS = 'FETCH_DATA_SUCCESS';
export const FETCH_DATA_FAILURE = 'FETCH_DATA_FAILURE';

export const fetchDataRequest = () => ({
  type: FETCH_DATA_REQUEST
});

export const fetchDataSuccess = data => ({
  type: FETCH_DATA_SUCCESS,
  payload: data
});

export const fetchDataFailure = error => ({
  type: FETCH_DATA_FAILURE,
  payload: error
});

// api.js
export const fetchDataFromApi = () => {
  return fetch('https://jsonplaceholder.typicode.com/posts')
    .then(response => response.json())
    .catch(error => { throw error });
};

// sagas.js
import { call, put, takeEvery } from 'redux-saga/effects';
import { FETCH_DATA_REQUEST, fetchDataSuccess, fetchDataFailure } from './actions';
import { fetchDataFromApi } from './api';

function* fetchDataSaga() {
  try {
    const data = yield call(fetchDataFromApi);
    yield put(fetchDataSuccess(data));
  } catch (error) {
    yield put(fetchDataFailure(error));
  }
}

export default function* rootSaga() {
  yield takeEvery(FETCH_DATA_REQUEST, fetchDataSaga);
}

// reducers.js
import { FETCH_DATA_SUCCESS, FETCH_DATA_FAILURE } from './actions';

const initialState = {
  data: [],
  error: null
};

export const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case FETCH_DATA_SUCCESS:
      return { ...state, data: action.payload, error: null };
    case FETCH_DATA_FAILURE:
      return { ...state, data: [], error: action.payload };
    default:
      return state;
  }
};

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { dataReducer } from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(dataReducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);

export default store;

// App.js
import React from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';
import { fetchDataRequest } from './actions';

const App = () => {
  const dispatch = useDispatch();
  const data = useSelector(state => state.data);
  const error = useSelector(state => state.error);

  const handleFetchData = () => {
    dispatch(fetchDataRequest());
  };

  return (
    <Provider store={store}>
      <div>
        <button onClick={handleFetchData}>Fetch Data</button>
        {error && <p>Error: {error}</p>}
        <ul>
          {data.map(item => (
            <li key={item.id}>{item.title}</li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```

#### Expected Output
When the `FETCH_DATA_REQUEST` action is dispatched, the saga will make an API call to fetch data. If the call is successful, the `FETCH_DATA_SUCCESS` action will be dispatched with the fetched data, and the list of data items will be displayed. If the call fails, the `FETCH_DATA_FAILURE` action will be dispatched with an error message, and an error message will be displayed.

#### Resources to Practice Redux Saga
1. [Redux-Saga Cheat Sheet](https://dev.to/redux-saga/redux-saga-cheat-sheet-2kk8)
2. [Handling Asynchronous Flows with Redux-Saga](https://medium.com/swlh/handling-asynchronous-flows-with-redux-saga-2fef29a6b7b3)

### Example 2: Handling Form Submissions with Redux Saga
#### Explanation
In this example, we will create a saga to handle form submissions. When a user submits a form, the saga will make an API call to submit the form data and handle the response. This example demonstrates how to handle user inputs and form submissions using Redux Saga.

The saga will listen for a `SUBMIT_FORM_REQUEST` action, call an API to submit the form data, and then dispatch either a `SUBMIT_FORM_SUCCESS` or `SUBMIT_FORM_FAILURE` action based on the API response. This will help you understand how to manage asynchronous operations related to form submissions using Redux Saga.

#### Code
```javascript
// actions.js
export const SUBMIT_FORM_REQUEST = 'SUBMIT_FORM_REQUEST';
export const SUBMIT_FORM_SUCCESS = 'SUBMIT_FORM_SUCCESS';
export const SUBMIT_FORM_FAILURE = 'SUBMIT_FORM_FAILURE';

export const submitFormRequest = formData => ({
  type: SUBMIT_FORM_REQUEST,
  payload: formData
});

export const submitFormSuccess = response => ({
  type: SUBMIT_FORM_SUCCESS,
  payload: response
});

export const submitFormFailure = error => ({
  type: SUBMIT_FORM_FAILURE,
  payload: error
});

// api.js
export const submitFormData = formData => {
  return fetch('https://jsonplaceholder.typicode.com/posts', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(formData)
  })
  .then(response => response.json())
  .catch(error => { throw error });
};

// sagas.js
import { call, put, takeEvery } from 'redux-saga/effects';
import { SUBMIT_FORM_REQUEST, submitFormSuccess, submitFormFailure } from './actions';
import { submitFormData } from './api';

function* submitFormSaga(action) {
  try {
    const response = yield call(submitFormData, action.payload);
    yield put(submitFormSuccess(response));
  } catch (error) {
    yield put(submitFormFailure(error));
  }
}

export default function* rootSaga() {
  yield takeEvery(SUBMIT_FORM_REQUEST, submitFormSaga);
}

// reducers.js
import { SUBMIT_FORM_SUCCESS, SUBMIT_FORM_FAILURE } from './actions';

const initialState = {
  response: null,
  error: null
};

export const formReducer = (state = initialState, action) => {
  switch (action.type) {
    case SUBMIT_FORM_SUCCESS:
      return { ...state, response: action.payload, error: null };
    case SUBMIT_FORM_FAILURE:
      return { ...state, response: null, error: action.payload };
    default:
      return state;
  }
};

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { formReducer } from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(formReducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);

export default store;

// Form.js
import React, { useState } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { submitFormRequest } from './actions';

const Form = () => {
  const [formData, setFormData] = useState({ title: '', body: '' });
  const dispatch = useDispatch();
  const response = useSelector(state => state.response);
  const error = useSelector(state => state.error);

  const handleSubmit = (event) => {
    event.preventDefault();
    dispatch(submitFormRequest(formData));
  };

  return (
    <div>
      <form onSubmit={handleSubmit}>
        <input
          type="text"
          placeholder="Title"
          value={formData.title}
          onChange={(e) => setFormData({ ...formData, title: e.target.value })}
        />
        <input
          type="text"
          placeholder="Body"
          value={formData.body}
          onChange={(e) => setFormData({ ...formData, body: e.target.value })}
        />
        <button type="submit">Submit</button>
      </form>
      {response && <p>Response: {JSON.stringify(response)}</p>}
      {error && <p>Error: {error}</p>}
    </div>
  );
};

export default Form;
```

#### Expected Output


When the `SUBMIT_FORM_REQUEST` action is dispatched, the saga will make an API call to submit the form data. If the call is successful, the `SUBMIT_FORM_SUCCESS` action will be dispatched with the API response, and the response will be displayed. If the call fails, the `SUBMIT_FORM_FAILURE` action will be dispatched with an error message, and an error message will be displayed.

#### Resources to Practice Redux Saga with Form Submissions
1. [Managing Forms in Redux with Redux-Saga](https://medium.com/@sampart/magic-forms-in-redux-with-redux-saga-bfa1ff84420c)
2. [Building Forms with Redux Form and Redux Saga](https://alligator.io/redux/redux-form-redux-saga/)

### Example 3: Real-time Data Fetching with Redux Saga
#### Explanation
In this example, we will create a saga to handle real-time data fetching. This involves setting up a periodic task that fetches data from an API at regular intervals. This example demonstrates how to handle polling or real-time updates using Redux Saga.

The saga will listen for a `START_POLLING` action, start a periodic task to fetch data from an API every few seconds, and dispatch either a `POLLING_SUCCESS` or `POLLING_FAILURE` action based on the API response. This will help you understand how to manage real-time data fetching using Redux Saga.

#### Code
```javascript
// actions.js
export const START_POLLING = 'START_POLLING';
export const STOP_POLLING = 'STOP_POLLING';
export const POLLING_SUCCESS = 'POLLING_SUCCESS';
export const POLLING_FAILURE = 'POLLING_FAILURE';

export const startPolling = () => ({
  type: START_POLLING
});

export const stopPolling = () => ({
  type: STOP_POLLING
});

export const pollingSuccess = data => ({
  type: POLLING_SUCCESS,
  payload: data
});

export const pollingFailure = error => ({
  type: POLLING_FAILURE,
  payload: error
});

// api.js
export const fetchDataFromApi = () => {
  return fetch('https://jsonplaceholder.typicode.com/posts')
    .then(response => response.json())
    .catch(error => { throw error });
};

// sagas.js
import { call, put, takeEvery, delay, race, take } from 'redux-saga/effects';
import { START_POLLING, STOP_POLLING, pollingSuccess, pollingFailure } from './actions';
import { fetchDataFromApi } from './api';

function* pollingSaga() {
  try {
    while (true) {
      const data = yield call(fetchDataFromApi);
      yield put(pollingSuccess(data));
      yield delay(5000);  // Poll every 5 seconds
    }
  } catch (error) {
    yield put(pollingFailure(error));
  }
}

function* watchPolling() {
  while (true) {
    yield take(START_POLLING);
    yield race([
      call(pollingSaga),
      take(STOP_POLLING)
    ]);
  }
}

export default function* rootSaga() {
  yield watchPolling();
}

// reducers.js
import { POLLING_SUCCESS, POLLING_FAILURE } from './actions';

const initialState = {
  data: [],
  error: null
};

export const dataReducer = (state = initialState, action) => {
  switch (action.type) {
    case POLLING_SUCCESS:
      return { ...state, data: action.payload, error: null };
    case POLLING_FAILURE:
      return { ...state, data: [], error: action.payload };
    default:
      return state;
  }
};

// store.js
import { createStore, applyMiddleware } from 'redux';
import createSagaMiddleware from 'redux-saga';
import { dataReducer } from './reducers';
import rootSaga from './sagas';

const sagaMiddleware = createSagaMiddleware();
const store = createStore(dataReducer, applyMiddleware(sagaMiddleware));

sagaMiddleware.run(rootSaga);

export default store;

// App.js
import React from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import store from './store';
import { startPolling, stopPolling } from './actions';

const App = () => {
  const dispatch = useDispatch();
  const data = useSelector(state => state.data);
  const error = useSelector(state => state.error);

  const handleStartPolling = () => {
    dispatch(startPolling());
  };

  const handleStopPolling = () => {
    dispatch(stopPolling());
  };

  return (
    <Provider store={store}>
      <div>
        <button onClick={handleStartPolling}>Start Polling</button>
        <button onClick={handleStopPolling}>Stop Polling</button>
        {error && <p>Error: {error}</p>}
        <ul>
          {data.map(item => (
            <li key={item.id}>{item.title}</li>
          ))}
        </ul>
      </div>
    </Provider>
  );
};

export default App;
```

#### Expected Output
When the `START_POLLING` action is dispatched, the saga will start a periodic task to fetch data from the API every 5 seconds. If the call is successful, the `POLLING_SUCCESS` action will be dispatched with the fetched data, and the list of data items will be updated. If the call fails, the `POLLING_FAILURE` action will be dispatched with an error message, and an error message will be displayed. The polling can be stopped by dispatching the `STOP_POLLING` action.

#### Resources to Practice Redux Saga with Real-time Data Fetching
1. [Real-time Data Fetching with Redux Saga](https://blog.logrocket.com/real-time-data-fetching-with-redux-saga/)
2. [Polling with Redux Saga](https://medium.com/@xpl/using-redux-saga-to-poll-server-4f85b2a30c85)

---

### Task 3: Study Advanced Caching Techniques

#### Overview of Advanced Caching Techniques
Caching is a technique used to store copies of files or data in a cache, or temporary storage location, so that they can be accessed more quickly. In the context of mobile app development, caching helps improve performance and user experience by reducing the need to fetch data repeatedly from the network. Advanced caching techniques involve strategies like in-memory caching, disk caching, and using libraries that provide efficient caching mechanisms.

One of the key benefits of advanced caching is that it helps in offline access. Users can still access certain functionalities or data of the app even when they are not connected to the internet. Effective caching strategies can also reduce the load on servers, improve app responsiveness, and enhance overall app performance.

#### Resources to Learn Advanced Caching Techniques
1. [Caching in React Native](https://blog.logrocket.com/data-caching-in-react-native/)
2. [React Native Caching Strategies](https://www.reactnativeschool.com/blog/data-caching-in-react-native/)

### Example 1: Using AsyncStorage for Caching Data
#### Explanation
AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the app. It is recommended for storing relatively small amounts of data that a user would need frequently. AsyncStorage is an ideal solution for caching data in React Native apps.

In this example, we will use AsyncStorage to cache data fetched from an API. The app will first check if the data is available in the cache; if it is, the app will use the cached data. If the data is not available or if it is outdated, the app will fetch the data from the API and then store it in AsyncStorage for future use.

#### Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { View, Text, Button, AsyncStorage } from 'react-native';

const fetchDataFromApi = async () => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  return response.json();
};

const App = () => {
  const [data, setData] = useState([]);
  const [error, setError] = useState(null);

  const getData = async () => {
    try {
      const cachedData = await AsyncStorage.getItem('posts');
      if (cachedData) {
        setData(JSON.parse(cachedData));
      } else {
        const apiData = await fetchDataFromApi();
        setData(apiData);
        await AsyncStorage.setItem('posts', JSON.stringify(apiData));
      }
    } catch (err) {
      setError(err.message);
    }
  };

  useEffect(() => {
    getData();
  }, []);

  return (
    <View>
      <Button title="Refresh Data" onPress={getData} />
      {error && <Text>Error: {error}</Text>}
      {data.map(post => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will attempt to fetch data from the cache. If the data is found in the cache, it will be displayed. If not, the app will fetch the data from the API, display it, and cache it for future use. Pressing the "Refresh Data" button will re-fetch the data from the API and update the cache.

#### Resources to Practice Caching with AsyncStorage
1. [AsyncStorage in React Native](https://reactnative.dev/docs/asyncstorage)
2. [Persisting Data with AsyncStorage](https://medium.com/react-native-training/asyncstorage-persisting-data-in-react-native-6fbc1f4d3a40)

### Example 2: Using Redux Persist for Caching Redux State
#### Explanation
Redux Persist is a library that allows you to save the Redux store in persistent storage, such as AsyncStorage, so that the state can be rehydrated when the app is reloaded. This technique is beneficial for caching the state of the app and maintaining the state across app sessions.

In this example, we will configure Redux Persist to cache the Redux state in AsyncStorage. The app will save the Redux state in AsyncStorage when the state changes and rehydrate the state from AsyncStorage when the app is loaded.

#### Code
```javascript
// store.js
import { createStore } from 'redux';
import { persistStore, persistReducer } from 'redux-persist';
import storage from 'redux-persist/lib/storage'; // defaults to AsyncStorage for React Native
import rootReducer from './reducers';

const persistConfig = {
  key: 'root',
  storage,
};

const persistedReducer = persistReducer(persistConfig, rootReducer);

export const store = createStore(persistedReducer);
export const persistor = persistStore(store);

// App.js
import React from 'react';
import { Provider } from 'react-redux';
import { PersistGate } from 'redux-persist/integration/react';
import { store, persistor } from './store';
import MainComponent from './MainComponent';

const App = () => (
  <Provider store={store}>
    <PersistGate loading={null} persistor={persistor}>
      <MainComponent />
    </PersistGate>
  </Provider>
);

export default App;

// reducers.js
const initialState = {
  data: [],
};

const rootReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'SET_DATA':
      return { ...state, data: action.payload };
    default:
      return state;
  }
};

export default rootReducer;

// MainComponent.js
import React, { useEffect } from 'react';
import { useDispatch, useSelector } from 'react-redux';
import { View, Text, Button } from 'react-native';

const fetchDataFromApi = async () => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts');
  return response.json();
};

const MainComponent = () => {
  const dispatch = useDispatch();
  const data = useSelector(state => state.data);

  const getData = async () => {
    const apiData = await fetchDataFromApi();
    dispatch({ type: 'SET_DATA', payload: apiData });
  };

  useEffect(() => {
    if (data.length === 0) {
      getData();
    }
  }, []);

  return (
    <View>
      <Button title="Refresh Data" onPress={getData} />
      {data.map(post => (
        <Text key={post.id}>{post.title}</Text>
      ))}
    </View>
  );
};

export default MainComponent;
```

#### Expected Output
When the app is loaded, Redux Persist will rehydrate the Redux state from AsyncStorage. The data fetched from the API will be displayed and cached in the Redux state, which will be saved in AsyncStorage. Pressing the "Refresh Data" button will re-fetch the data from the API and update the Redux state and the cache.

#### Resources to Practice Caching with Redux Persist
1. [Redux Persist Documentation](https://github.com/rt2zz/redux-persist)
2. [Persisting Redux State with Redux Persist](https://medium.com/@brucejee/persist-redux-store-with-redux-persist-1c55ba8702be)

### Example 3: Using Apollo Client with Cache for GraphQL
#### Explanation
Apollo Client is a popular library for managing GraphQL data. It provides a powerful caching mechanism that can cache the results of GraphQL queries, enabling efficient data retrieval and offline support. Apollo Client's cache is highly configurable and can be used to optimize the performance of a React Native app.

In this example, we will configure Apollo Client to cache the results of GraphQL queries. The app will query data from a GraphQL API and cache the results using Apollo Client's built-in cache. The cached data will be used for subsequent queries, reducing the need for repeated network requests.

#### Code
```javascript
// App.js
import React from 'react';
import { ApolloProvider, InMemoryCache, ApolloClient, gql, useQuery } from '@apollo/client';
import { View, Text, Button } from 'react-native';

const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app',
  cache: new InMemoryCache()
});

const GET_POKEMONS = gql`
  query {
    pokemons(first: 10) {
      id
      name
    }
  }
`;

const PokemonList = () => {
  const { loading, error, data, refetch } = useQuery(GET_POKEMONS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <Button title="Refresh Data" onPress={() => refetch()} />
      {data.pokemons.map(pokemon => (
        <Text key={pokemon.id}>{pokemon.name}</Text>
      ))}
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <PokemonList />
  </ApolloProvider>
);

export default App;
```

#### Expected Output
When the app is loaded, it will query data from the GraphQL API and cache the results using Apollo Client's cache. The list of Pokémon names will be displayed. Pressing the "Refresh Data" button will re-fetch the data from the API and update the cache. Subsequent queries will use the cached data, reducing the need for repeated network requests.

#### Resources to Practice Caching with Apollo Client
1. [Apollo Client Documentation](https://www.apollographql.com/docs/react/)
2. [GraphQL Caching with Apollo Client](https://www.apollographql.com/docs/react/caching/cache-configuration/)

---

### Task 4: Implement Caching with SWR (Stale-While-Revalidate)

#### Overview of SWR (Stale-While-Revalidate)
SWR, developed by Vercel, is a React hook library for data fetching that embraces the strategy of "stale-while-revalidate." This strategy allows a component to display stale (previously fetched) data while simultaneously revalidating the data in the background, ensuring that the user sees up-to-date information without experiencing a loading state. SWR is designed to handle caching, revalidation, focus tracking, and more in a very efficient way, making it an excellent tool for improving the user experience in React Native applications.

Using SWR, developers can simplify the process of data fetching and caching. It provides built-in support for automatic revalidation when the user refocuses the app, polling for updates at intervals, and error handling. This leads to a smoother and more responsive application by reducing the need for repeated API calls and minimizing the perceived loading times for users.

#### Resources to Learn SWR
1. [SWR Official Documentation](https://swr.vercel.app/docs)
2. [SWR: Data Fetching for React](https://blog.logrocket.com/swr-data-fetching-react/)

### Example 1: Basic Data Fetching with SWR
#### Explanation
In this example, we will use SWR to fetch data from a public API. The SWR hook will manage the caching and revalidation of the data. We will configure SWR to fetch data from the JSONPlaceholder API and display it in our React Native application.

The app will display a list of posts fetched from the API. When the data is fetched for the first time, it will be cached. Subsequent fetches will use the cached data while revalidating the data in the background to ensure it is up-to-date.

#### Code
```javascript
// App.js
import React from 'react';
import { View, Text, FlatList } from 'react-native';
import useSWR from 'swr';

const fetcher = url => fetch(url).then(res => res.json());

const App = () => {
  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher);

  if (error) return <Text>Error: {error.message}</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, SWR will fetch data from the JSONPlaceholder API and cache the result. The list of posts will be displayed. If the data is already cached, it will be shown immediately while SWR revalidates it in the background. Any updates will be reflected once the revalidation is complete.

#### Resources to Practice SWR
1. [Learn SWR](https://swr.vercel.app/learn)
2. [Using SWR with React Native](https://blog.logrocket.com/how-to-use-swr-react-native/)

### Example 2: Revalidation on Focus and Interval Polling with SWR
#### Explanation
In this example, we will configure SWR to revalidate data when the app window is refocused and to poll for updates at regular intervals. These features ensure that the data is always up-to-date without requiring user intervention.

The app will fetch a list of users from the JSONPlaceholder API. The SWR hook will be configured to revalidate the data when the app window is focused and to poll for updates every 5 seconds. This example demonstrates how to use SWR's built-in revalidation and polling mechanisms to keep data fresh.

#### Code
```javascript
// App.js
import React from 'react';
import { View, Text, FlatList } from 'react-native';
import useSWR from 'swr';

const fetcher = url => fetch(url).then(res => res.json());

const App = () => {
  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/users', fetcher, {
    refreshInterval: 5000, // Poll every 5 seconds
    revalidateOnFocus: true, // Revalidate when window is focused
  });

  if (error) return <Text>Error: {error.message}</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.name}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, SWR will fetch data from the JSONPlaceholder API and display the list of users. The data will be revalidated every 5 seconds and whenever the app window is refocused. This ensures that the displayed data is always fresh and up-to-date.

#### Resources to Practice Revalidation and Polling with SWR
1. [SWR Options](https://swr.vercel.app/docs/options)
2. [Handling Revalidation and Polling with SWR](https://dev.to/vercel/swr-react-hooks-for-data-fetching-3g0b)

### Example 3: Mutate Cache with SWR for Optimistic UI
#### Explanation
In this example, we will use the `mutate` function provided by SWR to update the cache manually and implement optimistic UI updates. This technique is useful for improving user experience by immediately reflecting changes in the UI without waiting for the server response.

The app will allow users to add a new post to the list. When a new post is added, the `mutate` function will update the cache optimistically to reflect the new post in the UI immediately. The post will be added to the server, and the cache will be updated again with the server response.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, FlatList, TextInput, Button } from 'react-native';
import useSWR, { mutate } from 'swr';

const fetcher = url => fetch(url).then(res => res.json());

const App = () => {
  const { data, error } = useSWR('https://jsonplaceholder.typicode.com/posts', fetcher);
  const [title, setTitle] = useState('');

  const addPost = async () => {
    const newPost = { title, id: Date.now() };

    mutate('https://jsonplaceholder.typicode.com/posts', [newPost, ...data], false);

    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newPost)
    });
    const result = await response.json();

    mutate('https://jsonplaceholder.typicode.com/posts');
  };

  if (error) return <Text>Error: {error.message}</Text>;
  if (!data) return <Text>Loading...</Text>;

  return (
    <View>
      <TextInput
        value={title}
        onChangeText={setTitle}
        placeholder="New Post Title"
      />
      <Button title="Add Post" onPress={addPost} />
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When a new post is added, it will immediately appear in the list due to the optimistic update with `mutate`. The post will be added to the server, and the SWR cache will be revalidated to reflect the server's response. This provides a seamless user experience by showing the changes instantly.

#### Resources to Practice Optimistic UI with SWR
1. [Mutate SWR Cache](https://swr.vercel.app/docs/mutation)
2. [Optimistic UI with SWR](https://kentcdodds.com/blog/implementing-optimistic-ui-updates)

---

### Task 5: Study Advanced Networking Techniques

#### Overview of Advanced Networking Techniques
Advanced networking techniques in mobile app development involve strategies and tools to handle complex networking scenarios efficiently. These include managing multiple concurrent requests, optimizing network performance, handling different types of requests and responses, and ensuring secure communication. Techniques such as HTTP/2, WebSockets, and GraphQL, along with tools like Axios, Fetch API, and networking libraries, play a crucial role in modern mobile applications.

Implementing advanced networking techniques helps improve the performance, reliability, and security of your applications. For instance, HTTP/2 allows multiple requests to be sent for a single connection, reducing latency. WebSockets enable real-time communication, making apps more interactive. Using GraphQL can optimize data fetching by allowing clients to request exactly the data they need. Mastering these techniques ensures that your React Native applications can handle complex networking requirements effectively.

#### Resources to Learn Advanced Networking Techniques
1. [HTTP/2 Explained](https://http2.github.io/)
2. [Real-Time WebSocket Examples with React](https://www.fullstacklabs.co/blog/websockets-with-react)

### Example 1: Implementing HTTP/2 for Multiple Concurrent Requests
#### Explanation
HTTP/2 is the second major version of the HTTP network protocol, introduced to improve the performance of web applications. It enables multiple requests for data to be sent simultaneously over a single TCP connection, significantly reducing latency and improving load times. This is particularly beneficial for mobile applications that need to fetch multiple resources concurrently.

In this example, we will use Axios to implement HTTP/2 in a React Native app. Axios is a popular HTTP client for JavaScript that supports HTTP/2. The app will fetch multiple resources concurrently using HTTP/2, demonstrating how to optimize network performance with this advanced networking technique.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList } from 'react-native';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [posts, comments] = await Promise.all([
          axios.get('https://jsonplaceholder.typicode.com/posts'),
          axios.get('https://jsonplaceholder.typicode.com/comments')
        ]);
        setData([...posts.data, ...comments.data]);
      } catch (err) {
        setError(err.message);
      }
    };
    fetchData();
  }, []);

  if (error) return <Text>Error: {error}</Text>;
  if (!data.length) return <Text>Loading...</Text>;

  return (
    <View>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.body || item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will fetch posts and comments concurrently from the JSONPlaceholder API using HTTP/2 via Axios. The fetched data will be displayed in a list. If there is an error during the fetch, it will be displayed to the user. This demonstrates improved network performance by handling multiple concurrent requests efficiently.

#### Resources to Practice HTTP/2 with Axios
1. [Axios Documentation](https://axios-http.com/docs/intro)
2. [Using HTTP/2 with Axios](https://www.beyondjava.net/using-http2-in-axios)

### Example 2: Real-Time Data with WebSockets
#### Explanation
WebSockets provide a full-duplex communication channel over a single TCP connection, allowing for real-time data exchange between the client and server. This is essential for applications that require instant updates, such as chat apps, live notifications, and real-time dashboards. WebSockets reduce latency by maintaining an open connection, enabling data to be sent and received instantly.

In this example, we will implement WebSockets in a React Native app using the `react-native-websocket` library. The app will connect to a WebSocket server to receive real-time updates, demonstrating how to use WebSockets for efficient real-time communication.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, FlatList } from 'react-native';
import WebSocket from 'react-native-websocket';

const App = () => {
  const [messages, setMessages] = useState([]);

  const ws = new WebSocket('wss://echo.websocket.org');

  ws.onmessage = (e) => {
    setMessages((prevMessages) => [...prevMessages, e.data]);
  };

  ws.onerror = (e) => {
    console.error(e.message);
  };

  const sendMessage = () => {
    ws.send('Hello WebSocket');
  };

  return (
    <View>
      <Button title="Send Message" onPress={sendMessage} />
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will establish a WebSocket connection to the echo server. Pressing the "Send Message" button will send a message to the server, which will echo it back, and the message will be displayed in a list. This demonstrates real-time data exchange using WebSockets.

#### Resources to Practice WebSockets
1. [WebSockets in React Native](https://levelup.gitconnected.com/using-websockets-in-react-native-9c10c6d9dc9e)
2. [React Native WebSocket Documentation](https://github.com/robwalkerco/react-native-websocket)

### Example 3: Optimizing Data Fetching with GraphQL
#### Explanation
GraphQL is a query language for APIs that allows clients to request exactly the data they need, minimizing over-fetching and under-fetching of data. This results in more efficient network usage and improved app performance. GraphQL also supports real-time updates through subscriptions, making it a powerful tool for modern mobile applications.

In this example, we will use Apollo Client to fetch data from a GraphQL API in a React Native app. The app will query a GraphQL server to fetch data and display it. This demonstrates how to use GraphQL for efficient and flexible data fetching.

#### Code
```javascript
// App.js
import React from 'react';
import { ApolloProvider, InMemoryCache, ApolloClient, gql, useQuery } from '@apollo/client';
import { View, Text, FlatList } from 'react-native';

const client = new ApolloClient({
  uri: 'https://graphql-pokemon2.vercel.app',
  cache: new InMemoryCache()
});

const GET_POKEMONS = gql`
  query {
    pokemons(first: 10) {
      id
      name
    }
  }
`;

const PokemonList = () => {
  const { loading, error, data } = useQuery(GET_POKEMONS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <FlatList
        data={data.pokemons}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.name}</Text>}
      />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <PokemonList />
  </ApolloProvider>
);

export default App;
```

#### Expected Output
When the app is loaded, it will fetch data from the GraphQL server using the Apollo Client and display a list of Pokémon names. This demonstrates how to use GraphQL for efficient data fetching, ensuring that only the required data is fetched and displayed.

#### Resources to Practice GraphQL with Apollo Client
1. [Apollo Client Documentation](https://www.apollographql.com/docs/react/)
2. [GraphQL with React Native](https://www.apollographql.com/blog/graphql/getting-started-with-graphql-and-react-native/)

---

### Task 6: Optimize Network Requests with HTTP/2

#### Overview of HTTP/2
HTTP/2 is the second major version of the HTTP network protocol, designed to improve the performance of web applications. It enables multiple requests to be sent for a single connection, reducing latency and improving load times. HTTP/2 includes features like header compression, multiplexing (allowing multiple requests and responses to be in flight simultaneously), and server push (sending resources to the client proactively).

Using HTTP/2 can significantly improve the performance of mobile applications by making network communication more efficient. It reduces the overhead associated with opening and closing multiple connections and enhances the speed and responsiveness of apps by allowing concurrent data streams over a single connection.

#### Resources to Learn HTTP/2
1. [HTTP/2 Explained](https://http2.github.io/)
2. [HTTP/2 in Node.js](https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/)

### Example 1: Using Axios with HTTP/2 for Concurrent Requests
#### Explanation
In this example, we will use Axios to implement HTTP/2 in a React Native app. Axios is a popular HTTP client for JavaScript that supports HTTP/2. The app will fetch multiple resources concurrently using HTTP/2, demonstrating how to optimize network performance with this advanced networking technique.

By utilizing Axios with HTTP/2, we can make multiple HTTP requests concurrently over a single connection, reducing the time needed to fetch data from multiple endpoints and improving the overall performance of the application.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList } from 'react-native';
import axios from 'axios';

const App = () => {
  const [data, setData] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [posts, comments] = await Promise.all([
          axios.get('https://jsonplaceholder.typicode.com/posts'),
          axios.get('https://jsonplaceholder.typicode.com/comments')
        ]);
        setData([...posts.data, ...comments.data]);
      } catch (err) {
        setError(err.message);
      }
    };
    fetchData();
  }, []);

  if (error) return <Text>Error: {error}</Text>;
  if (!data.length) return <Text>Loading...</Text>;

  return (
    <View>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.body || item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will fetch posts and comments concurrently from the JSONPlaceholder API using HTTP/2 via Axios. The fetched data will be displayed in a list. If there is an error during the fetch, it will be displayed to the user. This demonstrates improved network performance by handling multiple concurrent requests efficiently.

#### Resources to Practice HTTP/2 with Axios
1. [Axios Documentation](https://axios-http.com/docs/intro)
2. [Using HTTP/2 with Axios](https://www.beyondjava.net/using-http2-in-axios)

### Example 2: Implementing HTTP/2 Server Push with Node.js
#### Explanation
HTTP/2 server push allows a server to send resources to a client proactively, without the client having to request each resource explicitly. This can significantly reduce the time needed to load a webpage by preemptively pushing resources that the client will need.

In this example, we will create a simple Node.js server that uses HTTP/2 to push resources to the client. The server will push an HTML file along with associated CSS and JavaScript files to the client. This demonstrates how to implement server push to optimize resource loading in a web application.

#### Code
```javascript
// server.js
const http2 = require('http2');
const fs = require('fs');
const path = require('path');

const server = http2.createSecureServer({
  key: fs.readFileSync('server.key'),
  cert: fs.readFileSync('server.cert')
});

server.on('stream', (stream, headers) => {
  if (headers[':path'] === '/') {
    stream.pushStream({ ':path': '/style.css' }, (err, pushStream) => {
      if (err) throw err;
      pushStream.respondWithFile(path.join(__dirname, 'style.css'), { 'content-type': 'text/css' });
    });

    stream.pushStream({ ':path': '/script.js' }, (err, pushStream) => {
      if (err) throw err;
      pushStream.respondWithFile(path.join(__dirname, 'script.js'), { 'content-type': 'application/javascript' });
    });

    stream.respondWithFile(path.join(__dirname, 'index.html'), { 'content-type': 'text/html' });
  }
});

server.listen(8443, () => {
  console.log('Server is listening on https://localhost:8443');
});
```

#### Expected Output
When the server is started, it will listen for connections on port 8443. When a client connects and requests the root path, the server will push the `style.css` and `script.js` files to the client, along with the `index.html` file. This demonstrates how to use HTTP/2 server push to optimize resource loading in a web application.

#### Resources to Practice HTTP/2 Server Push
1. [HTTP/2 Server Push in Node.js](https://nodejs.org/en/docs/guides/anatomy-of-an-http-transaction/)
2. [HTTP/2 Push](https://developers.google.com/web/fundamentals/performance/http2#server_push)

### Example 3: Implementing HTTP/2 Multiplexing with Fetch API
#### Explanation
HTTP/2 multiplexing allows multiple requests and responses to be in flight simultaneously over a single TCP connection. This can greatly reduce the latency of network operations, as it avoids the overhead of establishing multiple connections and allows for more efficient use of network resources.

In this example, we will use the Fetch API to make multiple concurrent requests to different endpoints, leveraging HTTP/2 multiplexing to optimize network performance. The app will fetch data from multiple endpoints and display the results, demonstrating how to use HTTP/2 multiplexing for efficient network communication.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList } from 'react-native';

const App = () => {
  const [data, setData] = useState([]);
  const [error, setError] = useState(null);

  useEffect(() => {
    const fetchData = async () => {
      try {
        const [postsResponse, commentsResponse] = await Promise.all([
          fetch('https://jsonplaceholder.typicode.com/posts'),
          fetch('https://jsonplaceholder.typicode.com/comments')
        ]);

        const posts = await postsResponse.json();
        const comments = await commentsResponse.json();

        setData([...posts, ...comments]);
      } catch (err) {
        setError(err.message);
      }
    };

    fetchData();
  }, []);

  if (error) return <Text>Error: {error}</Text>;
  if (!data.length) return <Text>Loading...</Text>;

  return (
    <View>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.body || item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will fetch posts and comments concurrently from the JSONPlaceholder API using the Fetch API. The fetched data will be displayed in a list. If there is an error during the fetch, it will be displayed to the user. This demonstrates improved network performance by handling multiple concurrent requests efficiently using HTTP/2 multiplexing.

#### Resources to Practice HTTP/2 Multiplexing with Fetch API
1. [Fetch API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)
2. [HTTP/2 Multiplexing](https://developers.google.com/web/fundamentals/performance/http2#request_multiplexing)

---

### Task 7: Study SSR and SSG in Next.js

#### Overview of SSR (Server-Side Rendering) and SSG (Static Site Generation) in Next.js
Server-Side Rendering (SSR) and Static Site Generation (SSG) are two methods of pre-rendering that can significantly improve the performance and SEO of web applications. SSR involves rendering the HTML on the server at request time and sending it to the client. This can result in faster initial load times and better SEO, as the content is ready to be indexed by search engines. SSG, on the other hand, involves generating the HTML at build time. The pre-rendered HTML is then reused for each request, which can lead to extremely fast load times and reduced server load.

Next.js, a popular React framework, supports both SSR and SSG out of the box. By using these pre-rendering techniques, developers can build fast and highly optimized web applications. SSR is ideal for dynamic content that changes frequently, while SSG is best suited for static content that doesn’t change often.

#### Resources to Learn SSR and SSG in Next.js
1. [Next.js Official Documentation on SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Next.js Official Documentation on SSG](https://nextjs.org/docs/basic-features/pages#static-generation)

### Example 1: Implementing SSR in Next.js
#### Explanation
In this example, we will implement Server-Side Rendering (SSR) in a Next.js application. We will create a simple page that fetches data from an API and renders it on the server. The data will be fetched at request time, and the HTML will be pre-rendered on the server and sent to the client.

This example demonstrates how to use the `getServerSideProps` function in Next.js to fetch data and render it on the server. SSR is particularly useful for pages that require dynamic data that changes frequently.

#### Code
```javascript
// pages/index.js
import React from 'react';

const Home = ({ data }) => {
  return (
    <div>
      <h1>Server-Side Rendering (SSR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getServerSideProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const data = await res.json();

  return {
    props: {
      data,
    },
  };
};

export default Home;
```

#### Expected Output
When the page is loaded, the server will fetch the data from the API and render the HTML on the server. The pre-rendered HTML will be sent to the client, displaying the list of posts. The content will be ready for indexing by search engines, and the initial load time will be faster.

#### Resources to Practice SSR in Next.js
1. [Server-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Building SSR Apps with Next.js](https://www.smashingmagazine.com/2020/03/complete-guide-build-deploy-nextjs-app/)

### Example 2: Implementing SSG in Next.js
#### Explanation
In this example, we will implement Static Site Generation (SSG) in a Next.js application. We will create a simple page that fetches data from an API and generates the HTML at build time. The pre-rendered HTML will be reused for each request, resulting in very fast load times.

This example demonstrates how to use the `getStaticProps` function in Next.js to fetch data and generate static HTML pages. SSG is ideal for pages with static content that doesn’t change frequently.

#### Code
```javascript
// pages/index.js
import React from 'react';

const Home = ({ data }) => {
  return (
    <div>
      <h1>Static Site Generation (SSG)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const data = await res.json();

  return {
    props: {
      data,
    },
  };
};

export default Home;
```

#### Expected Output
When the page is built, the server will fetch the data from the API and generate the HTML. The pre-rendered HTML will be served for each request, resulting in very fast load times and reduced server load. This approach is highly efficient for static content.

#### Resources to Practice SSG in Next.js
1. [Static Site Generation in Next.js](https://nextjs.org/docs/basic-features/pages#static-generation)
2. [Next.js Static Site Generation Guide](https://www.netlify.com/blog/2020/11/30/how-to-use-next.js-static-site-generation/)

### Example 3: Combining SSR and SSG with Dynamic Routes
#### Explanation
In this example, we will combine SSR and SSG in a Next.js application with dynamic routes. We will create a page with dynamic routes that fetches data on the server and generates static pages at build time. This demonstrates how to handle dynamic content efficiently.

We will use the `getStaticPaths` function to generate paths for dynamic routes and `getStaticProps` to fetch data and generate static HTML. For pages that need to be updated frequently, we will use `getServerSideProps` to fetch data on the server.

#### Code
```javascript
// pages/posts/[id].js
import React from 'react';

const Post = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export const getStaticPaths = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map(post => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
};

export const getStaticProps = async ({ params }) => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
};

export default Post;
```

#### Expected Output
When the page is built, Next.js will fetch the list of posts and generate paths for each post using `getStaticPaths`. For each path, it will fetch the post data and generate static HTML using `getStaticProps`. The pre-rendered HTML will be served for each request, resulting in fast load times. This approach is efficient for static content with dynamic routes.

#### Resources to Practice Combining SSR and SSG in Next.js
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [Combining SSR and SSG in Next.js](https://nextjs.org/docs/advanced-features/preview-mode)

---

### Task 8: Implement SSR and SSG in a Next.js Project

#### Overview of SSR (Server-Side Rendering) and SSG (Static Site Generation) in Next.js
Server-Side Rendering (SSR) and Static Site Generation (SSG) are two powerful features in Next.js that help in pre-rendering pages to improve performance and SEO. SSR involves rendering the HTML on the server at request time and sending it to the client. This ensures that the content is ready for search engines to index and provides faster initial load times for users. SSG, on the other hand, involves generating the HTML at build time, which can be reused for each request. This leads to very fast load times and reduces the server load since the content is served statically.

Next.js provides built-in support for both SSR and SSG. SSR is achieved using the `getServerSideProps` function, which allows you to fetch data on each request and pre-render the page on the server. SSG is implemented using the `getStaticProps` and `getStaticPaths` functions, which fetch data at build time and generate static HTML for each path. These features make Next.js a powerful framework for building high-performance web applications.

#### Resources to Learn SSR and SSG in Next.js
1. [Next.js Official Documentation on SSR](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Next.js Official Documentation on SSG](https://nextjs.org/docs/basic-features/pages#static-generation)

### Example 1: Implementing SSR in Next.js
#### Explanation
Server-Side Rendering (SSR) is a technique where the HTML for a web page is generated on the server in response to a client request. This pre-rendered HTML is then sent to the client, along with the necessary JavaScript to make the page interactive. SSR ensures that the content is available immediately when the page loads, which improves the initial load time and SEO.

In this example, we will create a simple Next.js page that fetches data from an API and renders it on the server using `getServerSideProps`. This function runs on the server side at request time, fetches the necessary data, and passes it as props to the component. The HTML is then pre-rendered on the server and sent to the client.

#### Code
```javascript
// pages/index.js
import React from 'react';

const Home = ({ data }) => {
  return (
    <div>
      <h1>Server-Side Rendering (SSR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getServerSideProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const data = await res.json();

  return {
    props: {
      data,
    },
  };
};

export default Home;
```

#### Expected Output
When the page is loaded, the server will fetch the data from the API, pre-render the HTML with the data, and send it to the client. The list of posts will be displayed immediately upon page load, providing a fast and seamless user experience. This demonstrates how SSR can be used to improve the performance and SEO of a web application.

#### Resources to Practice SSR in Next.js
1. [Server-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Building SSR Apps with Next.js](https://www.smashingmagazine.com/2020/03/complete-guide-build-deploy-nextjs-app/)

### Example 2: Implementing SSG in Next.js
#### Explanation
Static Site Generation (SSG) is a technique where the HTML for a web page is generated at build time. The generated HTML is then served to the client upon request. SSG provides very fast load times since the HTML is pre-generated and served statically. It is particularly useful for pages with content that does not change frequently.

In this example, we will create a Next.js page that fetches data from an API and generates static HTML at build time using `getStaticProps`. This function runs at build time, fetches the necessary data, and passes it as props to the component. The HTML is then pre-rendered and stored as a static file.

#### Code
```javascript
// pages/index.js
import React from 'react';

const Home = ({ data }) => {
  return (
    <div>
      <h1>Static Site Generation (SSG)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const data = await res.json();

  return {
    props: {
      data,
    },
  };
};

export default Home;
```

#### Expected Output
When the page is built, the server will fetch the data from the API and generate the HTML. The pre-rendered HTML will be served for each request, resulting in very fast load times and reduced server load. This approach is highly efficient for static content.

#### Resources to Practice SSG in Next.js
1. [Static Site Generation in Next.js](https://nextjs.org/docs/basic-features/pages#static-generation)
2. [Next.js Static Site Generation Guide](https://www.netlify.com/blog/2020/11/30/how-to-use-next.js-static-site-generation/)

### Example 3: Combining SSR and SSG with Dynamic Routes
#### Explanation
Combining SSR and SSG allows you to handle different types of content in a single application efficiently. Dynamic routes in Next.js enable you to create pages with dynamic parameters, such as blog posts or product pages. By using `getStaticPaths` and `getStaticProps`, you can generate static pages for each dynamic route at build time. Additionally, you can use `getServerSideProps` for pages that need to be updated frequently.

In this example, we will create a Next.js application with dynamic routes for individual posts. We will use `getStaticPaths` to generate paths for each post and `getStaticProps` to fetch data and generate static HTML. For pages that require frequent updates, we can use `getServerSideProps`.

#### Code
```javascript
// pages/posts/[id].js
import React from 'react';

const Post = ({ post }) => {
  return (
    <div>
      <h1>{post.title}</h1>
      <p>{post.body}</p>
    </div>
  );
};

export const getStaticPaths = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map(post => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
};

export const getStaticProps = async ({ params }) => {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
};

export default Post;
```

#### Expected Output
When the application is built, Next.js will fetch the list of posts and generate paths for each post using `getStaticPaths`. For each path, it will fetch the post data and generate static HTML using `getStaticProps`. The pre-rendered HTML will be served for each request, resulting in fast load times. This approach efficiently handles static content with dynamic routes.

#### Resources to Practice Combining SSR and SSG in Next.js
1. [Dynamic Routes in Next.js](https://nextjs.org/docs/routing/dynamic-routes)
2. [Combining SSR and SSG in Next.js](https://nextjs.org/docs/advanced-features/preview-mode)

---

### Task 9: Study Hybrid Rendering with Next.js

#### Overview of Hybrid Rendering in Next.js
Hybrid rendering in Next.js refers to the ability to use multiple rendering strategies within the same application. Next.js allows you to mix and match Server-Side Rendering (SSR), Static Site Generation (SSG), and Client-Side Rendering (CSR) based on the requirements of each page or component. This flexibility enables developers to optimize performance, SEO, and user experience on a per-page basis.

By leveraging hybrid rendering, you can use SSR for dynamic content that needs to be updated frequently, SSG for static content that doesn’t change often, and CSR for interactive components that require user input. This approach ensures that your application is highly performant, scalable, and capable of handling diverse use cases.

#### Resources to Learn Hybrid Rendering in Next.js
1. [Next.js Hybrid Rendering](https://nextjs.org/docs/routing/dynamic-routes#hybrid-pages)
2. [Hybrid Rendering Strategies with Next.js](https://vercel.com/guides/nextjs-hybrid-rendering)

### Example 1: Combining SSR and SSG in a Single Page
#### Explanation
In this example, we will create a Next.js page that uses both SSR and SSG. The page will fetch dynamic content using SSR and static content using SSG. This demonstrates how to leverage hybrid rendering to optimize performance and SEO.

We will use `getServerSideProps` to fetch dynamic data at request time and `getStaticProps` to fetch static data at build time. The page will render both types of content, ensuring that dynamic data is always up-to-date while static data is pre-rendered for faster load times.

#### Code
```javascript
// pages/hybrid.js
import React from 'react';

const Hybrid = ({ dynamicData, staticData }) => {
  return (
    <div>
      <h1>Hybrid Rendering</h1>
      <h2>Dynamic Data (SSR)</h2>
      <ul>
        {dynamicData.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
      <h2>Static Data (SSG)</h2>
      <ul>
        {staticData.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getServerSideProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const dynamicData = await res.json();

  return {
    props: {
      dynamicData,
    },
  };
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_start=5&_limit=5');
  const staticData = await res.json();

  return {
    props: {
      staticData,
    },
  };
};

export default Hybrid;
```

#### Expected Output
When the page is loaded, dynamic data will be fetched at request time using SSR, and static data will be fetched at build time using SSG. The page will render both sets of data, demonstrating how to combine SSR and SSG in a single page. This approach ensures that dynamic content is always up-to-date while static content is served quickly.

#### Resources to Practice Combining SSR and SSG in Next.js
1. [Combining SSR and SSG in Next.js](https://nextjs.org/docs/basic-features/pages#static-generation-with-data)
2. [Hybrid Rendering with Next.js](https://vercel.com/guides/nextjs-hybrid-rendering)

### Example 2: Using CSR for Interactive Components in SSR/SSG Pages
#### Explanation
In this example, we will use Client-Side Rendering (CSR) for interactive components within SSR/SSG pages. CSR allows us to render dynamic and interactive content on the client side, enhancing the user experience.

We will create a page that uses SSR to fetch initial data and CSR to handle user interactions, such as form submissions or dynamic updates. This demonstrates how to integrate CSR into SSR/SSG pages to create rich and interactive web applications.

#### Code
```javascript
// pages/csr.js
import React, { useState } from 'react';

const CSRPage = ({ initialData }) => {
  const [data, setData] = useState(initialData);
  const [newItem, setNewItem] = useState('');

  const addItem = () => {
    const updatedData = [...data, { id: data.length + 1, title: newItem }];
    setData(updatedData);
    setNewItem('');
  };

  return (
    <div>
      <h1>Client-Side Rendering (CSR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
      <input
        type="text"
        value={newItem}
        onChange={(e) => setNewItem(e.target.value)}
      />
      <button onClick={addItem}>Add Item</button>
    </div>
  );
};

export const getServerSideProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const initialData = await res.json();

  return {
    props: {
      initialData,
    },
  };
};

export default CSRPage;
```

#### Expected Output
When the page is loaded, initial data will be fetched using SSR. The page will render the data and provide an input field for adding new items. The new items will be handled using CSR, allowing the user to interact with the page dynamically. This demonstrates how to combine SSR and CSR for a rich user experience.

#### Resources to Practice Using CSR in SSR/SSG Pages
1. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#client-side-navigation)
2. [Interactive Components with CSR in Next.js](https://vercel.com/guides/nextjs-interactive-components)

### Example 3: Implementing Incremental Static Regeneration (ISR)
#### Explanation
Incremental Static Regeneration (ISR) is a feature in Next.js that allows you to update static content after the site has been built. ISR enables you to update static pages without needing to rebuild the entire site, making it possible to serve up-to-date content with the performance benefits of static generation.

In this example, we will create a Next.js page that uses ISR to regenerate static pages at a specified interval. We will use `getStaticProps` with the `revalidate` property to define how often the page should be revalidated and regenerated. This demonstrates how to use ISR to keep static content up-to-date.

#### Code
```javascript
// pages/isr.js
import React from 'react';

const ISRPage = ({ data }) => {
  return (
    <div>
      <h1>Incremental Static Regeneration (ISR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const data = await res.json();

  return {
    props: {
      data,
    },
    revalidate: 10, // Revalidate every 10 seconds
  };
};

export default ISRPage;
```

#### Expected Output
When the page is built, Next.js will fetch the data and generate the static HTML. The static page will be served for each request and revalidated every 10 seconds. If the data changes, the page will be regenerated with the updated content. This demonstrates how to use ISR to keep static content up-to-date.

#### Resources to Practice ISR in Next.js
1. [Incremental Static Regeneration in Next.js](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [ISR Guide in Next.js](https://vercel.com/guides/nextjs-incremental-static-regeneration)

---

### Task 10: Implement Hybrid Rendering with Next.js for Mobile

#### Overview of Hybrid Rendering with Next.js for Mobile
Hybrid rendering in Next.js involves using a combination of Server-Side Rendering (SSR), Static Site Generation (SSG), and Client-Side Rendering (CSR) to optimize the performance and user experience of web applications. When applied to mobile web applications, hybrid rendering can significantly enhance load times, SEO, and interactivity. By pre-rendering content on the server (SSR) or at build time (SSG), and handling dynamic interactions on the client (CSR), developers can create fast and responsive mobile experiences.

Implementing hybrid rendering for mobile applications with Next.js allows you to leverage the benefits of each rendering strategy. SSR ensures that content is delivered quickly and is SEO-friendly, SSG provides pre-rendered static pages for blazing fast load times, and CSR allows for dynamic and interactive components that enhance user engagement. This approach ensures that your mobile web applications are optimized for performance, scalability, and user satisfaction.

#### Resources to Learn Hybrid Rendering in Next.js for Mobile
1. [Next.js Documentation on Hybrid Rendering](https://nextjs.org/docs/routing/dynamic-routes#hybrid-pages)
2. [Hybrid Rendering Strategies with Next.js](https://vercel.com/guides/nextjs-hybrid-rendering)

### Example 1: Implementing Hybrid Rendering with SSR and CSR for Mobile
#### Explanation
In this example, we will create a Next.js mobile page that uses Server-Side Rendering (SSR) to fetch initial data and Client-Side Rendering (CSR) to handle user interactions. This demonstrates how to use SSR for delivering pre-rendered content quickly and CSR for making the page interactive and responsive on mobile devices.

We will use the `getServerSideProps` function to fetch data on the server and render the HTML at request time. Additionally, we will add client-side interactivity to allow users to update the content dynamically. This combination ensures fast initial load times and a smooth user experience on mobile.

#### Code
```javascript
// pages/mobile-ssr-csr.js
import React, { useState } from 'react';

const MobileSSRCSR = ({ initialData }) => {
  const [data, setData] = useState(initialData);
  const [newItem, setNewItem] = useState('');

  const addItem = () => {
    const updatedData = [...data, { id: data.length + 1, title: newItem }];
    setData(updatedData);
    setNewItem('');
  };

  return (
    <div style={{ padding: '10px' }}>
      <h1>Hybrid Rendering (SSR + CSR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
      <input
        type="text"
        value={newItem}
        onChange={(e) => setNewItem(e.target.value)}
        placeholder="Add new item"
      />
      <button onClick={addItem}>Add Item</button>
    </div>
  );
};

export const getServerSideProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const initialData = await res.json();

  return {
    props: {
      initialData,
    },
  };
};

export default MobileSSRCSR;
```

#### Expected Output
When the page is loaded, the server will fetch the initial data and render the HTML, which will be sent to the client. The list of items will be displayed immediately upon page load. Users can add new items dynamically, which will be handled using CSR. This demonstrates how to combine SSR and CSR for a fast and interactive mobile web application.

#### Resources to Practice SSR and CSR in Next.js for Mobile
1. [Server-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#client-side-navigation)

### Example 2: Implementing Hybrid Rendering with SSG and CSR for Mobile
#### Explanation
In this example, we will create a Next.js mobile page that uses Static Site Generation (SSG) to pre-render static content at build time and Client-Side Rendering (CSR) to handle user interactions. This demonstrates how to use SSG for delivering static content quickly and CSR for making the page interactive and responsive on mobile devices.

We will use the `getStaticProps` function to fetch data at build time and generate static HTML. Additionally, we will add client-side interactivity to allow users to update the content dynamically. This combination ensures fast load times and a smooth user experience on mobile.

#### Code
```javascript
// pages/mobile-ssg-csr.js
import React, { useState } from 'react';

const MobileSSGCSR = ({ initialData }) => {
  const [data, setData] = useState(initialData);
  const [newItem, setNewItem] = useState('');

  const addItem = () => {
    const updatedData = [...data, { id: data.length + 1, title: newItem }];
    setData(updatedData);
    setNewItem('');
  };

  return (
    <div style={{ padding: '10px' }}>
      <h1>Hybrid Rendering (SSG + CSR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
      <input
        type="text"
        value={newItem}
        onChange={(e) => setNewItem(e.target.value)}
        placeholder="Add new item"
      />
      <button onClick={addItem}>Add Item</button>
    </div>
  );
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const initialData = await res.json();

  return {
    props: {
      initialData,
    },
  };
};

export default MobileSSGCSR;
```

#### Expected Output
When the page is built, Next.js will fetch the initial data and generate the static HTML, which will be served to the client. The list of items will be displayed immediately upon page load. Users can add new items dynamically, which will be handled using CSR. This demonstrates how to combine SSG and CSR for a fast and interactive mobile web application.

#### Resources to Practice SSG and CSR in Next.js for Mobile
1. [Static Site Generation in Next.js](https://nextjs.org/docs/basic-features/pages#static-generation)
2. [Client-Side Rendering in Next.js](https://nextjs.org/docs/basic-features/pages#client-side-navigation)

### Example 3: Implementing Incremental Static Regeneration (ISR) for Mobile
#### Explanation
Incremental Static Regeneration (ISR) allows you to update static content after the site has been built. This enables you to serve up-to-date content with the performance benefits of static generation. ISR is particularly useful for mobile applications where content needs to be updated frequently but served quickly.

In this example, we will create a Next.js mobile page that uses ISR to regenerate static pages at a specified interval. We will use `getStaticProps` with the `revalidate` property to define how often the page should be revalidated and regenerated. This demonstrates how to use ISR to keep static content up-to-date.

#### Code
```javascript
// pages/mobile-isr.js
import React from 'react';

const MobileISR = ({ data }) => {
  return (
    <div style={{ padding: '10px' }}>
      <h1>Incremental Static Regeneration (ISR)</h1>
      <ul>
        {data.map(item => (
          <li key={item.id}>{item.title}</li>
        ))}
      </ul>
    </div>
  );
};

export const getStaticProps = async () => {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
  const data = await res.json();

  return {
    props: {
      data,
    },
    revalidate: 10, // Revalidate every 10 seconds
  };
};

export default MobileISR;
```

#### Expected Output
When the page is built, Next.js will fetch the data and generate the static HTML. The static page will be served for each request and revalidated every 10 seconds. If the data changes, the page will be regenerated with the updated content. This demonstrates how to use ISR to keep static content up-to-date.

#### Resources to Practice ISR in Next.js for Mobile
1. [Incremental Static Regeneration in Next.js](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [ISR Guide in Next.js](https://vercel.com/guides/nextjs-incremental-static-regeneration)

---

### Task 11: Study Data Synchronization Techniques

#### Overview of Data Synchronization Techniques
Data synchronization in mobile applications ensures that data remains consistent across multiple devices and platforms. It is a critical feature for applications that require real-time updates, offline access, and seamless data consistency. Techniques for data synchronization include real-time syncing using WebSockets, periodic syncing using background tasks, and conflict resolution strategies to handle simultaneous data updates from different sources.

Real-time data synchronization is typically implemented using WebSockets or similar technologies that provide bi-directional communication between the client and server. This allows instant updates to be pushed to all connected clients. Periodic synchronization involves fetching and updating data at regular intervals, which can be scheduled using background tasks. Conflict resolution strategies are essential when multiple devices or users update the same data concurrently, ensuring that data integrity is maintained.

#### Resources to Learn Data Synchronization Techniques
1. [Understanding Data Synchronization](https://developer.android.com/training/sync-adapters)
2. [Real-Time Data Sync with WebSockets](https://socket.io/docs/v4/)

### Example 1: Real-Time Data Synchronization with WebSockets
#### Explanation
Real-time data synchronization ensures that all clients receive updates as soon as data changes. WebSockets are a popular choice for implementing real-time synchronization because they allow for continuous, bi-directional communication between the client and server. This is particularly useful for applications like chat apps, live notifications, and collaborative tools.

In this example, we will create a simple React Native application that uses WebSockets to synchronize data in real-time. The app will connect to a WebSocket server and update the UI whenever new data is received. This demonstrates how to implement real-time data synchronization in a mobile application.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, TextInput, FlatList } from 'react-native';
import WebSocket from 'ws';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [input, setInput] = useState('');
  const ws = new WebSocket('ws://echo.websocket.org');

  useEffect(() => {
    ws.onmessage = (e) => {
      setMessages((prevMessages) => [...prevMessages, e.data]);
    };

    return () => {
      ws.close();
    };
  }, []);

  const sendMessage = () => {
    ws.send(input);
    setInput('');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Real-Time Data Synchronization with WebSockets</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text>{item}</Text>}
      />
      <TextInput
        value={input}
        onChangeText={setInput}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will connect to the WebSocket server. Users can type messages in the input field and send them. The messages will be broadcast to all connected clients in real-time, and the UI will update to display the new messages instantly. This demonstrates how to implement real-time data synchronization using WebSockets in a React Native application.

#### Resources to Practice Real-Time Data Synchronization
1. [WebSockets in React Native](https://levelup.gitconnected.com/using-websockets-in-react-native-9c10c6d9dc9e)
2. [Building Real-Time Applications with WebSockets](https://blog.logrocket.com/websockets-in-react/)

### Example 2: Periodic Data Synchronization Using Background Tasks
#### Explanation
Periodic data synchronization involves fetching and updating data at regular intervals. This approach is useful for applications that need to keep data up-to-date but do not require real-time updates. Background tasks are used to perform these periodic syncs without interrupting the user experience.

In this example, we will use React Native's `BackgroundFetch` library to implement periodic data synchronization. The app will fetch data from an API at regular intervals and update the UI. This demonstrates how to use background tasks to keep data synchronized in a mobile application.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList } from 'react-native';
import BackgroundFetch from 'react-native-background-fetch';

const App = () => {
  const [data, setData] = useState([]);

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
      const result = await response.json();
      setData(result);
    };

    fetchData();

    const onFetch = async () => {
      await fetchData();
      BackgroundFetch.finish(BackgroundFetch.FETCH_RESULT_NEW_DATA);
    };

    BackgroundFetch.configure(
      { minimumFetchInterval: 15 }, // Fetch every 15 minutes
      onFetch,
      (error) => console.log('Background fetch failed to start:', error)
    );

    return () => {
      BackgroundFetch.stop();
    };
  }, []);

  return (
    <View style={{ padding: 20 }}>
      <Text>Periodic Data Synchronization with Background Tasks</Text>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will fetch the initial data from the API and display it in a list. The app will continue to fetch and update the data every 15 minutes in the background. This demonstrates how to use background tasks for periodic data synchronization in a React Native application.

#### Resources to Practice Periodic Data Synchronization
1. [Background Fetch in React Native](https://github.com/transistorsoft/react-native-background-fetch)
2. [Scheduling Background Tasks in React Native](https://heartbeat.fritz.ai/scheduling-background-tasks-in-react-native-2021-589cc5c6b9c1)

### Example 3: Conflict Resolution in Data Synchronization
#### Explanation
Conflict resolution is essential when multiple devices or users update the same data concurrently. It ensures that data remains consistent and prevents conflicts from causing data corruption. Common strategies for conflict resolution include the Last Write Wins (LWW) approach, versioning, and merging changes.

In this example, we will implement a simple conflict resolution strategy using the Last Write Wins (LWW) approach. The app will fetch data from an API and allow users to update it. If a conflict occurs, the latest update will overwrite the previous one. This demonstrates how to handle data conflicts in a mobile application.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, Button, TextInput, FlatList } from 'react-native';

const App = () => {
  const [data, setData] = useState([]);
  const [input, setInput] = useState('');

  useEffect(() => {
    const fetchData = async () => {
      const response = await fetch('https://jsonplaceholder.typicode.com/posts?_limit=5');
      const result = await response.json();
      setData(result);
    };

    fetchData();
  }, []);

  const updateData = async () => {
    const newData = { id: data.length + 1, title: input };
    const response = await fetch('https://jsonplaceholder.typicode.com/posts', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(newData),
    });

    const result = await response.json();
    setData((prevData) => [...prevData, result]);
    setInput('');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Conflict Resolution in Data Synchronization</Text>
      <FlatList
        data={data}
        keyExtractor={(item) => item.id.toString()}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
      <TextInput
        value={input}
        onChangeText={setInput}
        placeholder="Add new item"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Add Item" onPress={updateData} />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will fetch the initial data from the API and display it in a list. Users can add new items, and the app will handle conflicts by using the latest update to overwrite previous ones. This demonstrates how to implement conflict resolution in data synchronization using the Last Write Wins (LWW) approach.

#### Resources to Practice Conflict Resolution in Data Synchronization
1. [Handling Data Conflicts in Mobile Applications](https://www.couchbase.com/blog/handling-conflicts-couchbase-mobile/)
2. [Conflict Resolution Strategies](https://firebase.google.com/docs/firestore/manage-data/enable-offline#handle_concurrent_updates)

---

### Task 12: Implement Real-Time Data Sync with Firestore

#### Overview of Real-Time Data Sync with Firestore
Firestore is a flexible, scalable database for mobile, web, and server development from Firebase and Google Cloud Platform. One of Firestore's standout features is its real-time synchronization capabilities, which allow developers to build applications that stay up-to-date with changes to the data without needing to refresh or poll for updates. Firestore handles real-time data synchronization efficiently and can handle complex queries and updates.

Real-time data sync is crucial for applications where users need to see live updates without manual refreshes. Examples include chat applications, collaborative tools, and live dashboards. Firestore's real-time capabilities make it an excellent choice for such use cases, as it provides built-in support for listening to data changes and updating the UI accordingly.

#### Resources to Learn Real-Time Data Sync with Firestore
1. [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)
2. [Building a Real-Time Chat App with Firebase Firestore](https://www.freecodecamp.org/news/building-a-real-time-chat-app-with-react-and-firebase/)

### Example 1: Setting Up Firestore in a React Native App
#### Explanation
To use Firestore in a React Native application, you first need to set up Firebase in your project. This involves creating a Firebase project, adding your app to the project, and configuring your React Native app with Firebase credentials. Once Firebase is set up, you can integrate Firestore and start using its real-time database features.

In this example, we will set up Firebase and Firestore in a React Native application. We will configure Firebase, initialize Firestore, and ensure that the app is ready to use Firestore for real-time data synchronization.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button, TextInput } from 'react-native';
import firebase from 'firebase/app';
import 'firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

const db = firebase.firestore();

const App = () => {
  const [data, setData] = useState([]);
  const [newItem, setNewItem] = useState('');

  useEffect(() => {
    const unsubscribe = db.collection('items').onSnapshot(snapshot => {
      const items = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      }));
      setData(items);
    });

    return () => unsubscribe();
  }, []);

  const addItem = async () => {
    await db.collection('items').add({
      title: newItem,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    });
    setNewItem('');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Real-Time Data Sync with Firestore</Text>
      <FlatList
        data={data}
        keyExtractor={item => item.id}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
      <TextInput
        value={newItem}
        onChangeText={setNewItem}
        placeholder="Add new item"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Add Item" onPress={addItem} />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will connect to Firestore and listen for real-time updates to the "items" collection. Users can add new items, and these will be instantly synchronized and displayed in the list. This demonstrates the basic setup and real-time data synchronization capabilities of Firestore in a React Native application.

#### Resources to Practice Setting Up Firestore
1. [Firebase Firestore Getting Started Guide](https://firebase.google.com/docs/firestore/quickstart)
2. [Setting Up Firestore in React Native](https://rnfirebase.io/firestore/usage)

### Example 2: Real-Time Chat Application with Firestore
#### Explanation
A real-time chat application is a common use case for Firestore's real-time synchronization capabilities. In this example, we will build a simple chat app where messages are stored in Firestore and synchronized across all connected clients in real-time. Each message will include the sender's name and the message text.

We will use Firestore's real-time listeners to update the chat UI whenever new messages are added. This ensures that all users see the latest messages instantly, providing a seamless chat experience.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button, TextInput } from 'react-native';
import firebase from 'firebase/app';
import 'firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

const db = firebase.firestore();

const App = () => {
  const [messages, setMessages] = useState([]);
  const [newMessage, setNewMessage] = useState('');
  const [userName, setUserName] = useState('');

  useEffect(() => {
    const unsubscribe = db.collection('messages').orderBy('createdAt', 'asc').onSnapshot(snapshot => {
      const msgs = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      }));
      setMessages(msgs);
    });

    return () => unsubscribe();
  }, []);

  const sendMessage = async () => {
    if (newMessage.trim() && userName.trim()) {
      await db.collection('messages').add({
        text: newMessage,
        user: userName,
        createdAt: firebase.firestore.FieldValue.serverTimestamp(),
      });
      setNewMessage('');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Real-Time Chat with Firestore</Text>
      <FlatList
        data={messages}
        keyExtractor={item => item.id}
        renderItem={({ item }) => (
          <View>
            <Text>{item.user}: {item.text}</Text>
          </View>
        )}
      />
      <TextInput
        value={userName}
        onChangeText={setUserName}
        placeholder="Your name"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        value={newMessage}
        onChangeText={setNewMessage}
        placeholder="Type a message"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will connect to Firestore and listen for real-time updates to the "messages" collection. Users can send messages, and these will be instantly synchronized and displayed in the chat. This demonstrates how to build a real-time chat application using Firestore in a React Native application.

#### Resources to Practice Building a Real-Time Chat App with Firestore
1. [Building a Chat App with Firebase Firestore](https://www.freecodecamp.org/news/building-a-real-time-chat-app-with-react-and-firebase/)
2. [Firebase Firestore for Chat Applications](https://blog.logrocket.com/building-a-chat-app-with-react-native-and-firebase/)

### Example 3: Real-Time Data Sync with Firestore and Offline Support
#### Explanation
One of the powerful features of Firestore is its offline support. Firestore caches data locally, allowing your app to read, write, listen to, and query data even when the device is offline. When the device regains connectivity, Firestore synchronizes any local changes with the server, ensuring data consistency.

In this example, we will enhance our real-time data sync app to support offline mode. We will configure Firestore to cache data locally and handle offline writes. This ensures that users can continue to interact with the app even when they are offline, and their changes will be synchronized once they reconnect.

#### Code
```javascript
// App.js
import React, { useEffect, useState } from 'react';
import { View, Text, FlatList, Button, TextInput } from 'react-native';
import firebase from 'firebase/app';
import 'firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

const db = firebase.firestore();
db.enablePersistence()
  .catch((err) => {
    if (err.code === 'failed-precondition') {
      console.log('Multiple tabs open, persistence can only be enabled in one tab at a time.');
    } else if (err.code === 'unimplemented') {
      console.log('The current browser does not support all of the features required to enable persistence.');
    }
  });

const App = () => {


  const [data, setData] = useState([]);
  const [newItem, setNewItem] = useState('');

  useEffect(() => {
    const unsubscribe = db.collection('items').onSnapshot(snapshot => {
      const items = snapshot.docs.map(doc => ({
        id: doc.id,
        ...doc.data(),
      }));
      setData(items);
    });

    return () => unsubscribe();
  }, []);

  const addItem = async () => {
    await db.collection('items').add({
      title: newItem,
      createdAt: firebase.firestore.FieldValue.serverTimestamp(),
    });
    setNewItem('');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Real-Time Data Sync with Firestore and Offline Support</Text>
      <FlatList
        data={data}
        keyExtractor={item => item.id}
        renderItem={({ item }) => <Text>{item.title}</Text>}
      />
      <TextInput
        value={newItem}
        onChangeText={setNewItem}
        placeholder="Add new item"
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Add Item" onPress={addItem} />
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will connect to Firestore and listen for real-time updates to the "items" collection. Users can add new items, and these will be instantly synchronized and displayed in the list. If the app goes offline, users can still interact with the data, and any changes will be synchronized once the app reconnects. This demonstrates how to implement real-time data sync with offline support using Firestore in a React Native application.

#### Resources to Practice Real-Time Data Sync with Offline Support
1. [Firestore Offline Capabilities](https://firebase.google.com/docs/firestore/manage-data/enable-offline)
2. [Building Offline-First Apps with Firestore](https://pusher.com/tutorials/offline-apps-react-native/)

---

### Task 13: Study Secure Storage Solutions

#### Overview of Secure Storage Solutions
Secure storage solutions are essential for protecting sensitive data in mobile applications. This includes user credentials, tokens, payment information, and any other data that should not be exposed. Secure storage ensures that data is encrypted and safely stored on the device, protecting it from unauthorized access and potential breaches. Common secure storage methods include Keychain on iOS, Keystore on Android, and libraries like `react-native-keychain` and `react-native-encrypted-storage` for cross-platform compatibility.

Implementing secure storage solutions in your React Native application helps meet security standards and compliance requirements. It also enhances user trust by ensuring their data is protected. Secure storage solutions typically involve encryption, secure key management, and safe access patterns to ensure that data remains confidential and intact.

#### Resources to Learn Secure Storage Solutions
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Best Practices for Secure Storage on Mobile Devices](https://developer.android.com/training/articles/keystore)

### Example 1: Using `react-native-keychain` for Secure Storage
#### Explanation
The `react-native-keychain` library provides a simple way to store sensitive data, such as user credentials, securely in the keychain on iOS and the Keystore on Android. This library ensures that data is encrypted and stored safely, making it an ideal choice for secure storage in React Native applications.

In this example, we will use `react-native-keychain` to store and retrieve user credentials securely. We will demonstrate how to save a username and password, retrieve them, and handle errors appropriately. This showcases the basic usage of `react-native-keychain` for secure storage.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');
  const [retrievedPassword, setRetrievedPassword] = useState('');

  const saveCredentials = async () => {
    try {
      await Keychain.setGenericPassword(username, password);
      Alert.alert('Success', 'Credentials saved securely!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save credentials.');
    }
  };

  const loadCredentials = async () => {
    try {
      const credentials = await Keychain.getGenericPassword();
      if (credentials) {
        setRetrievedUsername(credentials.username);
        setRetrievedPassword(credentials.password);
      } else {
        Alert.alert('No credentials found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load credentials.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with react-native-keychain</Text>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Credentials" onPress={saveCredentials} />
      <Button title="Load Credentials" onPress={loadCredentials} />
      {retrievedUsername && retrievedPassword && (
        <View>
          <Text>Retrieved Username: {retrievedUsername}</Text>
          <Text>Retrieved Password: {retrievedPassword}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and password and save them securely using `react-native-keychain`. They can then load the stored credentials, which will be retrieved from secure storage and displayed. This demonstrates the basic usage of `react-native-keychain` for storing and retrieving sensitive data securely.

#### Resources to Practice Using `react-native-keychain`
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Securely Storing Data in React Native Apps](https://dev.to/charlesstover/securely-storing-data-in-react-native-36ib)

### Example 2: Using `react-native-encrypted-storage` for Secure Storage
#### Explanation
The `react-native-encrypted-storage` library is another option for secure storage in React Native applications. It provides a simple API to store sensitive data securely by encrypting it before saving it to storage. This library is suitable for storing small amounts of data such as tokens, user preferences, and other sensitive information.

In this example, we will use `react-native-encrypted-storage` to store and retrieve a user's token securely. We will demonstrate how to save a token, retrieve it, and handle errors appropriately. This showcases the basic usage of `react-native-encrypted-storage` for secure storage.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import EncryptedStorage from 'react-native-encrypted-storage';

const App = () => {
  const [token, setToken] = useState('');
  const [retrievedToken, setRetrievedToken] = useState('');

  const saveToken = async () => {
    try {
      await EncryptedStorage.setItem('user_token', token);
      Alert.alert('Success', 'Token saved securely!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save token.');
    }
  };

  const loadToken = async () => {
    try {
      const token = await EncryptedStorage.getItem('user_token');
      if (token) {
        setRetrievedToken(token);
      } else {
        Alert.alert('No token found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load token.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with react-native-encrypted-storage</Text>
      <TextInput
        placeholder="Token"
        value={token}
        onChangeText={setToken}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Token" onPress={saveToken} />
      <Button title="Load Token" onPress={loadToken} />
      {retrievedToken && (
        <View>
          <Text>Retrieved Token: {retrievedToken}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their token and save it securely using `react-native-encrypted-storage`. They can then load the stored token, which will be retrieved from secure storage and displayed. This demonstrates the basic usage of `react-native-encrypted-storage` for storing and retrieving sensitive data securely.

#### Resources to Practice Using `react-native-encrypted-storage`
1. [React Native Encrypted Storage Documentation](https://github.com/emeraldsanto/react-native-encrypted-storage)
2. [Storing Data Securely with React Native Encrypted Storage](https://www.reactnativeschool.com/securely-storing-secrets-in-react-native)

### Example 3: Using Secure Storage with Biometric Authentication
#### Explanation
Biometric authentication adds an extra layer of security to your mobile application by requiring user authentication through fingerprint, face recognition, or other biometric methods before accessing sensitive data. Combining secure storage with biometric authentication ensures that only the authenticated user can access stored data.

In this example, we will use `react-native-keychain` to store and retrieve user credentials securely with biometric authentication. We will demonstrate how to save credentials, retrieve them with biometric authentication, and handle errors appropriately. This showcases the integration of secure storage with biometric authentication.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');
  const [retrievedPassword, setRetrievedPassword] = useState('');

  const saveCredentials = async () => {
    try {
      await Keychain.setGenericPassword(username, password, {
        accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_CURRENT_SET,
      });
      Alert.alert('Success', 'Credentials saved securely with biometric authentication!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save credentials.');
    }
  };

  const loadCredentials = async () => {
    try {
      const credentials = await Keychain.getGenericPassword({
        authenticationPrompt: {
          title: 'Authentication required',
          subtitle: 'Log in to retrieve your credentials',
        },
      });
      if (credentials) {
        setRetrievedUsername(credentials.username);
        setRetrievedPassword(credentials.password);
      } else {
        Alert.alert('No credentials found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load credentials.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with Biometric Authentication</Text>
      <TextInput
        placeholder="Username"
        value={

username}
        onChangeText={setUsername}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Credentials" onPress={saveCredentials} />
      <Button title="Load Credentials" onPress={loadCredentials} />
      {retrievedUsername && retrievedPassword && (
        <View>
          <Text>Retrieved Username: {retrievedUsername}</Text>
          <Text>Retrieved Password: {retrievedPassword}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and password and save them securely using `react-native-keychain` with biometric authentication. They can then load the stored credentials, which will require biometric authentication and be retrieved from secure storage. This demonstrates the integration of secure storage with biometric authentication for enhanced security.

#### Resources to Practice Secure Storage with Biometric Authentication
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Implementing Biometric Authentication in React Native](https://dev.to/charlesstover/implementing-biometric-authentication-in-react-native-2b22)

---

### Task 14: Implement Secure Storage with Keychain

#### Overview of Secure Storage with Keychain
Secure storage is essential in mobile applications to protect sensitive user data, such as passwords, tokens, and other private information. Keychain on iOS and Keystore on Android provide a secure way to store this data, ensuring it is encrypted and safely stored. The `react-native-keychain` library provides a simple interface for using Keychain and Keystore in React Native applications, allowing developers to securely store and retrieve sensitive data.

Using `react-native-keychain`, developers can securely store credentials, tokens, and other sensitive information, enhancing the security of their applications. This library supports various security features, including biometrics, which add an additional layer of protection. By implementing secure storage with Keychain, developers can ensure that user data is protected from unauthorized access.

#### Resources to Learn Secure Storage with Keychain
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Using Keychain and Keystore in React Native](https://reactnative.dev/docs/security#keychain-and-keystore)

### Example 1: Storing and Retrieving Credentials
#### Explanation
The first step in implementing secure storage with Keychain is to store and retrieve user credentials securely. This involves saving the username and password to Keychain and then retrieving them when needed. This example demonstrates how to use `react-native-keychain` to securely store and retrieve credentials.

We will create a React Native application where users can enter their username and password, save them to Keychain, and retrieve them. This example shows the basic usage of `react-native-keychain` for secure storage.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');
  const [retrievedPassword, setRetrievedPassword] = useState('');

  const saveCredentials = async () => {
    try {
      await Keychain.setGenericPassword(username, password);
      Alert.alert('Success', 'Credentials saved securely!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save credentials.');
    }
  };

  const loadCredentials = async () => {
    try {
      const credentials = await Keychain.getGenericPassword();
      if (credentials) {
        setRetrievedUsername(credentials.username);
        setRetrievedPassword(credentials.password);
      } else {
        Alert.alert('No credentials found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load credentials.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with Keychain</Text>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Credentials" onPress={saveCredentials} />
      <Button title="Load Credentials" onPress={loadCredentials} />
      {retrievedUsername && retrievedPassword && (
        <View>
          <Text>Retrieved Username: {retrievedUsername}</Text>
          <Text>Retrieved Password: {retrievedPassword}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and password and save them securely using `react-native-keychain`. They can then load the stored credentials, which will be retrieved from secure storage and displayed. This demonstrates the basic usage of `react-native-keychain` for storing and retrieving sensitive data securely.

#### Resources to Practice Storing and Retrieving Credentials
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Securely Storing Data in React Native Apps](https://dev.to/charlesstover/securely-storing-data-in-react-native-36ib)

### Example 2: Secure Storage with Biometric Authentication
#### Explanation
Adding biometric authentication to secure storage provides an additional layer of security. This ensures that only authenticated users can access sensitive data stored in Keychain. Biometric authentication can be implemented using `react-native-keychain` by configuring the access control settings to require biometrics.

In this example, we will extend the previous example to include biometric authentication. Users will be required to authenticate using their fingerprint or face recognition before accessing the stored credentials. This enhances the security of the application by ensuring that only authorized users can access sensitive data.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');
  const [retrievedPassword, setRetrievedPassword] = useState('');

  const saveCredentials = async () => {
    try {
      await Keychain.setGenericPassword(username, password, {
        accessControl: Keychain.ACCESS_CONTROL.BIOMETRY_CURRENT_SET,
      });
      Alert.alert('Success', 'Credentials saved securely with biometric authentication!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save credentials.');
    }
  };

  const loadCredentials = async () => {
    try {
      const credentials = await Keychain.getGenericPassword({
        authenticationPrompt: {
          title: 'Authentication required',
          subtitle: 'Log in to retrieve your credentials',
        },
      });
      if (credentials) {
        setRetrievedUsername(credentials.username);
        setRetrievedPassword(credentials.password);
      } else {
        Alert.alert('No credentials found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load credentials.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with Biometric Authentication</Text>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Credentials" onPress={saveCredentials} />
      <Button title="Load Credentials" onPress={loadCredentials} />
      {retrievedUsername && retrievedPassword && (
        <View>
          <Text>Retrieved Username: {retrievedUsername}</Text>
          <Text>Retrieved Password: {retrievedPassword}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and password and save them securely using `react-native-keychain` with biometric authentication. They can then load the stored credentials, which will require biometric authentication and be retrieved from secure storage. This demonstrates the integration of secure storage with biometric authentication for enhanced security.

#### Resources to Practice Secure Storage with Biometric Authentication
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Implementing Biometric Authentication in React Native](https://dev.to/charlesstover/implementing-biometric-authentication-in-react-native-2b22)

### Example 3: Secure Storage with Access Control
#### Explanation
Access control settings in `react-native-keychain` provide additional security options, such as requiring user presence or device passcode for accessing stored data. This ensures that sensitive data is protected even if the device is compromised. Access control settings can be customized to fit the security requirements of your application.

In this example, we will use `react-native-keychain` to store credentials with specific access control settings. We will configure the access control to require the device passcode or biometrics for accessing the stored credentials. This demonstrates how to enhance the security of stored data using access control settings.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');
  const [retrievedPassword, setRetrievedPassword] = useState('');

  const saveCredentials = async () => {
    try {
      await Keychain.setGenericPassword(username, password, {
        accessControl: Keychain.ACCESS_CONTROL.DEVICE_PASSCODE_OR_BIOMETRY,
      });
      Alert.alert('Success', 'Credentials saved securely with access control!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save credentials.');
    }
  };

  const loadCredentials = async () => {
    try {
      const credentials = await Keychain.getGenericPassword({
        authenticationPrompt

: {
          title: 'Authentication required',
          subtitle: 'Log in to retrieve your credentials',
        },
      });
      if (credentials) {
        setRetrievedUsername(credentials.username);
        setRetrievedPassword(credentials.password);
      } else {
        Alert.alert('No credentials found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load credentials.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Secure Storage with Access Control</Text>
      <TextInput
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <TextInput
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Credentials" onPress={saveCredentials} />
      <Button title="Load Credentials" onPress={loadCredentials} />
      {retrievedUsername && retrievedPassword && (
        <View>
          <Text>Retrieved Username: {retrievedUsername}</Text>
          <Text>Retrieved Password: {retrievedPassword}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and password and save them securely using `react-native-keychain` with access control settings. They can then load the stored credentials, which will require device passcode or biometrics for access. This demonstrates how to use access control settings to enhance the security of stored data.

#### Resources to Practice Secure Storage with Access Control
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Best Practices for Secure Storage on Mobile Devices](https://developer.android.com/training/articles/keystore)

---

### CTask 15: Study Data Encryption Techniques

#### Overview of Data Encryption Techniques
Data encryption is a method of converting plain text into a coded format, called ciphertext, to prevent unauthorized access. It is a crucial aspect of data security in mobile applications, ensuring that sensitive information such as passwords, personal details, and financial data is protected from potential breaches. Encryption algorithms like AES (Advanced Encryption Standard) and RSA (Rivest-Shamir-Adleman) are commonly used to secure data both at rest and in transit.

Implementing encryption in mobile applications involves using libraries and tools that provide robust encryption methods. This ensures that data stored on the device or transmitted over the network is encrypted and can only be decrypted by authorized parties. Proper key management, encryption standards, and best practices are essential to ensure the security and integrity of the encrypted data.

#### Resources to Learn Data Encryption Techniques
1. [Encryption Basics](https://en.wikipedia.org/wiki/Encryption)
2. [Understanding AES Encryption](https://www.n-able.com/blog/aes-encryption)

### Example 1: Encrypting Data with AES in React Native
#### Explanation
AES (Advanced Encryption Standard) is a symmetric encryption algorithm widely used to secure data. In symmetric encryption, the same key is used for both encryption and decryption. AES is known for its efficiency and security, making it a popular choice for encrypting sensitive data in mobile applications.

In this example, we will use the `react-native-crypto-js` library to encrypt and decrypt data using AES. The example demonstrates how to securely store and retrieve encrypted data in a React Native application, ensuring that sensitive information is protected.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import CryptoJS from 'crypto-js';

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');

  const key = 'my-secret-key'; // Use a secure key in a real application

  const encryptData = () => {
    const encrypted = CryptoJS.AES.encrypt(plainText, key).toString();
    setEncryptedText(encrypted);
    Alert.alert('Success', 'Data encrypted successfully!');
  };

  const decryptData = () => {
    const bytes = CryptoJS.AES.decrypt(encryptedText, key);
    const decrypted = bytes.toString(CryptoJS.enc.Utf8);
    setDecryptedText(decrypted);
    Alert.alert('Success', 'Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Encrypting Data with AES</Text>
      <TextInput
        placeholder="Enter plain text"
        value={plainText}
        onChangeText={setPlainText}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Encrypt Data" onPress={encryptData} />
      {encryptedText && (
        <View>
          <Text>Encrypted Text: {encryptedText}</Text>
        </View>
      )}
      <Button title="Decrypt Data" onPress={decryptData} />
      {decryptedText && (
        <View>
          <Text>Decrypted Text: {decryptedText}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter plain text and encrypt it using AES. The encrypted text will be displayed, and users can decrypt it back to the original plain text. This demonstrates how to use AES encryption and decryption in a React Native application.

#### Resources to Practice Encrypting Data with AES
1. [CryptoJS Documentation](https://cryptojs.gitbook.io/docs/)
2. [AES Encryption in JavaScript](https://www.sitepoint.com/aes-encryption-decryption-in-javascript/)

### Example 2: Encrypting Data with RSA in React Native
#### Explanation
RSA (Rivest-Shamir-Adleman) is an asymmetric encryption algorithm that uses a pair of keys: a public key for encryption and a private key for decryption. This method is widely used for secure data transmission, such as in SSL/TLS for secure communication over the internet. RSA is known for its strong security but is computationally more intensive than symmetric algorithms like AES.

In this example, we will use the `react-native-rsa-native` library to encrypt and decrypt data using RSA. The example demonstrates how to generate RSA key pairs, encrypt data with the public key, and decrypt data with the private key in a React Native application.

#### Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import RSA from 'react-native-rsa-native';

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');
  const [publicKey, setPublicKey] = useState('');
  const [privateKey, setPrivateKey] = useState('');

  useEffect(() => {
    const generateKeys = async () => {
      const keys = await RSA.generateKeys(2048); // Generate 2048-bit key pair
      setPublicKey(keys.public);
      setPrivateKey(keys.private);
    };

    generateKeys();
  }, []);

  const encryptData = async () => {
    const encrypted = await RSA.encrypt(plainText, publicKey);
    setEncryptedText(encrypted);
    Alert.alert('Success', 'Data encrypted successfully!');
  };

  const decryptData = async () => {
    const decrypted = await RSA.decrypt(encryptedText, privateKey);
    setDecryptedText(decrypted);
    Alert.alert('Success', 'Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Encrypting Data with RSA</Text>
      <TextInput
        placeholder="Enter plain text"
        value={plainText}
        onChangeText={setPlainText}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Encrypt Data" onPress={encryptData} />
      {encryptedText && (
        <View>
          <Text>Encrypted Text: {encryptedText}</Text>
        </View>
      )}
      <Button title="Decrypt Data" onPress={decryptData} />
      {decryptedText && (
        <View>
          <Text>Decrypted Text: {decryptedText}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will generate an RSA key pair. Users can enter plain text and encrypt it using the public key. The encrypted text will be displayed, and users can decrypt it back to the original plain text using the private key. This demonstrates how to use RSA encryption and decryption in a React Native application.

#### Resources to Practice Encrypting Data with RSA
1. [RSA Documentation](https://react-native-rsa-native.vercel.app/docs)
2. [RSA Encryption in JavaScript](https://www.sitepoint.com/rsa-encryption-decryption-in-javascript/)

### Example 3: Encrypting Data at Rest Using `react-native-encrypted-storage`
#### Explanation
Encrypting data at rest ensures that sensitive data stored on the device is protected from unauthorized access. `react-native-encrypted-storage` is a library that provides a simple way to securely store and retrieve encrypted data in React Native applications. This library uses the device's secure storage mechanisms, such as Keychain on iOS and Keystore on Android, to encrypt data before saving it.

In this example, we will use `react-native-encrypted-storage` to securely store and retrieve a user's token. The example demonstrates how to save data securely, retrieve it, and handle errors appropriately. This showcases the basic usage of `react-native-encrypted-storage` for encrypting data at rest.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import EncryptedStorage from 'react-native-encrypted-storage';

const App = () => {
  const [token, setToken] = useState('');
  const [retrievedToken, setRetrievedToken] = useState('');

  const saveToken = async () => {
    try {
      await EncryptedStorage.setItem('user_token', token);
      Alert.alert('Success', 'Token saved securely!');
    } catch (error) {
      Alert.alert('Error', 'Failed to save token.');
    }
  };

  const loadToken = async () => {
    try {
      const token = await EncryptedStorage.getItem('user_token');
      if (token) {
        setRetrievedToken(token);
      } else {
        Alert.alert('No token found');
      }
    } catch (error) {
      Alert.alert('Error', 'Failed to load token.');
    }
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Encrypting Data at Rest with Encrypted Storage</Text>
      <TextInput
        placeholder="Enter token"
        value={token}
        onChangeText={setToken}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Save Token" onPress={saveToken} />
      <Button title="Load Token" onPress={load

Token} />
      {retrievedToken && (
        <View>
          <Text>Retrieved Token: {retrievedToken}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter their token and save it securely using `react-native-encrypted-storage`. They can then load the stored token, which will be retrieved from secure storage and displayed. This demonstrates the basic usage of `react-native-encrypted-storage` for storing and retrieving encrypted data securely.

#### Resources to Practice Encrypting Data at Rest
1. [React Native Encrypted Storage Documentation](https://github.com/emeraldsanto/react-native-encrypted-storage)
2. [Storing Data Securely with React Native Encrypted Storage](https://www.reactnativeschool.com/securely-storing-secrets-in-react-native)

---

### Task 16: Implement Encryption with Web Crypto API

#### Overview of Web Crypto API
The Web Crypto API provides a set of low-level cryptographic primitives to perform encryption, decryption, and other cryptographic operations in web applications. It includes methods for generating cryptographic keys, performing hash functions, and encrypting/decrypting data. The Web Crypto API is part of the W3C Web Cryptography standard and is widely supported in modern browsers. 

For React Native applications, the `react-native-webcrypto` library can be used to bring the Web Crypto API to the mobile environment, allowing developers to perform secure cryptographic operations in a consistent manner across platforms. Using the Web Crypto API, developers can ensure that sensitive data is protected both at rest and in transit, enhancing the overall security of their applications.

#### Resources to Learn Web Crypto API
1. [Web Crypto API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
2. [Using the Web Crypto API](https://www.smashingmagazine.com/2020/11/guide-using-web-crypto-api/)

### Example 1: Encrypting and Decrypting Data with AES-GCM
#### Explanation
AES-GCM (Advanced Encryption Standard in Galois/Counter Mode) is a widely used symmetric encryption algorithm known for its performance and security. In this example, we will use the Web Crypto API to encrypt and decrypt data using AES-GCM. This demonstrates how to securely handle encryption and decryption of sensitive data in a React Native application.

We will create a React Native application that allows users to enter plain text, encrypt it using AES-GCM, and then decrypt it back to the original text. This example showcases the basic usage of the Web Crypto API for encryption and decryption.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import 'react-native-get-random-values';
import { encode as base64Encode, decode as base64Decode } from 'base64-arraybuffer';

const generateKey = async () => {
  return crypto.subtle.generateKey(
    { name: 'AES-GCM', length: 256 },
    true,
    ['encrypt', 'decrypt']
  );
};

const encryptData = async (key, data) => {
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const encodedData = new TextEncoder().encode(data);
  const encrypted = await crypto.subtle.encrypt(
    { name: 'AES-GCM', iv },
    key,
    encodedData
  );
  return { iv: base64Encode(iv), encryptedData: base64Encode(encrypted) };
};

const decryptData = async (key, iv, data) => {
  const decodedIv = base64Decode(iv);
  const decodedData = base64Decode(data);
  const decrypted = await crypto.subtle.decrypt(
    { name: 'AES-GCM', iv: decodedIv },
    key,
    decodedData
  );
  return new TextDecoder().decode(decrypted);
};

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');
  const [encryptionKey, setEncryptionKey] = useState(null);

  const handleEncrypt = async () => {
    if (!encryptionKey) {
      const key = await generateKey();
      setEncryptionKey(key);
    }
    const { iv, encryptedData } = await encryptData(encryptionKey, plainText);
    setEncryptedText(JSON.stringify({ iv, encryptedData }));
    Alert.alert('Success', 'Data encrypted successfully!');
  };

  const handleDecrypt = async () => {
    if (!encryptionKey || !encryptedText) return;
    const { iv, encryptedData } = JSON.parse(encryptedText);
    const decrypted = await decryptData(encryptionKey, iv, encryptedData);
    setDecryptedText(decrypted);
    Alert.alert('Success', 'Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Encrypting and Decrypting Data with AES-GCM</Text>
      <TextInput
        placeholder="Enter plain text"
        value={plainText}
        onChangeText={setPlainText}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Encrypt Data" onPress={handleEncrypt} />
      {encryptedText && (
        <View>
          <Text>Encrypted Text: {encryptedText}</Text>
        </View>
      )}
      <Button title="Decrypt Data" onPress={handleDecrypt} />
      {decryptedText && (
        <View>
          <Text>Decrypted Text: {decryptedText}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter plain text and encrypt it using AES-GCM. The encrypted text will be displayed, and users can decrypt it back to the original plain text. This demonstrates how to use the Web Crypto API for encryption and decryption in a React Native application.

#### Resources to Practice Encrypting and Decrypting Data with AES-GCM
1. [Web Crypto API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt)
2. [AES-GCM Encryption in JavaScript](https://developer.mozilla.org/en-US/docs/Web/API/AesGcmParams)

### Example 2: Generating and Using RSA Key Pairs
#### Explanation
RSA (Rivest-Shamir-Adleman) is an asymmetric encryption algorithm that uses a pair of keys: a public key for encryption and a private key for decryption. This method is widely used for secure data transmission, such as in SSL/TLS for secure communication over the internet. In this example, we will use the Web Crypto API to generate RSA key pairs, encrypt data with the public key, and decrypt data with the private key.

We will create a React Native application that generates RSA key pairs, allows users to enter plain text, encrypt it using the public key, and then decrypt it back to the original text using the private key. This example demonstrates the use of RSA encryption and decryption with the Web Crypto API.

#### Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, Alert } from 'react-native';
import 'react-native-get-random-values';
import { encode as base64Encode, decode as base64Decode } from 'base64-arraybuffer';

const generateKeyPair = async () => {
  const keyPair = await crypto.subtle.generateKey(
    {
      name: 'RSA-OAEP',
      modulusLength: 2048,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: 'SHA-256',
    },
    true,
    ['encrypt', 'decrypt']
  );
  return keyPair;
};

const encryptData = async (publicKey, data) => {
  const encodedData = new TextEncoder().encode(data);
  const encrypted = await crypto.subtle.encrypt(
    { name: 'RSA-OAEP' },
    publicKey,
    encodedData
  );
  return base64Encode(encrypted);
};

const decryptData = async (privateKey, data) => {
  const decodedData = base64Decode(data);
  const decrypted = await crypto.subtle.decrypt(
    { name: 'RSA-OAEP' },
    privateKey,
    decodedData
  );
  return new TextDecoder().decode(decrypted);
};

const App = () => {
  const [plainText, setPlainText] = useState('');
  const [encryptedText, setEncryptedText] = useState('');
  const [decryptedText, setDecryptedText] = useState('');
  const [keyPair, setKeyPair] = useState(null);

  useEffect(() => {
    const generateKeys = async () => {
      const keys = await generateKeyPair();
      setKeyPair(keys);
    };
    generateKeys();
  }, []);

  const handleEncrypt = async () => {
    if (!keyPair) return;
    const encrypted = await encryptData(keyPair.publicKey, plainText);
    setEncryptedText(encrypted);
    Alert.alert('Success', 'Data encrypted successfully!');
  };

  const handleDecrypt = async () => {
    if (!keyPair || !encryptedText) return;
    const decrypted = await decryptData(keyPair.privateKey, encryptedText);
    setDecryptedText(decrypted);
    Alert.alert('Success', 'Data decrypted successfully!');
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Generating and Using RSA Key Pairs</Text>
      <TextInput
        placeholder="Enter plain text"
        value={plainText}
        onChangeText={setPlainText}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Encrypt Data" onPress={handleEncrypt} />
      {encryptedText && (
        <View>
          <Text>Encrypted Text: {encryptedText}</Text>
        </View>
      )}
      <Button title="Decrypt Data" onPress={handleDecrypt} />
      {decryptedText && (
        <View>
          <Text>Decrypted Text: {decryptedText}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, it will generate an RSA key pair. Users can enter plain

 text and encrypt it using the public key. The encrypted text will be displayed, and users can decrypt it back to the original plain text using the private key. This demonstrates how to use RSA encryption and decryption with the Web Crypto API in a React Native application.

#### Resources to Practice Generating and Using RSA Key Pairs
1. [Web Crypto API RSA Documentation](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey)
2. [RSA Encryption in JavaScript](https://www.sitepoint.com/rsa-encryption-decryption-in-javascript/)

### Example 3: Hashing Data with SHA-256
#### Explanation
Hashing is a process of converting data into a fixed-size string of characters, which is typically a hash code. SHA-256 (Secure Hash Algorithm 256-bit) is a cryptographic hash function that generates a unique 256-bit (32-byte) hash code for the input data. Hashing is commonly used to verify data integrity and store passwords securely.

In this example, we will use the Web Crypto API to hash data using SHA-256. The example demonstrates how to hash a user's input and display the resulting hash code. This showcases the basic usage of the Web Crypto API for hashing data.

#### Code
```javascript
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import 'react-native-get-random-values';
import { encode as base64Encode } from 'base64-arraybuffer';

const hashData = async (data) => {
  const encodedData = new TextEncoder().encode(data);
  const hashBuffer = await crypto.subtle.digest('SHA-256', encodedData);
  return base64Encode(hashBuffer);
};

const App = () => {
  const [inputText, setInputText] = useState('');
  const [hash, setHash] = useState('');

  const handleHash = async () => {
    const hashedData = await hashData(inputText);
    setHash(hashedData);
  };

  return (
    <View style={{ padding: 20 }}>
      <Text>Hashing Data with SHA-256</Text>
      <TextInput
        placeholder="Enter text"
        value={inputText}
        onChangeText={setInputText}
        style={{ borderWidth: 1, padding: 10, marginVertical: 10 }}
      />
      <Button title="Hash Data" onPress={handleHash} />
      {hash && (
        <View>
          <Text>Hashed Data: {hash}</Text>
        </View>
      )}
    </View>
  );
};

export default App;
```

#### Expected Output
When the app is loaded, users can enter text and hash it using SHA-256. The resulting hash code will be displayed. This demonstrates how to use the Web Crypto API for hashing data in a React Native application.

#### Resources to Practice Hashing Data with SHA-256
1. [Web Crypto API Hashing Documentation](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest)
2. [Hashing with SHA-256 in JavaScript](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/digest)

---

### Task 17: Study Real-Time Communication Techniques

#### Overview of Real-Time Communication Techniques
Real-time communication (RTC) in mobile applications enables instant data exchange between users or systems. It is essential for applications like chat apps, live collaboration tools, video conferencing, and real-time updates. Real-time communication can be implemented using various technologies such as WebSockets, WebRTC, and MQTT (Message Queuing Telemetry Transport).

WebSockets provide full-duplex communication channels over a single TCP connection, making them suitable for applications requiring low-latency, bidirectional data exchange. WebRTC is a technology specifically designed for peer-to-peer communication, supporting audio, video, and data sharing. MQTT is a lightweight messaging protocol optimized for devices with limited bandwidth and high-latency networks, commonly used in IoT applications.

#### Resources to Learn Real-Time Communication Techniques
1. [WebSockets Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [WebRTC Documentation](https://webrtc.org/)

### Example 1: Implementing Real-Time Chat with WebSockets
#### Explanation
WebSockets are ideal for implementing real-time chat applications due to their ability to maintain a persistent connection between the client and server. This allows messages to be sent and received instantly without the overhead of HTTP requests. In this example, we will create a simple real-time chat application using WebSockets.

The React Native application will connect to a WebSocket server and allow users to send and receive messages in real-time. This example demonstrates how to establish a WebSocket connection, handle incoming messages, and send messages to the server.

#### Code
```javascript
// App.js
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import WebSocket from 'react-native-websocket';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');
  const ws = useRef(null);

  useEffect(() => {
    ws.current = new WebSocket('wss://echo.websocket.org');

    ws.current.onmessage = (e) => {
      setMessages((prevMessages) => [...prevMessages, e.data]);
    };

    ws.current.onerror = (e) => {
      console.error(e.message);
    };

    ws.current.onclose = (e) => {
      console.log('WebSocket closed:', e.reason);
    };

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const sendMessage = () => {
    if (ws.current && message) {
      ws.current.send(message);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Real-Time Chat with WebSockets</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  title: {
    fontSize: 20,
    marginBottom: 10,
  },
  message: {
    padding: 10,
    backgroundColor: '#f0f0f0',
    marginVertical: 5,
    borderRadius: 5,
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 10,
    borderRadius: 5,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will connect to the WebSocket server. Users can type messages and send them by pressing the "Send Message" button. The messages will be displayed in the chat window in real-time as they are sent and received. This demonstrates how to implement real-time communication using WebSockets in a React Native application.

#### Resources to Practice Implementing Real-Time Chat with WebSockets
1. [WebSockets in React Native](https://levelup.gitconnected.com/using-websockets-in-react-native-9c10c6d9dc9e)
2. [Building Real-Time Applications with WebSockets](https://blog.logrocket.com/websockets-in-react/)

### Example 2: Implementing Video Chat with WebRTC
#### Explanation
WebRTC (Web Real-Time Communication) is a technology that enables peer-to-peer communication directly between browsers or mobile apps, supporting audio, video, and data sharing. It is commonly used for video chat applications, allowing users to engage in real-time video conversations without needing a centralized server for media relay.

In this example, we will create a simple video chat application using WebRTC. The React Native application will establish a peer-to-peer connection, enabling users to start a video chat. This example demonstrates how to set up WebRTC, handle video streams, and manage peer connections.

#### Code
```javascript
// App.js
import React, { useRef, useEffect } from 'react';
import { View, Button, StyleSheet } from 'react-native';
import { mediaDevices } from 'react-native-webrtc';
import {
  RTCPeerConnection,
  RTCIceCandidate,
  RTCSessionDescription,
  RTCView,
} from 'react-native-webrtc';

const App = () => {
  const localStream = useRef(null);
  const remoteStream = useRef(null);
  const pc = useRef(new RTCPeerConnection(null));

  useEffect(() => {
    const startLocalStream = async () => {
      const stream = await mediaDevices.getUserMedia({
        audio: true,
        video: true,
      });
      localStream.current.srcObject = stream;
      stream.getTracks().forEach((track) => {
        pc.current.addTrack(track, stream);
      });
    };

    pc.current.onicecandidate = (event) => {
      if (event.candidate) {
        // Send the candidate to the remote peer
      }
    };

    pc.current.ontrack = (event) => {
      if (event.streams && event.streams[0]) {
        remoteStream.current.srcObject = event.streams[0];
      }
    };

    startLocalStream();

    return () => {
      if (pc.current) {
        pc.current.close();
      }
    };
  }, []);

  const startCall = async () => {
    const offer = await pc.current.createOffer();
    await pc.current.setLocalDescription(new RTCSessionDescription(offer));
    // Send the offer to the remote peer
  };

  return (
    <View style={styles.container}>
      <RTCView streamURL={localStream.current && localStream.current.toURL()} style={styles.stream} />
      <RTCView streamURL={remoteStream.current && remoteStream.current.toURL()} style={styles.stream} />
      <Button title="Start Call" onPress={startCall} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  stream: {
    width: 200,
    height: 200,
    backgroundColor: 'black',
    margin: 10,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will prompt the user to grant access to the camera and microphone. The local video stream will be displayed on the screen. Users can start a call by pressing the "Start Call" button, which will initiate a WebRTC peer-to-peer connection. The remote video stream will be displayed once the connection is established. This demonstrates how to implement real-time video chat using WebRTC in a React Native application.

#### Resources to Practice Implementing Video Chat with WebRTC
1. [WebRTC Documentation](https://webrtc.org/)
2. [Building a Video Chat App with WebRTC and React Native](https://blog.reactnativecoach.com/setting-up-video-streaming-in-react-native-using-webrtc-1a9483b944f4)

### Example 3: Implementing Real-Time Communication with MQTT
#### Explanation
MQTT (Message Queuing Telemetry Transport) is a lightweight messaging protocol designed for devices with limited bandwidth and high-latency networks. It is commonly used in IoT (Internet of Things) applications to enable real-time communication between devices. MQTT operates on a publish-subscribe model, where clients can publish messages to topics and subscribe to topics to receive messages.

In this example, we will create a React Native application that uses MQTT for real-time communication. The app will connect to an MQTT broker, subscribe to a topic, and publish messages to the topic. This example demonstrates how to use MQTT for real-time messaging in a React Native application.

#### Code
```javascript
// App.js
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import { Client, Message } from 'react-native-paho-mqtt';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');
  const [client, setClient] = useState(null);

  useEffect(() => {
    const mqttClient = new Client({
      uri: 'ws://broker.hivemq.com:8000/mqtt',
      clientId: 'react_native_mqtt',
    });

    mqttClient.on('

connectionLost', (responseObject) => {
      console.log('Connection lost:', responseObject.errorMessage);
    });

    mqttClient.on('messageReceived', (msg) => {
      setMessages((prevMessages) => [...prevMessages, msg.payloadString]);
    });

    mqttClient.connect()
      .then(() => {
        console.log('Connected to MQTT broker');
        mqttClient.subscribe('react_native_topic');
      })
      .catch((err) => {
        console.error('Connection error:', err);
      });

    setClient(mqttClient);

    return () => {
      if (mqttClient) {
        mqttClient.disconnect();
      }
    };
  }, []);

  const sendMessage = () => {
    if (client && message) {
      const msg = new Message(message);
      msg.destinationName = 'react_native_topic';
      client.send(msg);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Real-Time Communication with MQTT</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  title: {
    fontSize: 20,
    marginBottom: 10,
  },
  message: {
    padding: 10,
    backgroundColor: '#f0f0f0',
    marginVertical: 5,
    borderRadius: 5,
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 10,
    borderRadius: 5,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will connect to the MQTT broker and subscribe to the topic "react_native_topic". Users can type messages and send them by pressing the "Send Message" button. The messages will be displayed in the chat window in real-time as they are sent and received. This demonstrates how to implement real-time communication using MQTT in a React Native application.

#### Resources to Practice Implementing Real-Time Communication with MQTT
1. [MQTT Documentation](https://mqtt.org/documentation)
2. [Building Real-Time Applications with MQTT](https://www.hivemq.com/mqtt-tutorial/)

---

### Task 18: Implement Real-Time Messaging with WebSockets

#### Overview of WebSockets for Real-Time Messaging
WebSockets provide a full-duplex communication channel over a single TCP connection, allowing for real-time data transfer between the client and server. This technology is particularly useful for applications that require instant data exchange, such as chat applications, live notifications, and real-time collaboration tools. Unlike traditional HTTP requests, WebSockets maintain an open connection, enabling continuous data flow without the need to re-establish the connection.

WebSockets are supported by all modern browsers and can be easily integrated into React Native applications. By using WebSockets, developers can create responsive and interactive applications that provide a seamless user experience. The persistent connection reduces latency and improves the efficiency of data transmission, making WebSockets an ideal choice for real-time messaging.

#### Resources to Learn WebSockets
1. [WebSockets Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Using WebSockets in React Native](https://levelup.gitconnected.com/using-websockets-in-react-native-9c10c6d9dc9e)

### Example 1: Basic Real-Time Messaging App
#### Explanation
In this example, we will create a basic real-time messaging application using WebSockets. The application will allow users to send and receive messages in real-time. We will use a WebSocket server that echoes messages back to the client, enabling users to see their messages displayed instantly.

The React Native application will establish a WebSocket connection, handle incoming messages, and allow users to send messages. This example demonstrates the fundamental concepts of using WebSockets for real-time communication.

#### Code
```javascript
// App.js
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import WebSocket from 'react-native-websocket';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');
  const ws = useRef(null);

  useEffect(() => {
    ws.current = new WebSocket('wss://echo.websocket.org');

    ws.current.onmessage = (e) => {
      setMessages((prevMessages) => [...prevMessages, e.data]);
    };

    ws.current.onerror = (e) => {
      console.error(e.message);
    };

    ws.current.onclose = (e) => {
      console.log('WebSocket closed:', e.reason);
    };

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const sendMessage = () => {
    if (ws.current && message) {
      ws.current.send(message);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Real-Time Messaging with WebSockets</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  title: {
    fontSize: 20,
    marginBottom: 10,
  },
  message: {
    padding: 10,
    backgroundColor: '#f0f0f0',
    marginVertical: 5,
    borderRadius: 5,
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 10,
    borderRadius: 5,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will connect to the WebSocket server. Users can type messages and send them by pressing the "Send Message" button. The messages will be displayed in the chat window in real-time as they are sent and received. This demonstrates how to implement real-time messaging using WebSockets in a React Native application.

#### Resources to Practice Basic Real-Time Messaging with WebSockets
1. [WebSockets Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Building Real-Time Applications with WebSockets](https://blog.logrocket.com/websockets-in-react/)

### Example 2: Real-Time Messaging with User Identification
#### Explanation
In this example, we will extend the basic real-time messaging app to include user identification. Each message will be associated with a username, allowing users to see who sent each message. This feature is essential for chat applications where users need to identify the sender of each message.

We will modify the application to include a username input field. When users send a message, their username will be included in the message data. This example demonstrates how to enhance real-time messaging with user identification using WebSockets.

#### Code
```javascript
// App.js
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import WebSocket from 'react-native-websocket';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');
  const [username, setUsername] = useState('');
  const ws = useRef(null);

  useEffect(() => {
    ws.current = new WebSocket('wss://echo.websocket.org');

    ws.current.onmessage = (e) => {
      setMessages((prevMessages) => [...prevMessages, e.data]);
    };

    ws.current.onerror = (e) => {
      console.error(e.message);
    };

    ws.current.onclose = (e) => {
      console.log('WebSocket closed:', e.reason);
    };

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const sendMessage = () => {
    if (ws.current && message && username) {
      const formattedMessage = `${username}: ${message}`;
      ws.current.send(formattedMessage);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Real-Time Messaging with User Identification</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
      />
      <TextInput
        style={styles.input}
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  title: {
    fontSize: 20,
    marginBottom: 10,
  },
  message: {
    padding: 10,
    backgroundColor: '#f0f0f0',
    marginVertical: 5,
    borderRadius: 5,
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 10,
    borderRadius: 5,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, users can enter their username and type messages. Each message sent will be prefixed with the username, allowing users to see who sent each message. The messages will be displayed in the chat window in real-time. This demonstrates how to implement user identification in a real-time messaging application using WebSockets.

#### Resources to Practice Real-Time Messaging with User Identification
1. [WebSockets Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Implementing User Identification in Real-Time Messaging](https://www.pubnub.com/blog/implementing-chat-application-react-websockets/)

### Example 3: Persistent Messaging with WebSockets and AsyncStorage
#### Explanation
In this example, we will extend the real-time messaging app to include persistent messaging. Messages will be stored locally using AsyncStorage, ensuring that users can see previous messages even after restarting the application. This feature is useful for chat applications where users need to retain message history.

We will modify the application to save messages to AsyncStorage whenever a new message is received. When the app loads, it will retrieve and display the saved messages from AsyncStorage. This example demonstrates how to implement persistent messaging using WebSockets and AsyncStorage in a React Native application.

#### Code
```javascript
// App.js
import React, { useState, useEffect, useRef } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import WebSocket from 'react-native-websocket';
import AsyncStorage from '@react-native-async-storage/async-storage';

const App = () => {
  const [messages, setMessages] = useState([]);
  const [message, setMessage] = useState('');
  const [username, setUsername] = useState('');
  const ws = useRef(null);

  useEffect(() => {
    const loadMessages = async () => {
      try {
        const savedMessages = await AsyncStorage.getItem('messages');
        if (savedMessages) {
          setMessages(JSON.parse(saved

Messages));
        }
      } catch (error) {
        console.error('Failed to load messages:', error);
      }
    };

    loadMessages();

    ws.current = new WebSocket('wss://echo.websocket.org');

    ws.current.onmessage = (e) => {
      const newMessage = e.data;
      setMessages((prevMessages) => {
        const updatedMessages = [...prevMessages, newMessage];
        AsyncStorage.setItem('messages', JSON.stringify(updatedMessages));
        return updatedMessages;
      });
    };

    ws.current.onerror = (e) => {
      console.error(e.message);
    };

    ws.current.onclose = (e) => {
      console.log('WebSocket closed:', e.reason);
    };

    return () => {
      if (ws.current) {
        ws.current.close();
      }
    };
  }, []);

  const sendMessage = () => {
    if (ws.current && message && username) {
      const formattedMessage = `${username}: ${message}`;
      ws.current.send(formattedMessage);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <Text style={styles.title}>Persistent Real-Time Messaging</Text>
      <FlatList
        data={messages}
        keyExtractor={(item, index) => index.toString()}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
      />
      <TextInput
        style={styles.input}
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send Message" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    padding: 20,
    flex: 1,
  },
  title: {
    fontSize: 20,
    marginBottom: 10,
  },
  message: {
    padding: 10,
    backgroundColor: '#f0f0f0',
    marginVertical: 5,
    borderRadius: 5,
  },
  input: {
    borderWidth: 1,
    padding: 10,
    marginVertical: 10,
    borderRadius: 5,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will retrieve and display the saved messages from AsyncStorage. Users can enter their username and type messages. Each message sent will be prefixed with the username and displayed in real-time. The messages will be saved to AsyncStorage, ensuring that they persist even after restarting the app. This demonstrates how to implement persistent messaging using WebSockets and AsyncStorage in a React Native application.

#### Resources to Practice Persistent Messaging with WebSockets and AsyncStorage
1. [WebSockets Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Using AsyncStorage in React Native](https://react-native-async-storage.github.io/async-storage/docs/install/)

---

### Task 19: Study Video Streaming APIs

#### Overview of Video Streaming APIs
Video streaming APIs enable developers to integrate video playback and streaming capabilities into their applications. These APIs provide a range of features, including live streaming, video-on-demand, adaptive bitrate streaming, and support for various video formats. Popular video streaming APIs include YouTube API, Vimeo API, and more specialized services like AWS IVS (Interactive Video Service) and Twilio Video API.

Integrating video streaming into React Native applications can significantly enhance user engagement by providing rich media content. Developers can leverage these APIs to build features such as live video broadcasts, video conferencing, and custom video players. Understanding the capabilities and integration methods of different video streaming APIs is essential for implementing robust and scalable video solutions.

#### Resources to Learn Video Streaming APIs
1. [YouTube Data API Documentation](https://developers.google.com/youtube/v3)
2. [Vimeo API Documentation](https://developer.vimeo.com/)

### Example 1: Integrating YouTube Video Playback
#### Explanation
The YouTube Data API allows developers to integrate YouTube video playback into their applications. This API provides access to YouTube videos, playlists, channels, and other content, enabling features such as video search, video playback, and video metadata retrieval. By integrating YouTube video playback, developers can enhance their applications with rich video content from YouTube.

In this example, we will create a React Native application that integrates YouTube video playback using the `react-native-youtube-iframe` library. This library provides a simple way to embed YouTube videos in a React Native application. The example will demonstrate how to play a YouTube video and handle basic playback controls.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import YoutubePlayer from 'react-native-youtube-iframe';

const App = () => {
  return (
    <View style={styles.container}>
      <YoutubePlayer
        height={300}
        play={true}
        videoId={'dQw4w9WgXcQ'} // Replace with your video ID
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a YouTube video player that plays the specified video. Users can watch the video and use the standard playback controls provided by the YouTube player. This demonstrates how to integrate YouTube video playback in a React Native application using the `react-native-youtube-iframe` library.

#### Resources to Practice Integrating YouTube Video Playback
1. [YouTube Data API Documentation](https://developers.google.com/youtube/v3)
2. [react-native-youtube-iframe Documentation](https://github.com/LonelyCpp/react-native-youtube-iframe)

### Example 2: Integrating Vimeo Video Playback
#### Explanation
The Vimeo API allows developers to integrate Vimeo video playback into their applications. This API provides access to Vimeo videos, channels, albums, and more, enabling features such as video search, video playback, and video metadata retrieval. Integrating Vimeo video playback can enhance applications with high-quality video content from Vimeo.

In this example, we will create a React Native application that integrates Vimeo video playback using the `react-native-webview` library. This library provides a way to embed web content in a React Native application, including Vimeo videos. The example will demonstrate how to play a Vimeo video and handle basic playback controls.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { WebView } from 'react-native-webview';

const App = () => {
  return (
    <View style={styles.container}>
      <WebView
        style={styles.webview}
        source={{ uri: 'https://player.vimeo.com/video/76979871' }} // Replace with your video URL
        allowsInlineMediaPlayback={true}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  webview: {
    width: '100%',
    height: 300,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a Vimeo video player that plays the specified video. Users can watch the video and use the standard playback controls provided by the Vimeo player. This demonstrates how to integrate Vimeo video playback in a React Native application using the `react-native-webview` library.

#### Resources to Practice Integrating Vimeo Video Playback
1. [Vimeo API Documentation](https://developer.vimeo.com/)
2. [react-native-webview Documentation](https://github.com/react-native-webview/react-native-webview)

### Example 3: Implementing Live Video Streaming with AWS IVS
#### Explanation
AWS Interactive Video Service (IVS) is a managed live streaming solution that enables developers to build live video applications with low latency. AWS IVS provides a scalable infrastructure for live streaming, allowing developers to focus on building engaging user experiences. By integrating AWS IVS, developers can create applications that support live video broadcasts, live events, and real-time video interaction.

In this example, we will create a React Native application that integrates AWS IVS for live video streaming. The example will demonstrate how to set up an AWS IVS channel, stream live video to the channel, and play the live video in the application using the `react-native-video` library.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Video from 'react-native-video';

const App = () => {
  return (
    <View style={styles.container}>
      <Video
        source={{ uri: 'https://d1fz9vkzbkrs3c.cloudfront.net/index.m3u8' }} // Replace with your AWS IVS stream URL
        style={styles.video}
        controls={true}
        resizeMode="contain"
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width: '100%',
    height: 300,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a video player that plays the live stream from the specified AWS IVS stream URL. Users can watch the live video and use the playback controls provided by the video player. This demonstrates how to integrate live video streaming using AWS IVS in a React Native application with the `react-native-video` library.

#### Resources to Practice Implementing Live Video Streaming with AWS IVS
1. [AWS IVS Documentation](https://docs.aws.amazon.com/ivs/)
2. [react-native-video Documentation](https://github.com/react-native-video/react-native-video)

---

### Task 20: Integrate Video Streaming with HLS (HTTP Live Streaming)

#### Overview of HLS (HTTP Live Streaming)
HTTP Live Streaming (HLS) is a protocol developed by Apple to deliver streaming media content over the internet. It works by breaking the overall stream into a sequence of small HTTP-based file downloads, each representing a short segment of the overall stream. This allows for adaptive bitrate streaming, where the client can switch between different quality levels based on current network conditions and performance.

HLS is widely supported across many platforms and devices, making it a popular choice for video streaming. It is particularly useful for live streaming events and on-demand video playback, providing a robust and scalable solution for delivering high-quality video content. HLS also supports features like encryption, closed captions, and alternative audio tracks, enhancing the overall streaming experience.

#### Resources to Learn About HLS
1. [Apple's HTTP Live Streaming (HLS) Documentation](https://developer.apple.com/streaming/)
2. [HLS Overview on Wikipedia](https://en.wikipedia.org/wiki/HTTP_Live_Streaming)

### Example 1: Basic HLS Video Playback
#### Explanation
In this example, we will create a React Native application that plays HLS video streams using the `react-native-video` library. This library provides a comprehensive video component that supports HLS playback, among other features. The example will demonstrate how to set up and play an HLS video stream within a React Native application.

We will embed a video player in the application, configure it to play an HLS stream, and handle basic playback controls. This example covers the fundamental integration of HLS video playback in React Native.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Video from 'react-native-video';

const App = () => {
  return (
    <View style={styles.container}>
      <Video
        source={{ uri: 'https://bitdash-a.akamaihd.net/content/MI201109210084_1/poster.jpg' }} // Replace with your HLS stream URL
        style={styles.video}
        controls={true}
        resizeMode="contain"
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width: '100%',
    height: 300,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a video player that plays the specified HLS stream. Users can watch the video and use the playback controls provided by the video player. This demonstrates how to integrate HLS video playback in a React Native application using the `react-native-video` library.

#### Resources to Practice Basic HLS Video Playback
1. [react-native-video Documentation](https://github.com/react-native-video/react-native-video)
2. [Getting Started with HLS Streaming](https://bitmovin.com/hls-streaming/)

### Example 2: Handling Multiple Bitrates with HLS
#### Explanation
One of the key features of HLS is its support for adaptive bitrate streaming, allowing the video player to switch between different quality levels based on network conditions. In this example, we will extend the basic HLS video playback to handle multiple bitrates. This involves configuring the HLS stream to include different quality levels and ensuring the video player can switch between them seamlessly.

We will use an HLS stream that includes multiple bitrate options, and the `react-native-video` library will handle the adaptive bitrate streaming automatically. This example demonstrates how to set up and test adaptive bitrate streaming in a React Native application.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Video from 'react-native-video';

const App = () => {
  return (
    <View style={styles.container}>
      <Video
        source={{ uri: 'https://bitdash-a.akamaihd.net/content/sintel/hls/playlist.m3u8' }} // Replace with your multi-bitrate HLS stream URL
        style={styles.video}
        controls={true}
        resizeMode="contain"
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width: '100%',
    height: 300,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a video player that plays the specified multi-bitrate HLS stream. Users can watch the video, and the player will automatically switch between different quality levels based on the network conditions. This demonstrates how to implement adaptive bitrate streaming with HLS in a React Native application using the `react-native-video` library.

#### Resources to Practice Handling Multiple Bitrates with HLS
1. [HLS Adaptive Bitrate Streaming Explained](https://bitmovin.com/hls-adaptive-bitrate-streaming/)
2. [Adaptive Streaming with HLS](https://developer.apple.com/documentation/http_live_streaming/about_apple_s_http_live_streaming_tools)

### Example 3: Implementing Live Video Streaming with HLS
#### Explanation
HLS is commonly used for live video streaming, providing a reliable and scalable solution for broadcasting live events. In this example, we will create a React Native application that plays live HLS streams. This involves setting up an HLS live stream and configuring the video player to handle live playback, including features like latency control and live edge seeking.

We will use a live HLS stream URL and the `react-native-video` library to play the live stream. This example demonstrates how to implement live video streaming with HLS in a React Native application, ensuring smooth and low-latency playback for live events.

#### Code
```javascript
// App.js
import React from 'react';
import { View, StyleSheet } from 'react-native';
import Video from 'react-native-video';

const App = () => {
  return (
    <View style={styles.container}>
      <Video
        source={{ uri: 'https://test-streams.mux.dev/x36xhzz/x36xhzz.m3u8' }} // Replace with your live HLS stream URL
        style={styles.video}
        controls={true}
        resizeMode="contain"
        liveBuffer={1.0} // Low latency for live streaming
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width: '100%',
    height: 300,
  },
});

export default App;
```

#### Expected Output
When the app is loaded, it will display a video player that plays the specified live HLS stream. Users can watch the live video, and the player will handle live playback, including low latency and live edge seeking. This demonstrates how to implement live video streaming with HLS in a React Native application using the `react-native-video` library.

#### Resources to Practice Implementing Live Video Streaming with HLS
1. [Live Streaming with HLS](https://developer.apple.com/documentation/http_live_streaming/about_apple_s_http_live_streaming_tools)
2. [react-native-video Documentation](https://github.com/react-native-video/react-native-video)

---
