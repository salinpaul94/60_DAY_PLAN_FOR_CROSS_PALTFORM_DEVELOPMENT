### Task 1: Review and Refactor Project Code for Optimization

Reviewing and refactoring project code for optimization is crucial in ensuring that your React Native application runs efficiently and maintains a high standard of code quality. During the review process, developers examine the existing codebase to identify areas that can be improved in terms of performance, readability, and maintainability. This may involve removing unnecessary code, simplifying complex logic, and ensuring that best practices are followed throughout the project. By doing so, the code becomes easier to understand, debug, and extend, which ultimately leads to a more robust and scalable application.

Refactoring involves systematically improving the code without changing its external behavior. This step is vital for optimizing performance and reducing technical debt. Common refactoring techniques include breaking down large components into smaller, reusable ones, optimizing state management to minimize unnecessary re-renders, and leveraging memoization techniques to avoid redundant computations. By focusing on these areas, developers can enhance the application's responsiveness, reduce load times, and improve overall user experience.

#### Online Resources
1. [Refactoring in React](https://refactoring.guru/refactoring/techniques/react)
2. [Optimizing Performance in React Native](https://reactnative.dev/docs/optimizing-performance)

#### Examples to Practice

1. **Identifying and Removing Unused Code**
2. **Optimizing State Management with `useReducer`**
3. **Implementing Memoization with `React.memo`**

### Example 1: Identifying and Removing Unused Code

Identifying and removing unused code is one of the simplest yet most effective ways to optimize your project. Unused code can increase the bundle size, slow down the application, and make the codebase harder to maintain. Start by using static analysis tools like ESLint to detect unused variables, functions, and imports. Once identified, you can safely remove this dead code to streamline your project.

Additionally, consider using a tool like Webpack's tree-shaking feature to automatically eliminate unused code during the build process. This ensures that only the necessary code is included in the final bundle, reducing load times and improving performance. Regular code reviews and audits can also help in catching and removing unused code before it becomes a significant issue.

#### Online Resources
1. [JavaScript Code Cleanup Techniques](https://www.sitepoint.com/javascript-code-cleanup-techniques/)
2. [Tree Shaking in Webpack](https://webpack.js.org/guides/tree-shaking/)

#### Code to Practice

```javascript
// Before
import React from 'react';
import { View, Text, Button } from 'react-native';

const ExampleComponent = () => {
  const unusedFunction = () => {
    console.log('This function is not used');
  };

  return (
    <View>
      <Text>Hello, World!</Text>
      <Button title="Click me" onPress={() => {}} />
    </View>
  );
};

export default ExampleComponent;

// After
import React from 'react';
import { View, Text, Button } from 'react-native';

const ExampleComponent = () => {
  return (
    <View>
      <Text>Hello, World!</Text>
      <Button title="Click me" onPress={() => {}} />
    </View>
  );
};

export default ExampleComponent;
```

**Expected Output:**

The "Hello, World!" text and a clickable button will be displayed. The unused function is removed, resulting in cleaner and more efficient code.

### Example 2: Optimizing State Management with `useReducer`

Optimizing state management is critical for performance, especially in complex applications. `useReducer` is a hook that is often more suitable than `useState` for managing complex state logic. It provides a way to centralize state updates, making the code easier to read and maintain. By using `useReducer`, you can avoid passing down state and update functions through multiple layers of components, which can lead to performance improvements.

Implementing `useReducer` involves defining a reducer function that specifies how the state should change in response to various actions. This approach is particularly useful for applications with complex state transitions, as it helps in keeping the state logic predictable and organized. Refactoring your state management to use `useReducer` can result in more scalable and maintainable code.

#### Online Resources
1. [Using the useReducer Hook](https://reactjs.org/docs/hooks-reference.html#usereducer)
2. [State Management in React Native](https://reactnative.dev/docs/state-management)

#### Code to Practice

```javascript
import React, { useReducer } from 'react';
import { View, Text, Button } from 'react-native';

const initialState = { count: 0 };

function reducer(state, action) {
  switch (action.type) {
    case 'increment':
      return { count: state.count + 1 };
    case 'decrement':
      return { count: state.count - 1 };
    default:
      throw new Error();
  }
}

const Counter = () => {
  const [state, dispatch] = useReducer(reducer, initialState);

  return (
    <View>
      <Text>Count: {state.count}</Text>
      <Button title="Increment" onPress={() => dispatch({ type: 'increment' })} />
      <Button title="Decrement" onPress={() => dispatch({ type: 'decrement' })} />
    </View>
  );
};

export default Counter;
```

**Expected Output:**

A counter with "Count: 0" displayed initially. Two buttons, "Increment" and "Decrement," will update the count value accordingly.

### Example 3: Implementing Memoization with `React.memo`

Memoization is a technique to optimize performance by caching the results of expensive function calls and reusing the cached result when the same inputs occur again. In React Native, you can use `React.memo` to prevent unnecessary re-renders of functional components when their props have not changed. This can lead to significant performance improvements, especially in components that render frequently or contain complex logic.

To use `React.memo`, wrap your functional component with it. This ensures that the component only re-renders when its props change. Additionally, you can provide a custom comparison function to control when the component should re-render. This level of optimization can help in reducing the rendering workload and improving the overall responsiveness of your application.

#### Online Resources
1. [React.memo](https://reactjs.org/docs/react-api.html#reactmemo)
2. [Performance Optimization with Memoization](https://www.smashingmagazine.com/2020/07/optimizing-react-app-performance/)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text } from 'react-native';

const ExpensiveComponent = React.memo(({ count }) => {
  console.log('Rendering ExpensiveComponent');
  return (
    <View>
      <Text>Count: {count}</Text>
    </View>
  );
});

const ParentComponent = () => {
  const [count, setCount] = React.useState(0);

  return (
    <View>
      <ExpensiveComponent count={count} />
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};

export default ParentComponent;
```

**Expected Output:**

The "ExpensiveComponent" will only re-render when the `count` prop changes, reducing unnecessary renders and optimizing performance. The console will log "Rendering ExpensiveComponent" only when `count` changes.

---

### Task 2: Study Best Practices in React Native Development

Studying best practices in React Native development is essential for building efficient, maintainable, and scalable applications. Best practices encompass a variety of areas, including code organization, component design, performance optimization, and state management. By adhering to these practices, developers can ensure that their code is clean, readable, and easy to debug. Additionally, best practices help in maintaining a consistent coding style across the team, which is crucial for collaborative development.

In React Native, best practices also involve leveraging the framework's capabilities to optimize performance and enhance user experience. This includes using appropriate components, minimizing unnecessary re-renders, and effectively managing resources such as memory and CPU usage. Following these practices not only improves the performance of the application but also contributes to a better end-user experience. Continuous learning and staying updated with the latest trends and techniques in React Native development are key to mastering these best practices.

#### Online Resources
1. [React Native Best Practices](https://medium.com/react-native-training/react-native-best-practices-2018-680d96363e98)
2. [Performance Optimization in React Native](https://reactnative.dev/docs/performance)

#### Examples to Practice

1. **Organizing Components and Folders**
2. **Optimizing Lists with FlatList**
3. **Using Context API for State Management**

### Example 1: Organizing Components and Folders

Organizing components and folders in a React Native project is crucial for maintainability and scalability. A well-structured project makes it easier for developers to navigate the codebase, understand the application's architecture, and collaborate effectively. Common approaches include organizing files by feature or by type. By feature means grouping all related files (components, styles, tests) together, whereas by type means separating files by their role (components, screens, services).

A typical project structure might look like this:
```
project/
├── src/
│   ├── components/
│   ├── screens/
│   ├── services/
│   ├── assets/
│   ├── navigation/
│   ├── App.js
│   ├── index.js
```
Each folder should contain related files, making it easier to locate and manage them. This organization helps in keeping the codebase clean and modular, facilitating easier testing and refactoring.

#### Online Resources
1. [Project Structure Best Practices](https://reactnative.dev/docs/structure)
2. [Scalable React Architecture](https://medium.com/swlh/scalable-architecture-for-react-native-apps-1e065a4af242)

#### Code to Practice

```javascript
// src/components/Button.js
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';

const Button = ({ onPress, title }) => (
  <TouchableOpacity onPress={onPress}>
    <Text>{title}</Text>
  </TouchableOpacity>
);

export default Button;

// src/screens/HomeScreen.js
import React from 'react';
import { View, Text } from 'react-native';
import Button from '../components/Button';

const HomeScreen = ({ navigation }) => (
  <View>
    <Text>Home Screen</Text>
    <Button title="Go to Details" onPress={() => navigation.navigate('Details')} />
  </View>
);

export default HomeScreen;

// src/navigation/AppNavigator.js
import { createAppContainer } from 'react-navigation';
import { createStackNavigator } from 'react-navigation-stack';
import HomeScreen from '../screens/HomeScreen';
import DetailsScreen from '../screens/DetailsScreen';

const AppNavigator = createStackNavigator(
  {
    Home: HomeScreen,
    Details: DetailsScreen,
  },
  {
    initialRouteName: 'Home',
  }
);

export default createAppContainer(AppNavigator);

// src/index.js
import { AppRegistry } from 'react-native';
import AppNavigator from './navigation/AppNavigator';
import { name as appName } from '../app.json';

AppRegistry.registerComponent(appName, () => AppNavigator);
```

**Expected Output:**

A well-organized project structure with separate folders for components, screens, and navigation, making the codebase clean and modular.

### Example 2: Optimizing Lists with FlatList

Optimizing lists in React Native is crucial for performance, especially when dealing with large datasets. The `FlatList` component is designed to handle large lists efficiently by rendering only the visible items and recycling views that are out of view. This approach minimizes memory usage and improves rendering performance. To optimize `FlatList`, ensure you use `keyExtractor` to provide unique keys for each item, and implement `getItemLayout` to define the height of each item, which helps in efficient scrolling.

Another optimization technique involves using the `shouldComponentUpdate` method or `React.memo` to prevent unnecessary re-renders. Additionally, leveraging the `onEndReached` and `onEndReachedThreshold` properties can help in implementing infinite scrolling, allowing the list to load more items as the user scrolls down.

#### Online Resources
1. [FlatList Documentation](https://reactnative.dev/docs/flatlist)
2. [Optimizing FlatList](https://medium.com/react-native-training/flatlist-performance-tips-534c295eb33e)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { FlatList, Text, View } from 'react-native';

const DATA = Array.from({ length: 1000 }, (_, index) => ({
  id: index.toString(),
  title: `Item ${index + 1}`,
}));

const Item = React.memo(({ title }) => (
  <View>
    <Text>{title}</Text>
  </View>
));

const App = () => {
  const [data, setData] = useState(DATA);

  const renderItem = ({ item }) => <Item title={item.title} />;

  return (
    <FlatList
      data={data}
      renderItem={renderItem}
      keyExtractor={(item) => item.id}
      getItemLayout={(data, index) => (
        { length: 50, offset: 50 * index, index }
      )}
    />
  );
};

export default App;
```

**Expected Output:**

A scrollable list displaying 1000 items, with optimized performance due to the efficient use of `FlatList` and memoized item rendering.

### Example 3: Using Context API for State Management

The Context API is a powerful feature in React for managing global state across the application. It allows you to avoid prop drilling by providing a way to pass data through the component tree without having to pass props down manually at every level. This makes state management more efficient and the codebase cleaner. The Context API is ideal for managing global settings, user authentication state, and theme settings.

To use the Context API, you create a context with `React.createContext()` and provide it at a high level in your component tree using the `Provider` component. Components that need access to the context can consume it using the `useContext` hook. This approach simplifies state management and makes the application more scalable and maintainable.

#### Online Resources
1. [Context API Documentation](https://reactjs.org/docs/context.html)
2. [Using Context API in React Native](https://reactnative.dev/docs/context)

#### Code to Practice

```javascript
import React, { createContext, useContext, useState } from 'react';
import { View, Text, Button } from 'react-native';

const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');

  return (
    <ThemeContext.Provider value={{ theme, setTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const ThemedComponent = () => {
  const { theme, setTheme } = useContext(ThemeContext);

  return (
    <View style={{ padding: 20 }}>
      <Text>Current Theme: {theme}</Text>
      <Button title="Toggle Theme" onPress={() => setTheme(theme === 'light' ? 'dark' : 'light')} />
    </View>
  );
};

const App = () => (
  <ThemeProvider>
    <ThemedComponent />
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen displaying the current theme (either 'light' or 'dark') and a button to toggle the theme. The theme state is managed globally using the Context API, making the application more maintainable.

---

### Task 3: Implement Best Practices in Your Project

Implementing best practices in a React Native project ensures that your application is not only performant but also maintainable and scalable. Best practices span across various areas including code organization, state management, performance optimization, and testing. By following these practices, you can create a robust and user-friendly application that adheres to industry standards. Ensuring that your codebase is well-structured, readable, and efficient helps in reducing technical debt and facilitates easier debugging and feature enhancements.

Furthermore, best practices involve leveraging React Native's features to their fullest potential. This includes using appropriate components, optimizing rendering processes, and employing efficient state management techniques. Keeping up with the latest developments in the React Native ecosystem and incorporating modern practices can significantly enhance the quality and performance of your application.

#### Online Resources
1. [React Native Best Practices](https://medium.com/react-native-training/react-native-best-practices-2018-680d96363e98)
2. [Performance Optimization in React Native](https://reactnative.dev/docs/performance)

#### Examples to Practice

1. **Code Splitting and Lazy Loading**
2. **Optimizing Redux for State Management**
3. **Implementing Efficient Animations**

### Example 1: Code Splitting and Lazy Loading

Code splitting and lazy loading are techniques used to improve the performance of a React Native application by loading only the necessary code at the right time. This approach helps in reducing the initial load time and improving the overall responsiveness of the app. Code splitting involves breaking down the application into smaller chunks, which can be loaded on demand. Lazy loading, on the other hand, defers the loading of these chunks until they are needed.

React Native's `React.lazy` and `Suspense` components provide built-in support for lazy loading. By wrapping dynamically imported components with `React.lazy` and using `Suspense` to display a fallback UI while the component is being loaded, you can enhance the user experience. This is particularly useful for large applications where loading all components at once would be inefficient.

#### Online Resources
1. [Lazy Loading in React Native](https://reactjs.org/docs/code-splitting.html#reactlazy)
2. [Optimizing Performance with Code Splitting](https://medium.com/@kasperdebruijn/how-to-improve-your-react-app-performance-with-code-splitting-2ec1c798e3ea)

#### Code to Practice

```javascript
import React, { Suspense } from 'react';
import { View, Text } from 'react-native';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

const App = () => (
  <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
    <Text>App Component</Text>
    <Suspense fallback={<Text>Loading...</Text>}>
      <LazyComponent />
    </Suspense>
  </View>
);

export default App;

// LazyComponent.js
import React from 'react';
import { View, Text } from 'react-native';

const LazyComponent = () => (
  <View style={{ padding: 20 }}>
    <Text>Lazy Loaded Component</Text>
  </View>
);

export default LazyComponent;
```

**Expected Output:**

The "App Component" text is displayed immediately. The "Lazy Loaded Component" text is displayed after the lazy-loaded component has finished loading, with "Loading..." shown during the load.

### Example 2: Optimizing Redux for State Management

Optimizing Redux for state management involves structuring your Redux store and actions efficiently to minimize unnecessary re-renders and ensure that state updates are handled smoothly. This includes normalizing the state to avoid deeply nested structures, which can complicate state updates and lead to performance issues. Additionally, using middleware like `redux-thunk` or `redux-saga` can help manage side effects and asynchronous actions more effectively.

Another key practice is to leverage the `useSelector` hook and `memoization` to prevent unnecessary re-renders. The `useSelector` hook allows you to extract data from the Redux store and memoization ensures that components only re-render when the relevant slice of the state changes. This combination can significantly enhance the performance and responsiveness of your application.

#### Online Resources
1. [Optimizing Redux](https://redux.js.org/recipes/structuring-reducers/optimizing-reducer-performance)
2. [Using Redux with React Native](https://reactnative.dev/docs/redux)

#### Code to Practice

```javascript
// store.js
import { createStore, applyMiddleware } from 'redux';
import thunk from 'redux-thunk';

const initialState = { count: 0 };

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'INCREMENT':
      return { ...state, count: state.count + 1 };
    case 'DECREMENT':
      return { ...state, count: state.count - 1 };
    default:
      return state;
  }
};

const store = createStore(reducer, applyMiddleware(thunk));

export default store;

// CounterComponent.js
import React from 'react';
import { useSelector, useDispatch } from 'react-redux';
import { View, Text, Button } from 'react-native';

const CounterComponent = () => {
  const count = useSelector((state) => state.count);
  const dispatch = useDispatch();

  return (
    <View style={{ padding: 20 }}>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => dispatch({ type: 'INCREMENT' })} />
      <Button title="Decrement" onPress={() => dispatch({ type: 'DECREMENT' })} />
    </View>
  );
};

export default CounterComponent;

// App.js
import React from 'react';
import { Provider } from 'react-redux';
import store from './store';
import CounterComponent from './CounterComponent';

const App = () => (
  <Provider store={store}>
    <CounterComponent />
  </Provider>
);

export default App;
```

**Expected Output:**

A counter with "Count: 0" displayed initially. Two buttons, "Increment" and "Decrement," will update the count value accordingly. The state management is optimized for performance using Redux.

### Example 3: Implementing Efficient Animations

Implementing efficient animations in React Native involves using libraries and techniques that provide smooth and performant animations without impacting the overall performance of the application. The `react-native-reanimated` library is a powerful tool for creating complex animations in a declarative way. It leverages native drivers to ensure that animations run smoothly, even on lower-end devices.

To implement efficient animations, you should avoid using the JavaScript thread for heavy computations and instead offload these tasks to the native thread. This can be achieved using `useSharedValue` and `useAnimatedStyle` hooks provided by `react-native-reanimated`. These hooks allow you to define animations that run entirely on the native side, resulting in better performance and responsiveness.

#### Online Resources
1. [Reanimated 2 Documentation](https://docs.swmansion.com/react-native-reanimated/)
2. [Creating Smooth Animations in React Native](https://blog.bitsrc.io/creating-smooth-animations-in-react-native-using-reanimated-2-8b57c5a56f94)

#### Code to Practice

```javascript
import React from 'react';
import { View, Button } from 'react-native';
import Animated, { useSharedValue, useAnimatedStyle, withTiming } from 'react-native-reanimated';

const App = () => {
  const opacity = useSharedValue(1);

  const animatedStyle = useAnimatedStyle(() => {
    return {
      opacity: opacity.value,
    };
  });

  const toggleOpacity = () => {
    opacity.value = withTiming(opacity.value === 1 ? 0 : 1, {
      duration: 500,
    });
  };

  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Animated.View style={[{ width: 100, height: 100, backgroundColor: 'blue' }, animatedStyle]} />
      <Button title="Toggle Opacity" onPress={toggleOpacity} />
    </View>
  );
};

export default App;
```

**Expected Output:**

A blue box with an initial opacity of 1. When the "Toggle Opacity" button is pressed, the opacity of the box toggles between 1 and 0 with a smooth transition, showcasing efficient animation using `react-native-reanimated`.

---

### Task 4: Study Component Libraries

Component libraries are essential tools in React Native development, providing pre-built, reusable components that help speed up the development process and ensure consistency across the application. By using these libraries, developers can focus on implementing business logic rather than reinventing the wheel for common UI elements. Popular component libraries for React Native include React Native Elements, NativeBase, and React Native Paper. These libraries offer a wide range of components such as buttons, cards, forms, and navigation tools, all designed to work seamlessly across different platforms.

Studying component libraries involves understanding how to integrate them into your project, customizing the components to match your application's design, and leveraging their features to enhance the user experience. Additionally, it is important to stay updated with the latest versions of these libraries to benefit from new features, bug fixes, and performance improvements. By mastering the use of component libraries, developers can build high-quality, responsive, and visually appealing applications efficiently.

#### Online Resources
1. [React Native Elements Documentation](https://reactnativeelements.com/docs/)
2. [NativeBase Documentation](https://docs.nativebase.io/)

#### Examples to Practice

1. **Using React Native Elements for Basic UI Components**
2. **Creating a Themed Application with NativeBase**
3. **Implementing Material Design with React Native Paper**

### Example 1: Using React Native Elements for Basic UI Components

React Native Elements is a popular UI toolkit that provides a set of customizable components for React Native applications. It simplifies the process of creating common UI elements like buttons, cards, and input fields, allowing developers to focus on building the core functionality of their apps. The library is highly customizable, making it easy to match the components with your application's design.

To use React Native Elements, you need to install the library and import the necessary components into your project. You can then customize these components by using props and styles. This approach helps in maintaining a consistent design across your application and speeds up the development process.

#### Online Resources
1. [Getting Started with React Native Elements](https://reactnativeelements.com/docs/getting_started)
2. [React Native Elements GitHub Repository](https://github.com/react-native-elements/react-native-elements)

#### Code to Practice

```javascript
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Button, Card, Input } from 'react-native-elements';

const App = () => (
  <View style={styles.container}>
    <Card>
      <Card.Title>React Native Elements</Card.Title>
      <Card.Divider />
      <Input placeholder="Enter text" />
      <Button title="Submit" />
    </Card>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
});

export default App;
```

**Expected Output:**

A card component with a title, an input field, and a submit button, styled using React Native Elements.

### Example 2: Creating a Themed Application with NativeBase

NativeBase is a component library that provides a rich set of customizable components and themes for React Native applications. It allows developers to quickly build consistent and attractive user interfaces by offering pre-designed components that adhere to best design practices. NativeBase also supports theming, making it easy to apply a consistent look and feel across your entire application.

To create a themed application with NativeBase, you need to install the library and wrap your root component with the NativeBase `Provider` component. This enables you to apply a global theme to all NativeBase components in your application. You can customize the theme by modifying the default theme object or creating a new one from scratch.

#### Online Resources
1. [NativeBase Getting Started Guide](https://docs.nativebase.io/docs/GettingStarted)
2. [NativeBase Theming](https://docs.nativebase.io/docs/Theming)

#### Code to Practice

```javascript
import React from 'react';
import { View } from 'react-native';
import { NativeBaseProvider, Box, Button, Input } from 'native-base';

const App = () => (
  <NativeBaseProvider>
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center', padding: 20 }}>
      <Box alignItems="center">
        <Input placeholder="Enter text" width="75%" mb={5} />
        <Button>Submit</Button>
      </Box>
    </View>
  </NativeBaseProvider>
);

export default App;
```

**Expected Output:**

A simple form with an input field and a submit button, styled using NativeBase's default theme.

### Example 3: Implementing Material Design with React Native Paper

React Native Paper is a library that provides a collection of customizable components implementing Google's Material Design guidelines. It helps developers create visually appealing and user-friendly interfaces that adhere to Material Design principles. React Native Paper includes components like buttons, cards, dialogs, and text inputs, all designed to work seamlessly across platforms.

To implement Material Design with React Native Paper, you need to install the library and wrap your root component with the Paper `Provider` component. This enables you to use and customize the components provided by the library. You can also use the Paper `Theme` object to apply global styles and ensure consistency across your application.

#### Online Resources
1. [React Native Paper Documentation](https://callstack.github.io/react-native-paper/getting-started.html)
2. [Material Design Guidelines](https://material.io/design)

#### Code to Practice

```javascript
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Provider as PaperProvider, Button, Card, TextInput } from 'react-native-paper';

const App = () => (
  <PaperProvider>
    <View style={styles.container}>
      <Card>
        <Card.Title title="React Native Paper" />
        <Card.Content>
          <TextInput label="Enter text" mode="outlined" />
          <Button mode="contained" style={styles.button}>Submit</Button>
        </Card.Content>
      </Card>
    </View>
  </PaperProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
  button: {
    marginTop: 10,
  },
});

export default App;
```

**Expected Output:**

A card component with a title, an outlined text input, and a contained button, styled using React Native Paper's Material Design components.

---

### Task5: Use React Native Elements for UI Components

React Native Elements is a popular library that provides a set of customizable and easy-to-use UI components for React Native applications. This library helps developers quickly create visually appealing interfaces by offering pre-built components such as buttons, input fields, cards, and more. By using React Native Elements, you can ensure consistency across your application’s UI and speed up the development process by leveraging these ready-made components.

The library also offers extensive customization options, allowing you to tailor the components to fit your design requirements. You can easily modify the appearance of components through props and styles, making it straightforward to integrate them into your application's existing theme. Additionally, React Native Elements is well-maintained and has a strong community, providing ample resources and support for developers.

#### Online Resources
1. [React Native Elements Documentation](https://reactnativeelements.com/docs/)
2. [Getting Started with React Native Elements](https://reactnativeelements.com/docs/getting_started)

#### Examples to Practice

1. **Creating a Simple Form**
2. **Building a Card-Based Layout**
3. **Customizing Buttons and Inputs**

### Example 1: Creating a Simple Form

Creating a simple form using React Native Elements involves combining several components such as `Input`, `Button`, and `Form` to build a user-friendly form interface. These components are designed to be easily integrated and styled, making it straightforward to create forms for user input. The `Input` component provides a consistent look and feel for text input fields, while the `Button` component offers customizable buttons for form submission.

To create a simple form, you need to install React Native Elements and import the required components. Then, you can arrange these components within a `View` or `Form` container and style them as needed. This example demonstrates how to create a basic user registration form with input fields for username, email, and password, along with a submit button.

#### Online Resources
1. [React Native Elements Input Component](https://reactnativeelements.com/docs/input/)
2. [React Native Elements Button Component](https://reactnativeelements.com/docs/button/)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Input, Button } from 'react-native-elements';

const RegistrationForm = () => {
  const [username, setUsername] = useState('');
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleSubmit = () => {
    // Handle form submission logic
    console.log('Form submitted', { username, email, password });
  };

  return (
    <View style={styles.container}>
      <Input
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
        leftIcon={{ type: 'font-awesome', name: 'user' }}
      />
      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        leftIcon={{ type: 'font-awesome', name: 'envelope' }}
      />
      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        leftIcon={{ type: 'font-awesome', name: 'lock' }}
      />
      <Button title="Register" onPress={handleSubmit} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
});

export default RegistrationForm;
```

**Expected Output:**

A simple registration form with input fields for username, email, and password, and a submit button. The form will log the input values to the console upon submission.

### Example 2: Building a Card-Based Layout

Building a card-based layout using React Native Elements involves using the `Card` component to organize content into visually distinct sections. The `Card` component provides a consistent look for displaying grouped content, such as user profiles, product information, or article previews. By leveraging this component, you can create a clean and organized layout that enhances the user experience.

To create a card-based layout, you can import the `Card` component from React Native Elements and use it to wrap different pieces of content. This example demonstrates how to create a profile card with a user's avatar, name, and a brief bio. The card will also include buttons for actions such as following or messaging the user.

#### Online Resources
1. [React Native Elements Card Component](https://reactnativeelements.com/docs/card/)
2. [Building Card Layouts with React Native Elements](https://reactnativeelements.com/docs/card/#content)

#### Code to Practice

```javascript
import React from 'react';
import { View, StyleSheet } from 'react-native';
import { Card, Button, Avatar } from 'react-native-elements';

const ProfileCard = () => {
  return (
    <View style={styles.container}>
      <Card>
        <Card.Title>John Doe</Card.Title>
        <Card.Divider />
        <View style={styles.cardContent}>
          <Avatar
            rounded
            size="large"
            source={{ uri: 'https://example.com/avatar.jpg' }}
          />
          <Card.Title>John Doe</Card.Title>
          <Card.FeaturedSubtitle>Software Engineer</Card.FeaturedSubtitle>
          <Button title="Follow" style={styles.button} />
          <Button title="Message" type="outline" style={styles.button} />
        </View>
      </Card>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  cardContent: {
    alignItems: 'center',
  },
  button: {
    marginTop: 10,
    width: 200,
  },
});

export default ProfileCard;
```

**Expected Output:**

A profile card displaying the user's avatar, name, job title, and buttons for following and messaging. The card layout is clean and visually distinct, enhancing the overall user experience.

### Example 3: Customizing Buttons and Inputs

Customizing buttons and inputs in React Native Elements allows you to tailor these components to match your application's design requirements. The `Button` and `Input` components are highly customizable, enabling you to modify their appearance and behavior through various props. This flexibility ensures that your UI components align with your branding and design guidelines.

To customize buttons and inputs, you can use props such as `buttonStyle`, `titleStyle`, `inputStyle`, and `containerStyle`. These props allow you to apply custom styles to the components, such as changing colors, adjusting padding, or modifying font styles. This example demonstrates how to create a custom-styled login form with personalized buttons and input fields.

#### Online Resources
1. [Customizing React Native Elements Components](https://reactnativeelements.com/docs/customization/)
2. [Button Component Customization](https://reactnativeelements.com/docs/button/#styling)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { View, StyleSheet } from 'react-native';
import { Input, Button } from 'react-native-elements';

const LoginForm = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');

  const handleLogin = () => {
    // Handle login logic
    console.log('Logging in with', { email, password });
  };

  return (
    <View style={styles.container}>
      <Input
        placeholder="Email"
        value={email}
        onChangeText={setEmail}
        leftIcon={{ type: 'font-awesome', name: 'envelope' }}
        inputStyle={styles.input}
        containerStyle={styles.inputContainer}
      />
      <Input
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
        leftIcon={{ type: 'font-awesome', name: 'lock' }}
        inputStyle={styles.input}
        containerStyle={styles.inputContainer}
      />
      <Button
        title="Login"
        onPress={handleLogin}
        buttonStyle={styles.button}
        titleStyle={styles.buttonTitle}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 20,
  },
  input: {
    color: '#000',
  },
  inputContainer: {
    marginBottom: 20,
  },
  button: {
    backgroundColor: '#007BFF',
  },
  buttonTitle: {
    color: '#FFF',
  },
});

export default LoginForm;
```

**Expected Output:**

A custom-styled login form with input fields for email and password, and a login button. The input fields and button are styled according to the specified custom styles, providing a unique and branded look.

---

### Task 6: Study Design Systems

Design systems are comprehensive guidelines that standardize the design and development process across an organization or project. They include a collection of reusable components, patterns, and styles that ensure consistency and coherence in the user interface. By providing a unified language and set of principles, design systems help teams collaborate more effectively and maintain a consistent look and feel across different parts of an application or multiple applications.

In React Native development, adopting a design system can significantly improve the efficiency and quality of your project. It allows developers to reuse components and follow established patterns, reducing the time needed to create new features and ensuring that the application's design remains uniform. Moreover, design systems can evolve over time, incorporating feedback and new requirements, making them a living document that grows with your project.

#### Online Resources
1. [Introduction to Design Systems](https://www.smashingmagazine.com/2018/11/guide-design-systems/)
2. [Design Systems in React Native](https://blog.bitsrc.io/building-a-design-system-with-react-native-27b47b99a46b)

#### Examples to Practice

1. **Creating a Design System with Styled Components**
2. **Implementing a Design System in a React Native Project**
3. **Customizing a Design System**

### Example 1: Creating a Design System with Styled Components

Styled Components is a library for React and React Native that allows you to write CSS-in-JS, enabling you to style your components directly within your JavaScript code. This approach is particularly useful for creating design systems, as it allows you to define and manage styles in a centralized and modular manner. By using Styled Components, you can create a consistent and reusable set of styles and components that adhere to your design system's guidelines.

To create a design system with Styled Components, start by defining basic UI components such as buttons, text inputs, and containers. These components should be styled according to your design guidelines and made reusable throughout your application. This example demonstrates how to create a simple design system with a button and a container component.

#### Online Resources
1. [Styled Components Documentation](https://styled-components.com/docs)
2. [Creating Design Systems with Styled Components](https://blog.bitsrc.io/creating-design-systems-with-styled-components-1002cfa93b57)

#### Code to Practice

```javascript
import React from 'react';
import styled from 'styled-components/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f8f9fa;
  padding: 20px;
`;

const Button = styled.TouchableOpacity`
  background-color: #007bff;
  padding: 10px 20px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #fff;
  font-size: 16px;
`;

const App = () => (
  <Container>
    <Button>
      <ButtonText>Press Me</ButtonText>
    </Button>
  </Container>
);

export default App;
```

**Expected Output:**

A screen with a centered button that has a consistent style defined by the design system, including a blue background and white text.

### Example 2: Implementing a Design System in a React Native Project

Implementing a design system in a React Native project involves integrating the predefined components and styles into your application's architecture. This ensures that all UI elements adhere to the design guidelines, promoting a cohesive and professional look across the entire application. By systematically applying the design system, you can streamline development and improve maintainability.

To implement a design system, start by organizing your components and styles in a centralized directory. This directory should contain all the reusable components, such as buttons, inputs, and layouts, styled according to the design system. This example demonstrates how to structure a simple design system and use it within a React Native project.

#### Online Resources
1. [Building Design Systems with React Native](https://medium.com/swlh/building-a-design-system-with-react-native-27b47b99a46b)
2. [Using Design Systems in React Native](https://blog.bitsrc.io/using-design-systems-in-react-native-6c88b705841f)

#### Code to Practice

```javascript
// components/Container.js
import styled from 'styled-components/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f8f9fa;
  padding: 20px;
`;

export default Container;

// components/Button.js
import React from 'react';
import styled from 'styled-components/native';

const ButtonContainer = styled.TouchableOpacity`
  background-color: #007bff;
  padding: 10px 20px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #fff;
  font-size: 16px;
`;

const Button = ({ title, onPress }) => (
  <ButtonContainer onPress={onPress}>
    <ButtonText>{title}</ButtonText>
  </ButtonContainer>
);

export default Button;

// App.js
import React from 'react';
import Container from './components/Container';
import Button from './components/Button';

const App = () => (
  <Container>
    <Button title="Press Me" onPress={() => alert('Button Pressed!')} />
  </Container>
);

export default App;
```

**Expected Output:**

A screen with a centered button styled according to the design system. The button will display an alert message when pressed, demonstrating the use of reusable components.

### Example 3: Customizing a Design System

Customizing a design system involves extending or modifying the predefined components and styles to better fit specific project requirements. This might include changing colors, typography, or spacing to align with a brand's identity. Customization ensures that while the design system provides a consistent base, it remains flexible enough to accommodate unique needs.

To customize a design system, you can create a theme object that defines the styles and values you want to apply across your components. This theme object can be passed to a `ThemeProvider` to make the styles accessible throughout your application. This example demonstrates how to create a custom theme and apply it to your components.

#### Online Resources
1. [Customizing Design Systems](https://uxdesign.cc/customizing-design-systems-5b61b3926b5e)
2. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)

#### Code to Practice

```javascript
import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

const theme = {
  colors: {
    primary: '#4CAF50',
    background: '#f5f5f5',
    text: '#333',
    buttonText: '#fff',
  },
  spacing: {
    padding: '10px',
    margin: '10px',
  },
  fontSize: {
    large: '18px',
    medium: '16px',
    small: '14px',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: ${(props) => props.theme.spacing.padding};
`;

const Button = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.primary};
  padding: ${(props) => props.theme.spacing.padding};
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSize.medium};
`;

const App = () => (
  <ThemeProvider theme={theme}>
    <Container>
      <Button>
        <ButtonText>Press Me</ButtonText>
      </Button>
    </Container>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen with a button styled according to the custom theme, featuring a green background and white text. The container background and other styling properties are also derived from the theme, ensuring a consistent look.

---

### Task 7: Implement a Design System in Your App

Implementing a design system in your React Native app involves integrating a cohesive set of design guidelines, reusable components, and standardized styles. This process ensures consistency across the user interface, improving both the user experience and the maintainability of the codebase. A well-implemented design system allows for quicker development, as components can be reused and customized easily, reducing the need to rewrite code for each new feature.

To start implementing a design system, you need to establish a central theme that defines the visual elements such as colors, typography, and spacing. This theme is then applied consistently across all components. Libraries such as Styled Components and design system frameworks like Material UI can assist in creating and managing these themes effectively. By centralizing the styling logic, you can make global changes easily and ensure that all parts of the application adhere to the same design principles.

#### Online Resources
1. [Creating a Design System with React and Styled Components](https://css-tricks.com/building-a-design-system-in-react-with-styled-components/)
2. [Design Systems in React Native](https://medium.com/@bootstragram/building-design-systems-in-react-native-764cc08b8b34)

#### Examples to Practice

1. **Defining a Theme with Styled Components**
2. **Creating Reusable Components**
3. **Applying the Design System in a React Native App**

### Example 1: Defining a Theme with Styled Components

Defining a theme with Styled Components is the first step in implementing a design system. A theme is a centralized object that contains all the design tokens such as colors, font sizes, and spacing units. This object can be passed down through a `ThemeProvider` to ensure that all styled components in your app adhere to the defined theme.

To define a theme, create a theme object with the necessary design tokens and wrap your application in a `ThemeProvider`. This example demonstrates how to set up a basic theme and apply it to components using Styled Components.

#### Online Resources
1. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)
2. [Creating a Design System with Styled Components](https://www.smashingmagazine.com/2020/01/creating-design-system-react/)

#### Code to Practice

```javascript
import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: ${(props) => props.theme.spacing.medium};
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const App = () => (
  <ThemeProvider theme={theme}>
    <Container>
      <ThemedButton>
        <ButtonText>Press Me</ButtonText>
      </ThemedButton>
    </Container>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen with a button that follows the defined theme, including colors and spacing. The theme ensures consistency across the UI components.

### Example 2: Creating Reusable Components

Creating reusable components is essential for maintaining a consistent design and improving development efficiency. Reusable components are designed to be flexible and adaptable, allowing them to be used in various parts of your application without modification. These components should adhere to the design system and leverage the theme for styling.

To create reusable components, define them in a way that allows customization through props while maintaining a consistent appearance. This example demonstrates how to create a reusable button component that can be easily customized and reused across the application.

#### Online Resources
1. [Building Reusable Components in React](https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0)
2. [Reusable Components with Styled Components](https://styled-components.com/docs/basics#styling-any-component)

#### Code to Practice

```javascript
import React from 'react';
import styled from 'styled-components/native';

const ButtonContainer = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
  align-items: center;
  margin: ${(props) => props.theme.spacing.small};
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const Button = ({ title, onPress, style }) => (
  <ButtonContainer onPress={onPress} style={style}>
    <ButtonText>{title}</ButtonText>
  </ButtonContainer>
);

export default Button;

// App.js
import React from 'react';
import { ThemeProvider } from 'styled-components/native';
import { View, StyleSheet } from 'react-native';
import Button from './Button';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
};

const App = () => (
  <ThemeProvider theme={theme}>
    <View style={styles.container}>
      <Button title="Button 1" onPress={() => alert('Button 1 pressed')} />
      <Button title="Button 2" onPress={() => alert('Button 2 pressed')} />
    </View>
  </ThemeProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 20,
  },
});

export default App;
```

**Expected Output:**

A screen with two buttons that follow the same styling rules, demonstrating the reusability and consistency of the components.

### Example 3: Applying the Design System in a React Native App

Applying the design system in a React Native app involves integrating the predefined theme and reusable components throughout the entire application. This ensures that all parts of the app adhere to the same design principles, providing a cohesive and professional user experience. By consistently applying the design system, you can also make global updates easily, as changes to the theme will automatically propagate to all components.

To apply the design system, ensure that your app is wrapped with the `ThemeProvider` and that all components use the theme for styling. This example demonstrates how to apply the design system to a simple app with multiple screens, showcasing the consistency and ease of maintenance that the design system provides.

#### Online Resources
1. [Applying Design Systems in React Native](https://blog.bitsrc.io/using-design-systems-in-react-native-6c88b705841f)
2. [Managing Global Styles with ThemeProvider](https://styled-components.com/docs/advanced#theming)

#### Code to Practice

```javascript
// themes.js
export const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
};

// Button.js
import React from 'react';
import styled from 'styled-components/native';

const ButtonContainer = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
  align-items: center;
  margin: ${(props) => props.theme.spacing.small};
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const Button = ({ title, onPress, style }) => (
  <ButtonContainer onPress={onPress} style={style}>
    <ButtonText>{title}</ButtonText>
  </ButtonContainer>
);

export default Button;

// ScreenOne.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Button from './Button';

const ScreenOne = ({ navigation }) => (
  <View style={styles.container}>
    <Text>Screen One</Text>
    <Button title="Go to Screen Two" onPress={() => navigation.navigate('ScreenTwo')} />
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default ScreenOne

;

// ScreenTwo.js
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Button from './Button';

const ScreenTwo = ({ navigation }) => (
  <View style={styles.container}>
    <Text>Screen Two</Text>
    <Button title="Go to Screen One" onPress={() => navigation.navigate('ScreenOne')} />
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default ScreenTwo;

// App.js
import React from 'react';
import { ThemeProvider } from 'styled-components/native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';
import ScreenOne from './ScreenOne';
import ScreenTwo from './ScreenTwo';
import { theme } from './themes';

const Stack = createStackNavigator();

const App = () => (
  <ThemeProvider theme={theme}>
    <NavigationContainer>
      <Stack.Navigator initialRouteName="ScreenOne">
        <Stack.Screen name="ScreenOne" component={ScreenOne} />
        <Stack.Screen name="ScreenTwo" component={ScreenTwo} />
      </Stack.Navigator>
    </NavigationContainer>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A navigable app with two screens, each following the same design principles and styling defined by the theme. The design system ensures consistency across different parts of the application.

---

### Task 8: Study Theming and Styling

Theming and styling in React Native are essential for creating visually consistent and appealing user interfaces. Theming involves defining a set of design guidelines, such as colors, typography, and spacing, which can be applied across the entire application. This helps in maintaining a consistent look and feel throughout the app. Styling, on the other hand, involves applying these themes to individual components using various methods such as inline styles, StyleSheet, and CSS-in-JS libraries like Styled Components. By effectively managing theming and styling, developers can ensure that their applications not only look great but also provide a cohesive user experience.

React Native offers multiple approaches to theming and styling, including built-in StyleSheet for defining styles and third-party libraries like Styled Components for more advanced theming capabilities. StyleSheet allows developers to create and reuse styles across components, promoting a modular and maintainable codebase. Styled Components, however, provide a more dynamic approach by allowing styles to be defined directly within components, making it easier to manage complex theming requirements. Understanding and utilizing these tools effectively is crucial for building professional and scalable React Native applications.

#### Online Resources
1. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)
2. [React Native Styling Cheatsheet](https://github.com/vhpoet/react-native-styling-cheat-sheet)

#### Examples to Practice

1. **Applying Themes with StyleSheet**
2. **Dynamic Theming with Styled Components**
3. **Responsive Styling in React Native**

### Example 1: Applying Themes with StyleSheet

Using StyleSheet in React Native allows you to define and apply consistent styles across your application. By creating a centralized theme object, you can ensure that all components adhere to the same design guidelines, promoting a uniform look and feel. This example demonstrates how to create a theme object and apply it to different components using StyleSheet.

To apply themes with StyleSheet, start by defining a theme object that contains the design tokens such as colors, font sizes, and spacing. Then, create styles using StyleSheet and apply these styles to your components. This approach ensures that any changes to the theme are propagated throughout the application, making it easier to maintain a consistent design.

#### Online Resources
1. [React Native StyleSheet Documentation](https://reactnative.dev/docs/stylesheet)
2. [Using StyleSheet in React Native](https://www.digitalocean.com/community/tutorials/react-react-native-stylesheet)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    buttonBackground: '#6200ee',
    buttonText: '#ffffff',
  },
  fontSizes: {
    small: 12,
    medium: 16,
    large: 20,
  },
  spacing: {
    small: 8,
    medium: 16,
    large: 24,
  },
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: theme.colors.background,
    padding: theme.spacing.medium,
  },
  text: {
    color: theme.colors.text,
    fontSize: theme.fontSizes.large,
    marginBottom: theme.spacing.medium,
  },
  button: {
    backgroundColor: theme.colors.buttonBackground,
    padding: theme.spacing.medium,
    borderRadius: 5,
  },
  buttonText: {
    color: theme.colors.buttonText,
    fontSize: theme.fontSizes.medium,
  },
});

const App = () => (
  <View style={styles.container}>
    <Text style={styles.text}>Hello, World!</Text>
    <View style={styles.button}>
      <Text style={styles.buttonText}>Press Me</Text>
    </View>
  </View>
);

export default App;
```

**Expected Output:**

A screen with a text message "Hello, World!" and a button styled according to the theme, demonstrating how to use StyleSheet for theming.

### Example 2: Dynamic Theming with Styled Components

Styled Components provide a powerful way to apply dynamic theming in React Native applications. This library allows you to define and manage styles within your components, making it easier to create and apply themes dynamically. By using the `ThemeProvider`, you can pass a theme object to your entire component tree, ensuring that all components use the same design tokens.

To implement dynamic theming, define a theme object and wrap your application with the `ThemeProvider` from Styled Components. Then, create styled components that use the theme for styling. This example demonstrates how to set up dynamic theming with Styled Components, allowing for easy customization and consistency across the application.

#### Online Resources
1. [Styled Components Documentation](https://styled-components.com/docs)
2. [Dynamic Theming with Styled Components](https://dev.to/danielleye/react-dynamic-theming-with-styled-components-3ea)

#### Code to Practice

```javascript
import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: ${(props) => props.theme.spacing.medium};
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const App = () => (
  <ThemeProvider theme={theme}>
    <Container>
      <ThemedButton>
        <ButtonText>Press Me</ButtonText>
      </ThemedButton>
    </Container>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen with a button styled according to the theme using Styled Components, demonstrating dynamic theming capabilities.

### Example 3: Responsive Styling in React Native

Responsive styling is crucial for creating applications that work well on various screen sizes and orientations. React Native provides several tools and techniques for implementing responsive designs, including Flexbox, Dimensions API, and media queries with libraries like `react-native-media-queries`. By leveraging these tools, you can create layouts that adapt to different screen sizes, ensuring a consistent user experience across devices.

To implement responsive styling, use Flexbox for layout management and the Dimensions API to get screen dimensions dynamically. You can also use media queries to apply different styles based on the device's characteristics. This example demonstrates how to create a responsive layout using Flexbox and media queries.

#### Online Resources
1. [React Native Flexbox](https://reactnative.dev/docs/flexbox)
2. [Building Responsive Layouts in React Native](https://medium.com/react-native-training/building-responsive-layouts-in-react-native-79d67b4b8b0a)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';

const { width, height } = Dimensions.get('window');

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: '#f2f2f2',
  },
  box: {
    width: width * 0.8,
    height: height * 0.2,
    backgroundColor: '#6200ee',
    justifyContent: 'center',
    alignItems: 'center',
    marginBottom: 20,
  },
  text: {
    color: '#ffffff',
    fontSize: 16,
  },
});

const App = () => (
  <View style={styles.container}>
    <View style={styles.box}>
      <Text style={styles.text}>Responsive Box 1</Text>
    </View>
    <View style={styles.box}>
      <Text style={styles.text}>Responsive Box 2</Text>
    </View>
  </View>
);

export default App;
```

**Expected Output:**

A screen with two responsive boxes that adapt their size based on the screen dimensions, demonstrating responsive styling in React Native.

---

### Task 9: Implement Dynamic Theming with Styled Components

Dynamic theming with Styled Components allows you to create flexible and customizable themes that can change based on user preferences or other criteria. Styled Components is a popular library for styling in React and React Native that enables you to write CSS directly in your JavaScript files, providing a powerful and intuitive way to manage styles. By using `ThemeProvider` from Styled Components, you can define a theme object that holds your design tokens, such as colors, fonts, and spacing, and apply it across your entire application.

Dynamic theming is particularly useful for applications that need to support multiple themes, such as light and dark modes. You can create different theme objects and switch between them based on user preferences or system settings. This approach ensures that your application maintains a consistent look and feel while providing the flexibility to adapt to different themes dynamically.

#### Online Resources
1. [Styled Components Theming Documentation](https://styled-components.com/docs/advanced#theming)
2. [Dynamic Theming with Styled Components](https://dev.to/danielleye/react-dynamic-theming-with-styled-components-3ea)

#### Examples to Practice

1. **Basic Theme Implementation**
2. **Switching Between Light and Dark Themes**
3. **Persisting User Theme Preference**

### Example 1: Basic Theme Implementation

In this example, you will learn how to set up a basic theme with Styled Components and apply it to your React Native application. The `ThemeProvider` component is used to pass the theme object to all styled components in the component tree. This ensures that all components adhere to the design tokens defined in the theme.

To implement a basic theme, define a theme object containing your design tokens, such as colors and font sizes. Wrap your application with the `ThemeProvider` and create styled components that use the theme for styling. This example demonstrates how to create a simple theme and apply it to a button component.

#### Online Resources
1. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)
2. [Styled Components Documentation](https://styled-components.com/docs)

#### Code to Practice

```javascript
import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: ${(props) => props.theme.spacing.medium};
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const App = () => (
  <ThemeProvider theme={theme}>
    <Container>
      <ThemedButton>
        <ButtonText>Press Me</ButtonText>
      </ThemedButton>
    </Container>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen with a button styled according to the theme, including colors and spacing. The theme ensures consistency across the UI components.

### Example 2: Switching Between Light and Dark Themes

In this example, you will learn how to implement light and dark themes and switch between them dynamically. By defining separate theme objects for light and dark modes, you can provide users with a theme toggle feature, enhancing the user experience. This is particularly useful for applications that need to support dark mode for better readability in low-light environments.

To switch between themes, create separate theme objects for light and dark modes. Use a state variable to manage the current theme and a button to toggle between the themes. This example demonstrates how to switch between light and dark themes dynamically.

#### Online Resources
1. [Switching Themes with Styled Components](https://styled-components.com/docs/advanced#theming)
2. [React Native Dark Mode](https://reactnative.dev/docs/appearance)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import styled, { ThemeProvider } from 'styled-components/native';
import { Button, Text, View } from 'react-native';

const lightTheme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
};

const darkTheme = {
  colors: {
    primary: '#bb86fc',
    background: '#121212',
    text: '#ffffff',
    button: '#bb86fc',
    buttonText: '#000000',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: 16px;
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: 16px;
  border-radius: 5px;
  margin-top: 20px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: 16px;
`;

const App = () => {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeProvider theme={theme}>
      <Container>
        <ThemedButton onPress={toggleTheme}>
          <ButtonText>Toggle Theme</ButtonText>
        </ThemedButton>
        <Text style={{ color: theme.colors.text, marginTop: 20 }}>
          Current Theme: {theme === lightTheme ? 'Light' : 'Dark'}
        </Text>
      </Container>
    </ThemeProvider>
  );
};

export default App;
```

**Expected Output:**

A screen with a button to toggle between light and dark themes. The background color, text color, and button styles change based on the current theme.

### Example 3: Persisting User Theme Preference

In this example, you will learn how to persist the user's theme preference using `AsyncStorage`. Persisting the theme preference ensures that the user's chosen theme is maintained even after the application is closed and reopened. This enhances the user experience by providing a consistent appearance according to the user's preferences.

To persist the theme preference, use `AsyncStorage` to save the selected theme. Retrieve the theme from `AsyncStorage` when the app loads and set it as the current theme. This example demonstrates how to persist and retrieve the user's theme preference using `AsyncStorage`.

#### Online Resources
1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/docs/install/)
2. [Persisting Theme with AsyncStorage](https://medium.com/@huayecai/persist-react-native-theme-in-asyncstorage-9bbeb41e9289)

#### Code to Practice

```javascript
import React, { useState, useEffect } from 'react';
import styled, { ThemeProvider } from 'styled-components/native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import { Button, Text, View, ActivityIndicator } from 'react-native';

const lightTheme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
};

const darkTheme = {
  colors: {
    primary: '#bb86fc',
    background: '#121212',
    text: '#ffffff',
    button: '#bb86fc',
    buttonText: '#000000',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: 16px;
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: 16px;
  border-radius: 5px;
  margin-top: 20px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: 16px;
`;

const App = () => {
  const [theme, setTheme] = useState(lightTheme);
  const [isLoading, setIsLoading] = useState(true);

  useEffect(() => {
    const loadTheme = async () => {
      const storedTheme = await AsyncStorage.getItem('theme');
      if (storedTheme) {
        setTheme(storedTheme === 'light' ? lightTheme : darkTheme);
      }
      setIsLoading(false);
    };
    loadTheme();
  }, []);

  const toggleTheme = async () => {
    const newTheme = theme === lightTheme ? darkTheme : lightTheme;
    setTheme(newTheme);
    await AsyncStorage.setItem('theme', newTheme === lightTheme ? 'light' : 'dark');
  };

  if (isLoading) {
    return <ActivityIndicator size="large" color="#0000ff

" />;
  }

  return (
    <ThemeProvider theme={theme}>
      <Container>
        <ThemedButton onPress={toggleTheme}>
          <ButtonText>Toggle Theme</ButtonText>
        </ThemedButton>
        <Text style={{ color: theme.colors.text, marginTop: 20 }}>
          Current Theme: {theme === lightTheme ? 'Light' : 'Dark'}
        </Text>
      </Container>
    </ThemeProvider>
  );
};

export default App;
```

**Expected Output:**

A screen with a button to toggle between light and dark themes. The selected theme is persisted using `AsyncStorage`, ensuring that the user's preference is maintained across app sessions.

---

### Task 10: Study CSS-in-JS Solutions

CSS-in-JS is a popular styling technique in modern web development where CSS is written within JavaScript files. This approach allows for better component encapsulation, easier maintenance, and more dynamic styling capabilities. CSS-in-JS solutions enable you to scope styles to components, thus avoiding the global scope pollution common in traditional CSS. By leveraging JavaScript’s full power, CSS-in-JS also makes it easier to implement theming, conditional styling, and other advanced features.

React Native, being a JavaScript-based framework, supports several CSS-in-JS libraries, such as Styled Components and Emotion. These libraries provide a powerful and flexible way to manage styles directly within your React Native components. They offer benefits like better performance through optimized CSS generation, easier debugging with scoped class names, and the ability to use JavaScript to manipulate styles dynamically. Studying and implementing CSS-in-JS solutions can significantly enhance your React Native development workflow.

#### Online Resources
1. [Styled Components Documentation](https://styled-components.com/docs)
2. [Emotion Documentation](https://emotion.sh/docs/introduction)

#### Examples to Practice

1. **Using Styled Components for Basic Styling**
2. **Dynamic Styling with Emotion**
3. **Creating Responsive Designs with Styled Components**

### Example 1: Using Styled Components for Basic Styling

Styled Components is a popular CSS-in-JS library that allows you to define component-level styles in your JavaScript code. It provides a clean and intuitive syntax for creating styled components and supports theming, which makes it easy to maintain a consistent design across your application. By using Tagged Template Literals, Styled Components enables you to write actual CSS within your JavaScript files.

To use Styled Components for basic styling, first install the library and create a simple component with styles. This example demonstrates how to set up Styled Components in a React Native project and apply styles to a button component.

#### Online Resources
1. [Styled Components Getting Started Guide](https://styled-components.com/docs/basics#getting-started)
2. [React Native Styling with Styled Components](https://www.reactnativeschool.com/react-native-styling-with-styled-components)

#### Code to Practice

```javascript
import React from 'react';
import styled from 'styled-components/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f2f2f2;
`;

const StyledButton = styled.TouchableOpacity`
  background-color: #6200ee;
  padding: 16px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #ffffff;
  font-size: 16px;
`;

const App = () => (
  <Container>
    <StyledButton>
      <ButtonText>Press Me</ButtonText>
    </StyledButton>
  </Container>
);

export default App;
```

**Expected Output:**

A screen with a button styled using Styled Components, featuring a purple background and white text.

### Example 2: Dynamic Styling with Emotion

Emotion is another powerful CSS-in-JS library that provides a high level of flexibility and performance for styling your React Native components. Emotion allows you to use both styled components and inline styles with the `css` function, making it highly versatile. It supports dynamic styling based on props and state, which is useful for creating responsive and interactive UIs.

To use Emotion for dynamic styling, first install the library and create styled components that respond to props. This example demonstrates how to apply different styles to a button component based on its props, such as changing the background color on press.

#### Online Resources
1. [Emotion Getting Started Guide](https://emotion.sh/docs/introduction)
2. [Using Emotion in React Native](https://emotion.sh/docs/@emotion/native)

#### Code to Practice

```javascript
import React from 'react';
import { useState } from 'react';
import { Text } from 'react-native';
import styled from '@emotion/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f2f2f2;
`;

const StyledButton = styled.TouchableOpacity`
  background-color: ${(props) => (props.pressed ? '#6200ee' : '#bbbbbb')};
  padding: 16px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #ffffff;
  font-size: 16px;
`;

const App = () => {
  const [pressed, setPressed] = useState(false);

  return (
    <Container>
      <StyledButton
        pressed={pressed}
        onPress={() => setPressed(!pressed)}
      >
        <ButtonText>Press Me</ButtonText>
      </StyledButton>
    </Container>
  );
};

export default App;
```

**Expected Output:**

A screen with a button that changes its background color from grey to purple when pressed, demonstrating dynamic styling with Emotion.

### Example 3: Creating Responsive Designs with Styled Components

Creating responsive designs in React Native is crucial for ensuring that your application looks good on various devices and screen sizes. Styled Components provides tools to handle responsive styling by using media queries and props. This allows you to create adaptive layouts that adjust based on the device's screen dimensions and orientation.

To create responsive designs with Styled Components, you can use media queries within your styled components to apply different styles based on screen size. Additionally, you can pass props to styled components to dynamically adjust their styles. This example demonstrates how to create a responsive layout that adjusts padding and font size based on screen width.

#### Online Resources
1. [Styled Components Media Queries](https://styled-components.com/docs/advanced#media-templates)
2. [Responsive Design with Styled Components](https://www.smashingmagazine.com/2020/01/responsive-design-react-styled-components/)

#### Code to Practice

```javascript
import React from 'react';
import styled from 'styled-components/native';
import { Dimensions } from 'react-native';

const { width } = Dimensions.get('window');

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f2f2f2;
  padding: ${(props) => (props.isLargeScreen ? '32px' : '16px')};
`;

const ResponsiveText = styled.Text`
  font-size: ${(props) => (props.isLargeScreen ? '24px' : '16px')};
  color: #000000;
`;

const App = () => {
  const isLargeScreen = width > 600;

  return (
    <Container isLargeScreen={isLargeScreen}>
      <ResponsiveText isLargeScreen={isLargeScreen}>
        Responsive Text
      </ResponsiveText>
    </Container>
  );
};

export default App;
```

**Expected Output:**

A screen with text that adjusts its padding and font size based on the screen width, demonstrating responsive design with Styled Components.

---

### Task 11: Implement Emotion for Styling

Emotion is a powerful and flexible CSS-in-JS library that allows you to style your components in a highly dynamic and responsive way. With Emotion, you can write CSS directly within your JavaScript files, enabling you to leverage the full power of JavaScript for your styling needs. This library provides both the `styled` API, which is similar to Styled Components, and the `css` function for more complex, conditional styles. By using Emotion, you can create scoped styles that prevent conflicts and make your components more reusable and maintainable.

Emotion is particularly useful in React Native because it allows for advanced theming and styling techniques. You can easily create and switch between themes, apply responsive styles based on props and state, and utilize JavaScript's logic to manage styles dynamically. Emotion also optimizes performance by generating minimal CSS at runtime and providing server-side rendering support. Studying and implementing Emotion for styling can significantly enhance the appearance and maintainability of your React Native applications.

#### Online Resources
1. [Emotion Documentation](https://emotion.sh/docs/introduction)
2. [Using Emotion in React Native](https://emotion.sh/docs/@emotion/native)

#### Examples to Practice

1. **Basic Styling with Emotion**
2. **Theming with Emotion**
3. **Dynamic Styling with Emotion**

### Example 1: Basic Styling with Emotion

Using Emotion for basic styling involves creating styled components that encapsulate your styles within the component file. This approach makes your styles more modular and easier to maintain. Emotion's `styled` function allows you to create components with attached styles, similar to how you would use CSS classes in traditional web development.

To implement basic styling with Emotion, first install the library and create a simple component with styles. This example demonstrates how to set up Emotion in a React Native project and apply styles to a button component.

#### Online Resources
1. [Emotion Styled API](https://emotion.sh/docs/styled)
2. [Getting Started with Emotion in React Native](https://emotion.sh/docs/@emotion/native)

#### Code to Practice

```javascript
import React from 'react';
import styled from '@emotion/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f2f2f2;
`;

const StyledButton = styled.TouchableOpacity`
  background-color: #6200ee;
  padding: 16px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #ffffff;
  font-size: 16px;
`;

const App = () => (
  <Container>
    <StyledButton>
      <ButtonText>Press Me</ButtonText>
    </StyledButton>
  </Container>
);

export default App;
```

**Expected Output:**

A screen with a button styled using Emotion, featuring a purple background and white text.

### Example 2: Theming with Emotion

Theming with Emotion allows you to define a set of design tokens, such as colors, fonts, and spacing, which can be applied consistently across your application. The `ThemeProvider` component from Emotion enables you to pass a theme object to your entire component tree, ensuring that all styled components use the same design tokens. This makes it easy to maintain a consistent look and feel throughout your app and quickly switch between different themes.

To implement theming with Emotion, define a theme object and wrap your application with the `ThemeProvider`. Then, create styled components that use the theme for styling. This example demonstrates how to set up a light theme and apply it to various components in a React Native application.

#### Online Resources
1. [Theming with Emotion](https://emotion.sh/docs/theming)
2. [Emotion Theming in React Native](https://medium.com/@carloslfu/use-emotion-theming-to-create-a-design-system-in-react-native-29d3f2067e20)

#### Code to Practice

```javascript
import React from 'react';
import styled, { ThemeProvider } from '@emotion/native';

const theme = {
  colors: {
    primary: '#6200ee',
    background: '#f2f2f2',
    text: '#000000',
    button: '#6200ee',
    buttonText: '#ffffff',
  },
  fontSizes: {
    small: '12px',
    medium: '16px',
    large: '20px',
  },
  spacing: {
    small: '8px',
    medium: '16px',
    large: '24px',
  },
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${(props) => props.theme.colors.background};
  padding: ${(props) => props.theme.spacing.medium};
`;

const ThemedButton = styled.TouchableOpacity`
  background-color: ${(props) => props.theme.colors.button};
  padding: ${(props) => props.theme.spacing.medium};
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: ${(props) => props.theme.colors.buttonText};
  font-size: ${(props) => props.theme.fontSizes.medium};
`;

const App = () => (
  <ThemeProvider theme={theme}>
    <Container>
      <ThemedButton>
        <ButtonText>Press Me</ButtonText>
      </ThemedButton>
    </Container>
  </ThemeProvider>
);

export default App;
```

**Expected Output:**

A screen with a button styled according to the theme, including colors and spacing. The theme ensures consistency across the UI components.

### Example 3: Dynamic Styling with Emotion

Dynamic styling with Emotion involves using props and state to conditionally apply styles to your components. This approach is particularly useful for creating interactive UIs that respond to user actions or changes in application state. Emotion allows you to define styles based on props directly within your styled components, making it easy to manage complex styling logic.

To implement dynamic styling with Emotion, create styled components that accept props and use these props to apply different styles. This example demonstrates how to change the background color of a button component based on whether it is pressed.

#### Online Resources
1. [Emotion Dynamic Styles](https://emotion.sh/docs/styled#dynamic-styles)
2. [Using Props in Emotion](https://emotion.sh/docs/styled#changing-based-on-props)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import styled from '@emotion/native';

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: #f2f2f2;
`;

const StyledButton = styled.TouchableOpacity`
  background-color: ${(props) => (props.pressed ? '#6200ee' : '#bbbbbb')};
  padding: 16px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: #ffffff;
  font-size: 16px;
`;

const App = () => {
  const [pressed, setPressed] = useState(false);

  return (
    <Container>
      <StyledButton
        pressed={pressed}
        onPress={() => setPressed(!pressed)}
      >
        <ButtonText>Press Me</ButtonText>
      </StyledButton>
    </Container>
  );
};

export default App;
```

**Expected Output:**

A screen with a button that changes its background color from grey to purple when pressed, demonstrating dynamic styling with Emotion.

---

### Task 11: Study Accessibility Improvements

Accessibility improvements in React Native ensure that your application is usable by as many people as possible, including those with disabilities. Making your app accessible involves implementing features that support screen readers, keyboard navigation, color contrast adjustments, and more. By enhancing accessibility, you not only comply with legal requirements but also provide a better user experience for everyone, leading to broader user engagement and inclusivity.

React Native provides various built-in components and APIs to help developers make their apps more accessible. These include accessibility props, roles, and state descriptions that can be applied to components to describe their purpose and state to screen readers. Learning to use these tools effectively is crucial for creating applications that everyone can use, regardless of their abilities.

#### Online Resources
1. [React Native Accessibility Guide](https://reactnative.dev/docs/accessibility)
2. [Web Content Accessibility Guidelines (WCAG)](https://www.w3.org/WAI/standards-guidelines/wcag/)

#### Examples to Practice

1. **Implementing Basic Accessibility Props**
2. **Using Accessibility Roles and States**
3. **Handling Focus and Keyboard Navigation**

### Example 1: Implementing Basic Accessibility Props

Basic accessibility props in React Native help in providing additional context and functionality to UI components for users relying on assistive technologies like screen readers. These props include `accessible`, `accessibilityLabel`, `accessibilityHint`, and `accessibilityRole`. By adding these props, you can ensure that components are properly announced and understood by screen readers.

To implement basic accessibility props, start by adding these props to your components. This example demonstrates how to enhance a button component with accessibility props to make it more accessible.

#### Online Resources
1. [Accessibility Props in React Native](https://reactnative.dev/docs/accessibility#accessibility-properties)
2. [Using Accessibility Props in React Native](https://medium.com/swlh/accessibility-in-react-native-3afc6181991)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

const App = () => (
  <View style={styles.container}>
    <TouchableOpacity
      style={styles.button}
      accessible={true}
      accessibilityLabel="Press me"
      accessibilityHint="Navigates to the next screen"
      accessibilityRole="button"
      onPress={() => alert('Button pressed!')}
    >
      <Text style={styles.buttonText}>Press Me</Text>
    </TouchableOpacity>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  button: {
    backgroundColor: '#6200ee',
    padding: 16,
    borderRadius: 5,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
  },
});

export default App;
```

**Expected Output:**

A button with accessibility props that is properly announced by screen readers, providing context and hints about its functionality.

### Example 2: Using Accessibility Roles and States

Accessibility roles and states provide additional context about the purpose and state of a UI component. Roles describe what kind of UI element a component is (e.g., button, header, checkbox), while states provide information about the current state of the component (e.g., checked, selected, disabled). These properties help screen readers convey more accurate information to users, improving the overall accessibility of the application.

To use accessibility roles and states, add the appropriate props to your components. This example demonstrates how to implement a checkbox with accessibility roles and states, providing context about its checked state to screen readers.

#### Online Resources
1. [Accessibility Roles and States in React Native](https://reactnative.dev/docs/accessibility#accessibility-roles-and-states)
2. [Implementing Accessible Components in React Native](https://blog.logrocket.com/implementing-accessible-components-react-native/)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { View, Text, TouchableOpacity, StyleSheet } from 'react-native';

const App = () => {
  const [checked, setChecked] = useState(false);

  return (
    <View style={styles.container}>
      <TouchableOpacity
        style={styles.checkbox}
        accessible={true}
        accessibilityRole="checkbox"
        accessibilityState={{ checked }}
        onPress={() => setChecked(!checked)}
      >
        <Text style={styles.checkboxText}>{checked ? '☑️' : '⬜️'}</Text>
      </TouchableOpacity>
      <Text style={styles.label}>Accept Terms and Conditions</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  checkbox: {
    padding: 10,
  },
  checkboxText: {
    fontSize: 24,
  },
  label: {
    marginTop: 10,
    fontSize: 16,
  },
});

export default App;
```

**Expected Output:**

A checkbox that toggles its state between checked and unchecked. The checkbox has appropriate accessibility roles and states, providing context about its current state to screen readers.

### Example 3: Handling Focus and Keyboard Navigation

Handling focus and keyboard navigation is crucial for making applications accessible to users who rely on keyboard navigation or assistive technologies. Properly managing focus ensures that users can navigate through the application using the keyboard or other input devices. In React Native, you can use props like `accessible`, `accessibilityLabel`, and `onFocus` to manage focus and keyboard navigation effectively.

To handle focus and keyboard navigation, add the necessary accessibility props to your components and manage focus changes programmatically if needed. This example demonstrates how to create a form with accessible input fields and a submit button, ensuring proper focus management and keyboard navigation.

#### Online Resources
1. [Handling Focus in React Native](https://reactnative.dev/docs/accessibility#handling-focus)
2. [Keyboard Navigation in React Native](https://www.smashingmagazine.com/2020/10/keyboard-accessible-forms-wai-aria/)

#### Code to Practice

```javascript
import React, { useRef } from 'react';
import { View, TextInput, TouchableOpacity, Text, StyleSheet } from 'react-native';

const App = () => {
  const inputRef = useRef(null);

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Username"
        accessible={true}
        accessibilityLabel="Enter your username"
        ref={inputRef}
      />
      <TextInput
        style={styles.input}
        placeholder="Password"
        secureTextEntry
        accessible={true}
        accessibilityLabel="Enter your password"
      />
      <TouchableOpacity
        style={styles.button}
        accessible={true}
        accessibilityLabel="Submit form"
        accessibilityRole="button"
        onPress={() => alert('Form submitted!')}
      >
        <Text style={styles.buttonText}>Submit</Text>
      </TouchableOpacity>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  input: {
    width: '100%',
    padding: 16,
    marginVertical: 8,
    borderWidth: 1,
    borderColor: '#ccc',
    borderRadius: 5,
  },
  button: {
    backgroundColor: '#6200ee',
    padding: 16,
    borderRadius: 5,
    marginTop: 16,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
  },
});

export default App;
```

**Expected Output:**

A form with two input fields and a submit button. The form fields and button have appropriate accessibility labels, and focus management ensures a smooth user experience for keyboard navigation and screen readers.

---

### Task 13: Implement Accessible Navigation

Accessible navigation in React Native involves designing and implementing navigation structures that can be easily used by everyone, including people with disabilities. This means ensuring that all navigational elements are accessible via screen readers, keyboard navigation, and other assistive technologies. By making navigation accessible, you improve the overall usability and inclusivity of your application, making it easier for all users to find and interact with the content they need.

To implement accessible navigation, you can use a combination of React Native's accessibility props and the React Navigation library. React Navigation provides a flexible and robust way to manage navigation in React Native apps, and when combined with accessibility enhancements, it ensures that all users can navigate through your app efficiently. Key accessibility features include properly labeling navigational elements, managing focus correctly, and providing clear instructions for screen reader users.

#### Online Resources
1. [React Native Accessibility Guide](https://reactnative.dev/docs/accessibility)
2. [React Navigation Accessibility](https://reactnavigation.org/docs/accessibility/)

#### Examples to Practice

1. **Creating Accessible Tabs**
2. **Managing Focus in Stack Navigation**
3. **Implementing Accessible Drawer Navigation**

### Example 1: Creating Accessible Tabs

Tabs are a common navigation pattern in mobile applications. Making tabs accessible involves ensuring that they are properly labeled for screen readers and that the focus is managed correctly when navigating between tabs. React Navigation's `createBottomTabNavigator` can be used to create tab-based navigation in React Native.

To create accessible tabs, you need to add appropriate accessibility labels and roles to the tab elements. This example demonstrates how to set up a basic tab navigator with accessible tabs.

#### Online Resources
1. [React Navigation Tabs Documentation](https://reactnavigation.org/docs/bottom-tab-navigator/)
2. [Creating Accessible Tabs](https://reactnative.dev/docs/accessibility#accessibility-properties)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createBottomTabNavigator } from '@react-navigation/bottom-tabs';
import Ionicons from 'react-native-vector-icons/Ionicons';

const HomeScreen = () => (
  <View style={styles.container}>
    <Text>Home Screen</Text>
  </View>
);

const SettingsScreen = () => (
  <View style={styles.container}>
    <Text>Settings Screen</Text>
  </View>
);

const Tab = createBottomTabNavigator();

const App = () => (
  <NavigationContainer>
    <Tab.Navigator
      screenOptions={({ route }) => ({
        tabBarIcon: ({ color, size }) => {
          let iconName;
          if (route.name === 'Home') {
            iconName = 'home';
          } else if (route.name === 'Settings') {
            iconName = 'settings';
          }
          return <Ionicons name={iconName} size={size} color={color} />;
        },
        tabBarAccessibilityLabel: `${route.name} tab`,
        tabBarRole: 'tab',
      })}
    >
      <Tab.Screen name="Home" component={HomeScreen} />
      <Tab.Screen name="Settings" component={SettingsScreen} />
    </Tab.Navigator>
  </NavigationContainer>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A tab navigator with two tabs: Home and Settings. The tabs are accessible and properly labeled for screen readers, and the icons are displayed using `Ionicons`.

### Example 2: Managing Focus in Stack Navigation

Stack navigation allows users to navigate through a stack of screens, typically using a navigation bar or header. Ensuring that focus is managed correctly when navigating between screens is essential for accessibility. This involves setting focus to the appropriate elements when a new screen is presented, making it easier for users relying on screen readers to understand the current context.

To manage focus in stack navigation, you can use React Navigation's `useNavigation` hook to programmatically set focus to specific elements when navigating between screens. This example demonstrates how to set up a stack navigator and manage focus for accessible navigation.

#### Online Resources
1. [React Navigation Stack Documentation](https://reactnavigation.org/docs/stack-navigator/)
2. [Managing Focus in React Native](https://reactnative.dev/docs/accessibility#handling-focus)

#### Code to Practice

```javascript
import React, { useRef } from 'react';
import { View, Text, Button, StyleSheet, findNodeHandle } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createStackNavigator } from '@react-navigation/stack';

const HomeScreen = ({ navigation }) => {
  const buttonRef = useRef(null);

  React.useEffect(() => {
    const focusButton = () => {
      const reactTag = findNodeHandle(buttonRef.current);
      if (reactTag) {
        buttonRef.current.focus();
      }
    };
    navigation.addListener('focus', focusButton);
    return () => navigation.removeListener('focus', focusButton);
  }, [navigation]);

  return (
    <View style={styles.container}>
      <Text>Home Screen</Text>
      <Button
        title="Go to Details"
        onPress={() => navigation.navigate('Details')}
        ref={buttonRef}
        accessibilityLabel="Go to details screen"
        accessibilityRole="button"
      />
    </View>
  );
};

const DetailsScreen = () => (
  <View style={styles.container}>
    <Text>Details Screen</Text>
  </View>
);

const Stack = createStackNavigator();

const App = () => (
  <NavigationContainer>
    <Stack.Navigator>
      <Stack.Screen name="Home" component={HomeScreen} />
      <Stack.Screen name="Details" component={DetailsScreen} />
    </Stack.Navigator>
  </NavigationContainer>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A stack navigator with two screens: Home and Details. When navigating to the Home screen, the focus is set to the "Go to Details" button, ensuring proper focus management for screen readers.

### Example 3: Implementing Accessible Drawer Navigation

Drawer navigation provides a sidebar menu that users can slide in from the side of the screen. Ensuring that the drawer is accessible involves properly labeling the drawer button and providing focus management when the drawer is opened and closed. React Navigation's `createDrawerNavigator` can be used to create a drawer-based navigation in React Native.

To implement accessible drawer navigation, add appropriate accessibility props to the drawer button and manage focus when the drawer is opened. This example demonstrates how to set up a basic drawer navigator with accessible drawer functionality.

#### Online Resources
1. [React Navigation Drawer Documentation](https://reactnavigation.org/docs/drawer-navigator/)
2. [Creating Accessible Drawer Navigation](https://reactnative.dev/docs/accessibility#accessibility-properties)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { NavigationContainer } from '@react-navigation/native';
import { createDrawerNavigator } from '@react-navigation/drawer';
import { TouchableOpacity } from 'react-native-gesture-handler';

const HomeScreen = ({ navigation }) => (
  <View style={styles.container}>
    <Text>Home Screen</Text>
    <TouchableOpacity
      style={styles.button}
      onPress={() => navigation.openDrawer()}
      accessible={true}
      accessibilityLabel="Open drawer"
      accessibilityRole="button"
    >
      <Text style={styles.buttonText}>Open Drawer</Text>
    </TouchableOpacity>
  </View>
);

const SettingsScreen = () => (
  <View style={styles.container}>
    <Text>Settings Screen</Text>
  </View>
);

const Drawer = createDrawerNavigator();

const App = () => (
  <NavigationContainer>
    <Drawer.Navigator initialRouteName="Home">
      <Drawer.Screen name="Home" component={HomeScreen} />
      <Drawer.Screen name="Settings" component={SettingsScreen} />
    </Drawer.Navigator>
  </NavigationContainer>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  button: {
    backgroundColor: '#6200ee',
    padding: 16,
    borderRadius: 5,
    marginTop: 20,
  },
  buttonText: {
    color: '#ffffff',
    fontSize: 16,
  },
});

export default App;
```

**Expected Output:**

A drawer navigator with two screens: Home and Settings. The drawer can be opened with an accessible button on the Home screen, and focus management ensures a smooth experience for screen readers.

---

### Task 14: Study Performance Monitoring

Performance monitoring in React Native is crucial for ensuring that your application runs smoothly and efficiently across various devices and platforms. It involves tracking and analyzing different performance metrics such as load times, frame rates, memory usage, and network requests. By understanding these metrics, developers can identify performance bottlenecks, optimize code, and improve the overall user experience. Tools like React Native's built-in performance monitor, Flipper, and third-party services like Firebase Performance Monitoring can help in tracking and addressing performance issues effectively.

Performance monitoring is not just about identifying issues; it's also about continuous improvement and maintaining the performance of your application over time. Regularly monitoring performance metrics helps in catching issues early, especially after new features are added or updates are made. It also allows developers to set performance benchmarks and goals, ensuring that the application meets the desired performance standards consistently. Implementing a robust performance monitoring strategy is essential for delivering high-quality, responsive, and reliable applications.

#### Online Resources
1. [React Native Performance](https://reactnative.dev/docs/performance)
2. [Monitoring React Native Performance](https://firebase.google.com/docs/perf-mon/get-started-react-native)

#### Examples to Practice

1. **Using React Native Performance Monitor**
2. **Integrating Flipper for Performance Monitoring**
3. **Implementing Firebase Performance Monitoring**

### Example 1: Using React Native Performance Monitor

React Native provides a built-in performance monitor that helps developers track various performance metrics during development. This monitor displays information such as FPS (frames per second), memory usage, and JavaScript thread activity, allowing developers to identify performance issues in real time. Enabling the performance monitor is simple and provides immediate feedback on how the application performs under different conditions.

To use the React Native performance monitor, you need to enable it in your development environment. This example demonstrates how to activate the performance monitor and interpret its output to optimize your application.

#### Online Resources
1. [React Native Performance Monitor](https://reactnative.dev/docs/performance#using-performance-monitor)
2. [Improving Performance in React Native](https://medium.com/swlh/improving-performance-in-react-native-applications-247828e903e)

#### Code to Practice

```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  useEffect(() => {
    if (__DEV__) {
      const { enableLatestRenderer } = require('react-native');
      enableLatestRenderer();
    }
  }, []);

  const performHeavyTask = () => {
    let sum = 0;
    for (let i = 0; i < 1e6; i++) {
      sum += i;
    }
    alert('Heavy task completed');
  };

  return (
    <View style={styles.container}>
      <Text>React Native Performance Monitor</Text>
      <Button title="Perform Heavy Task" onPress={performHeavyTask} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

The React Native performance monitor will be enabled, displaying FPS, memory usage, and other metrics while running the app. The "Perform Heavy Task" button will simulate a computationally intensive task to observe performance impacts.

### Example 2: Integrating Flipper for Performance Monitoring

Flipper is a powerful tool for debugging and performance monitoring in React Native applications. It provides a range of plugins for tracking various performance metrics, including network requests, layout updates, and logs. Flipper's integration with React Native makes it easy to monitor and debug applications, providing a visual interface to analyze performance data.

To integrate Flipper for performance monitoring, you need to set up Flipper in your React Native project and enable the relevant plugins. This example demonstrates how to configure Flipper and use its performance monitoring capabilities to track and analyze your application's performance.

#### Online Resources
1. [Flipper Documentation](https://fbflipper.com/docs/features/react-native/)
2. [Using Flipper with React Native](https://reactnative.dev/docs/flipper)

#### Code to Practice

```javascript
// Add the following lines to the android/app/build.gradle file
// inside the dependencies block

dependencies {
  ...
  debugImplementation 'com.facebook.flipper:flipper:0.93.0'
  debugImplementation 'com.facebook.flipper:flipper-network-plugin:0.93.0'
  debugImplementation 'com.facebook.flipper:flipper-fresco-plugin:0.93.0'
  debugImplementation 'com.facebook.soloader:soloader:0.10.1'
}

// For iOS, ensure you have the latest Flipper setup in your Podfile
// Example Podfile snippet

use_flipper!({ 'Flipper' => '0.93.0' })

// Then install the pods
$ cd ios
$ pod install

// Example App.js code to use Flipper

import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import FlipperPlugin from 'react-native-flipper';

const App = () => {
  const performHeavyTask = () => {
    let sum = 0;
    for (let i = 0; i < 1e6; i++) {
      sum += i;
    }
    alert('Heavy task completed');
  };

  return (
    <View style={styles.container}>
      <Text>Flipper Performance Monitoring</Text>
      <Button title="Perform Heavy Task" onPress={performHeavyTask} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Flipper will be integrated into the React Native project, allowing you to monitor performance metrics such as network requests and layout updates. The "Perform Heavy Task" button will simulate a computationally intensive task to observe performance impacts.

### Example 3: Implementing Firebase Performance Monitoring

Firebase Performance Monitoring is a powerful tool for tracking the performance of your React Native applications. It provides insights into app startup times, HTTP request performance, and screen rendering times. By integrating Firebase Performance Monitoring, you can gather detailed performance data and use it to optimize your application.

To implement Firebase Performance Monitoring, you need to set up Firebase in your React Native project and configure the performance monitoring SDK. This example demonstrates how to integrate Firebase Performance Monitoring and track performance metrics in your application.

#### Online Resources
1. [Firebase Performance Monitoring Documentation](https://firebase.google.com/docs/perf-mon/get-started-react-native)
2. [Setting Up Firebase in React Native](https://rnfirebase.io/)

#### Code to Practice

```javascript
// Add Firebase dependencies to your project
// npm install @react-native-firebase/app @react-native-firebase/perf

import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import perf from '@react-native-firebase/perf';

const App = () => {
  useEffect(() => {
    const trace = perf().newTrace('app_startup');
    trace.start();
    return () => {
      trace.stop();
    };
  }, []);

  const performHeavyTask = async () => {
    const trace = perf().newTrace('heavy_task');
    trace.start();
    let sum = 0;
    for (let i = 0; i < 1e6; i++) {
      sum += i;
    }
    trace.stop();
    alert('Heavy task completed');
  };

  return (
    <View style={styles.container}>
      <Text>Firebase Performance Monitoring</Text>
      <Button title="Perform Heavy Task" onPress={performHeavyTask} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Firebase Performance Monitoring will be integrated into the React Native project, tracking metrics such as app startup times and the performance of the "Perform Heavy Task" button. Performance data will be available in the Firebase console for analysis.

---

### Task 15: Implement Performance Monitoring with Sentry

Sentry is a powerful error tracking and performance monitoring tool that helps developers identify and fix issues in their applications. By integrating Sentry into your React Native application, you can monitor performance metrics such as transaction duration, frame rates, and memory usage. This allows you to gain insights into the performance of your application, identify bottlenecks, and improve the overall user experience. Sentry also provides detailed error reports, including stack traces, device information, and user context, making it easier to diagnose and resolve issues.

To implement performance monitoring with Sentry, you need to set up Sentry in your React Native project and configure it to capture performance data. This involves installing the Sentry SDK, initializing it with your Sentry DSN, and instrumenting your application to capture transactions and spans. By doing so, you can track the performance of specific operations, measure their impact on the user experience, and make data-driven decisions to optimize your application.

#### Online Resources
1. [Sentry React Native Documentation](https://docs.sentry.io/platforms/react-native/)
2. [Performance Monitoring with Sentry](https://docs.sentry.io/product/performance/)

#### Examples to Practice

1. **Setting Up Sentry in a React Native Project**
2. **Capturing Performance Metrics with Sentry**
3. **Tracking Custom Transactions and Spans**

### Example 1: Setting Up Sentry in a React Native Project

Setting up Sentry in a React Native project involves installing the Sentry SDK and initializing it with your Sentry DSN (Data Source Name). This step is crucial for enabling Sentry to capture errors and performance data from your application. Once Sentry is set up, it will automatically capture unhandled exceptions and send error reports to your Sentry dashboard.

To set up Sentry, you need to install the `@sentry/react-native` package and configure it in your application. This example demonstrates how to install Sentry, initialize it with your DSN, and verify that it is working correctly by triggering an intentional error.

#### Online Resources
1. [Sentry React Native Setup Guide](https://docs.sentry.io/platforms/react-native/)
2. [React Native Error Tracking with Sentry](https://docs.sentry.io/platforms/react-native/guides/)

#### Code to Practice

```javascript
// Install the Sentry package
// npm install @sentry/react-native

import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN', // Replace with your Sentry DSN
});

const App = () => {
  useEffect(() => {
    Sentry.captureMessage('App mounted');
  }, []);

  const triggerError = () => {
    throw new Error('This is a test error');
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Setup Example</Text>
      <Button title="Trigger Error" onPress={triggerError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Sentry will be initialized with your DSN, and an intentional error can be triggered by pressing the "Trigger Error" button. The error will be captured by Sentry and sent to your Sentry dashboard.

### Example 2: Capturing Performance Metrics with Sentry

Capturing performance metrics with Sentry allows you to monitor the performance of your React Native application in real time. Sentry's performance monitoring features enable you to track transaction durations, measure frame rates, and identify slow operations. By analyzing these metrics, you can pinpoint performance bottlenecks and optimize your application for better user experience.

To capture performance metrics, you need to enable performance monitoring in Sentry and instrument your application to capture transactions and spans. This example demonstrates how to configure Sentry to capture performance data and monitor the performance of specific operations within your application.

#### Online Resources
1. [Sentry Performance Monitoring](https://docs.sentry.io/product/performance/)
2. [React Native Performance Monitoring with Sentry](https://docs.sentry.io/platforms/react-native/performance/)

#### Code to Practice

```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN', // Replace with your Sentry DSN
  tracesSampleRate: 1.0,
});

const App = () => {
  useEffect(() => {
    Sentry.captureMessage('App mounted');
  }, []);

  const performTask = async () => {
    const transaction = Sentry.startTransaction({ name: 'perform_task' });
    Sentry.configureScope(scope => {
      scope.setSpan(transaction);
    });

    try {
      // Simulate a task
      await new Promise(resolve => setTimeout(resolve, 2000));
    } finally {
      transaction.finish();
    }
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Performance Monitoring Example</Text>
      <Button title="Perform Task" onPress={performTask} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Sentry will capture performance metrics for the "perform_task" transaction. When the "Perform Task" button is pressed, a simulated task will be performed, and its duration will be tracked and sent to Sentry.

### Example 3: Tracking Custom Transactions and Spans

Tracking custom transactions and spans with Sentry allows you to monitor specific parts of your application in detail. Transactions represent a series of related operations, while spans represent individual operations within a transaction. By creating custom transactions and spans, you can gain insights into the performance of specific features or workflows in your application.

To track custom transactions and spans, you need to create transactions and spans programmatically using the Sentry SDK. This example demonstrates how to create a custom transaction with multiple spans to monitor the performance of a complex operation.

#### Online Resources
1. [Sentry Custom Instrumentation](https://docs.sentry.io/product/performance/instrumentation/custom-instrumentation/)
2. [React Native Custom Transactions and Spans](https://docs.sentry.io/platforms/react-native/performance/instrumentation/)

#### Code to Practice

```javascript
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN', // Replace with your Sentry DSN
  tracesSampleRate: 1.0,
});

const App = () => {
  useEffect(() => {
    Sentry.captureMessage('App mounted');
  }, []);

  const performComplexTask = async () => {
    const transaction = Sentry.startTransaction({ name: 'complex_task' });
    Sentry.configureScope(scope => {
      scope.setSpan(transaction);
    });

    try {
      const span1 = transaction.startChild({ op: 'task_part_1', description: 'Part 1 of complex task' });
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate part 1
      span1.finish();

      const span2 = transaction.startChild({ op: 'task_part_2', description: 'Part 2 of complex task' });
      await new Promise(resolve => setTimeout(resolve, 1500)); // Simulate part 2
      span2.finish();

      const span3 = transaction.startChild({ op: 'task_part_3', description: 'Part 3 of complex task' });
      await new Promise(resolve => setTimeout(resolve, 2000)); // Simulate part 3
      span3.finish();
    } finally {
      transaction.finish();
    }
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Custom Transactions and Spans Example</Text>
      <Button title="Perform Complex Task" onPress={performComplexTask} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Sentry will capture performance metrics for the "complex_task" transaction, including detailed spans for each part of the task. When the "Perform Complex Task" button is pressed, the task will be performed, and the performance of each part will be tracked and sent to Sentry.

---

### Task 16: Study Crash Reporting

Crash reporting is a crucial aspect of mobile app development that involves tracking and logging errors and crashes that occur in your application. Effective crash reporting helps developers identify and resolve issues quickly, ensuring a stable and reliable user experience. By capturing detailed information about crashes, including stack traces, device information, and user actions leading up to the crash, developers can pinpoint the root cause of issues and implement fixes more efficiently. This proactive approach to handling crashes reduces downtime and improves user satisfaction.

There are several tools and services available for crash reporting in React Native applications, including Sentry, Firebase Crashlytics, and Bugsnag. These tools provide comprehensive crash reporting features, including real-time alerts, user session tracking, and integration with development workflows. By integrating a crash reporting tool into your React Native app, you can continuously monitor the health of your application, gain insights into its stability, and prioritize bug fixes based on their impact on users.

#### Online Resources
1. [Crash Reporting in React Native](https://reactnative.dev/docs/upgrading)
2. [Best Practices for Mobile App Crash Reporting](https://www.smashingmagazine.com/2021/02/crash-reporting-best-practices/)

#### Examples to Practice

1. **Setting Up Sentry for Crash Reporting**
2. **Integrating Firebase Crashlytics**
3. **Using Bugsnag for Crash Reporting**

### Example 1: Setting Up Sentry for Crash Reporting

Sentry is a popular error tracking and crash reporting tool that helps developers monitor and fix crashes in their applications. By integrating Sentry into your React Native app, you can capture detailed information about crashes, including stack traces, device context, and user actions. Sentry provides real-time alerts and integrates with various development tools, making it easier to track and resolve issues quickly.

To set up Sentry for crash reporting, you need to install the Sentry SDK and configure it with your Sentry DSN. This example demonstrates how to set up Sentry in a React Native project, capture crashes, and send reports to the Sentry dashboard.

#### Online Resources
1. [Sentry React Native Documentation](https://docs.sentry.io/platforms/react-native/)
2. [React Native Error Tracking with Sentry](https://docs.sentry.io/platforms/react-native/guides/)

#### Code to Practice

```javascript
// Install the Sentry package
// npm install @sentry/react-native

import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({
  dsn: 'YOUR_SENTRY_DSN', // Replace with your Sentry DSN
});

const App = () => {
  useEffect(() => {
    Sentry.captureMessage('App mounted');
  }, []);

  const triggerError = () => {
    throw new Error('This is a test error');
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Crash Reporting Example</Text>
      <Button title="Trigger Error" onPress={triggerError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Sentry will be initialized with your DSN, and an intentional error can be triggered by pressing the "Trigger Error" button. The error will be captured by Sentry and sent to your Sentry dashboard, where you can view detailed crash reports.

### Example 2: Integrating Firebase Crashlytics

Firebase Crashlytics is a lightweight, real-time crash reporting tool that helps developers track, prioritize, and fix stability issues in their apps. It provides detailed crash reports, including stack traces, device information, and user actions leading up to the crash. Crashlytics also offers features like custom logging and crash-free user metrics, making it easier to understand and resolve issues.

To integrate Firebase Crashlytics into your React Native app, you need to set up Firebase in your project and configure Crashlytics. This example demonstrates how to set up Firebase Crashlytics, capture crashes, and send reports to the Firebase console.

#### Online Resources
1. [Firebase Crashlytics Documentation](https://firebase.google.com/docs/crashlytics)
2. [Setting Up Firebase in React Native](https://rnfirebase.io/)

#### Code to Practice

```javascript
// Install Firebase packages
// npm install @react-native-firebase/app @react-native-firebase/crashlytics

import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import crashlytics from '@react-native-firebase/crashlytics';

const App = () => {
  useEffect(() => {
    crashlytics().log('App mounted');
  }, []);

  const triggerCrash = () => {
    crashlytics().crash();
  };

  return (
    <View style={styles.container}>
      <Text>Firebase Crashlytics Example</Text>
      <Button title="Trigger Crash" onPress={triggerCrash} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Firebase Crashlytics will be initialized, and an intentional crash can be triggered by pressing the "Trigger Crash" button. The crash will be captured by Crashlytics and sent to the Firebase console, where you can view detailed crash reports.

### Example 3: Using Bugsnag for Crash Reporting

Bugsnag is a robust error monitoring tool that provides real-time crash reporting and diagnostics for mobile applications. It helps developers capture and analyze errors, providing detailed reports that include stack traces, device context, and user actions. Bugsnag also offers powerful features like user tracking and custom error reporting, making it easier to prioritize and resolve issues.

To use Bugsnag for crash reporting in your React Native app, you need to set up the Bugsnag SDK and configure it with your Bugsnag API key. This example demonstrates how to integrate Bugsnag, capture crashes, and send reports to the Bugsnag dashboard.

#### Online Resources
1. [Bugsnag React Native Documentation](https://docs.bugsnag.com/platforms/react-native/)
2. [Getting Started with Bugsnag](https://docs.bugsnag.com/platforms/react-native/react-native/)

#### Code to Practice

```javascript
// Install Bugsnag package
// npm install @bugsnag/react-native

import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import Bugsnag from '@bugsnag/react-native';

Bugsnag.start();

const App = () => {
  useEffect(() => {
    Bugsnag.notify(new Error('App mounted'));
  }, []);

  const triggerError = () => {
    Bugsnag.notify(new Error('This is a test error'));
  };

  return (
    <View style={styles.container}>
      <Text>Bugsnag Crash Reporting Example</Text>
      <Button title="Trigger Error" onPress={triggerError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Bugsnag will be initialized, and an intentional error can be triggered by pressing the "Trigger Error" button. The error will be captured by Bugsnag and sent to the Bugsnag dashboard, where you can view detailed crash reports.

---

### Task 17: Implement Crash Reporting with Bugsnag

Bugsnag is a robust error monitoring and crash reporting tool that helps developers capture, analyze, and resolve crashes and errors in their applications. It provides detailed crash reports that include stack traces, device context, and user actions leading up to the crash, enabling developers to diagnose and fix issues quickly. Bugsnag's real-time alerts and comprehensive dashboards make it easier to monitor the health of your application and prioritize fixes based on the impact on users.

Integrating Bugsnag into your React Native application involves setting up the Bugsnag SDK and configuring it with your Bugsnag API key. Once configured, Bugsnag will automatically capture and report unhandled exceptions and crashes, and you can also manually log errors and custom events. By leveraging Bugsnag's capabilities, you can ensure that your application remains stable and provides a smooth user experience, even as you add new features and updates.

#### Online Resources
1. [Bugsnag React Native Documentation](https://docs.bugsnag.com/platforms/react-native/)
2. [Getting Started with Bugsnag in React Native](https://docs.bugsnag.com/platforms/react-native/react-native/)

#### Examples to Practice

1. **Basic Bugsnag Setup and Configuration**
2. **Capturing Unhandled Exceptions**
3. **Logging Custom Errors and Events**

### Example 1: Basic Bugsnag Setup and Configuration

Setting up Bugsnag for crash reporting in a React Native project involves installing the Bugsnag SDK and initializing it with your Bugsnag API key. This setup enables Bugsnag to start capturing and reporting errors and crashes from your application. The initial setup is straightforward and provides immediate benefits by capturing unhandled exceptions automatically.

To set up Bugsnag, you need to install the Bugsnag SDK and configure it in your application. This example demonstrates how to install and initialize Bugsnag in a React Native project.

#### Online Resources
1. [Bugsnag Setup Guide for React Native](https://docs.bugsnag.com/platforms/react-native/react-native/)
2. [Bugsnag React Native Configuration](https://docs.bugsnag.com/platforms/react-native/configuration-options/)

#### Code to Practice

```javascript
// Install Bugsnag package
// npm install @bugsnag/react-native

import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import Bugsnag from '@bugsnag/react-native';

Bugsnag.start();

const App = () => (
  <View style={styles.container}>
    <Text>Bugsnag Setup Example</Text>
  </View>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Bugsnag will be initialized with your API key, and it will start capturing and reporting unhandled exceptions from your React Native application.

### Example 2: Capturing Unhandled Exceptions

Capturing unhandled exceptions is a crucial aspect of crash reporting, as it helps developers identify and fix issues that were not anticipated during development. Bugsnag automatically captures unhandled exceptions and sends detailed reports to the Bugsnag dashboard. These reports include information such as stack traces, device context, and user actions, making it easier to diagnose and resolve issues.

To capture unhandled exceptions, ensure that Bugsnag is properly initialized in your application. This example demonstrates how to trigger an unhandled exception and verify that Bugsnag captures and reports it.

#### Online Resources
1. [Bugsnag Unhandled Exception Handling](https://docs.bugsnag.com/platforms/react-native/unhandled-exceptions/)
2. [React Native Error Handling with Bugsnag](https://docs.bugsnag.com/platforms/react-native/react-native/)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import Bugsnag from '@bugsnag/react-native';

Bugsnag.start();

const App = () => {
  const triggerError = () => {
    throw new Error('This is an unhandled exception');
  };

  return (
    <View style={styles.container}>
      <Text>Capture Unhandled Exceptions Example</Text>
      <Button title="Trigger Error" onPress={triggerError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

An unhandled exception will be triggered when the "Trigger Error" button is pressed. Bugsnag will capture the exception and send a detailed report to the Bugsnag dashboard.

### Example 3: Logging Custom Errors and Events

In addition to capturing unhandled exceptions, Bugsnag allows you to log custom errors and events. This feature is useful for tracking specific issues or monitoring important events in your application. By manually logging errors, you can gain insights into issues that may not result in crashes but still impact the user experience.

To log custom errors and events, use the `Bugsnag.notify` method. This example demonstrates how to log custom errors and events with additional context information.

#### Online Resources
1. [Bugsnag Custom Error Logging](https://docs.bugsnag.com/platforms/react-native/custom-errors/)
2. [Using Bugsnag to Log Events](https://docs.bugsnag.com/platforms/react-native/react-native/#logging-events)

#### Code to Practice

```javascript
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import Bugsnag from '@bugsnag/react-native';

Bugsnag.start();

const App = () => {
  const logCustomError = () => {
    Bugsnag.notify(new Error('This is a custom error'), event => {
      event.addMetadata('custom', { info: 'Additional context information' });
    });
  };

  const logCustomEvent = () => {
    Bugsnag.leaveBreadcrumb('User clicked the button', { category: 'user_action' });
  };

  return (
    <View style={styles.container}>
      <Text>Log Custom Errors and Events Example</Text>
      <Button title="Log Custom Error" onPress={logCustomError} />
      <Button title="Log Custom Event" onPress={logCustomEvent} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

Custom errors and events will be logged when the respective buttons are pressed. Bugsnag will capture these logs and send detailed reports to the Bugsnag dashboard, including additional context information for custom errors.

---

### Task 18: Study Real-Time Communication

Real-time communication (RTC) is a technology that allows for the instantaneous exchange of information between devices over the internet. This technology is commonly used in applications that require live updates or instant feedback, such as messaging apps, video conferencing, online gaming, and collaborative tools. By implementing RTC, developers can create more interactive and engaging user experiences, where users can see updates and interact with others in real time.

In React Native, real-time communication can be achieved using various protocols and libraries. WebSockets and WebRTC are two popular technologies for implementing RTC. WebSockets provide a full-duplex communication channel over a single, long-lived connection, making them ideal for real-time messaging and notifications. WebRTC, on the other hand, is specifically designed for peer-to-peer communication, enabling direct audio, video, and data sharing between devices. Understanding and implementing these technologies can significantly enhance the capabilities of your React Native applications.

#### Online Resources
1. [WebSockets in React Native](https://reactnative.dev/docs/network#using-websockets)
2. [WebRTC in React Native](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)

#### Examples to Practice

1. **Implementing a Basic WebSocket Connection**
2. **Building a Real-Time Chat Application**
3. **Creating a Peer-to-Peer Video Call with WebRTC**

### Example 1: Implementing a Basic WebSocket Connection

WebSockets provide a persistent connection between the client and server, allowing for bi-directional communication. This makes WebSockets ideal for real-time applications where instant data exchange is crucial. In React Native, you can use the built-in `WebSocket` API to establish and manage WebSocket connections.

To implement a basic WebSocket connection, you need to create a WebSocket instance, handle connection events, and send/receive messages. This example demonstrates how to set up a WebSocket connection in a React Native application and handle real-time data updates.

#### Online Resources
1. [Using WebSockets in React Native](https://reactnative.dev/docs/network#using-websockets)
2. [MDN WebSocket API](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)

#### Code to Practice

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [message, setMessage] = useState('No message received');

  useEffect(() => {
    const ws = new WebSocket('wss://echo.websocket.org');

    ws.onopen = () => {
      console.log('WebSocket connection opened');
      ws.send('Hello WebSocket');
    };

    ws.onmessage = (e) => {
      setMessage(e.data);
    };

    ws.onerror = (e) => {
      console.error('WebSocket error', e.message);
    };

    ws.onclose = (e) => {
      console.log('WebSocket connection closed', e.code, e.reason);
    };

    return () => {
      ws.close();
    };
  }, []);

  return (
    <View style={styles.container}>
      <Text>WebSocket Message: {message}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A screen displaying messages received from a WebSocket server. The initial message will be "Hello WebSocket," sent when the connection is established.

### Example 2: Building a Real-Time Chat Application

Real-time chat applications are a common use case for WebSockets. They allow users to send and receive messages instantly, creating an interactive communication experience. By using WebSockets, you can build a chat application where messages are sent and received in real time without the need for constant polling.

To build a real-time chat application, you need to establish a WebSocket connection, handle incoming and outgoing messages, and update the UI accordingly. This example demonstrates how to create a basic chat interface in a React Native application using WebSockets.

#### Online Resources
1. [React Native WebSocket Chat Example](https://blog.logrocket.com/implementing-websocket-communication-react-native/)
2. [Building a Chat App with WebSockets](https://www.sitepoint.com/how-to-build-a-react-js-chat-app/)

#### Code to Practice

```javascript
import React, { useEffect, useState } from 'react';
import { View, TextInput, Button, FlatList, Text, StyleSheet } from 'react-native';

const App = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);
  let ws;

  useEffect(() => {
    ws = new WebSocket('wss://echo.websocket.org');

    ws.onmessage = (e) => {
      setMessages((prevMessages) => [...prevMessages, e.data]);
    };

    ws.onerror = (e) => {
      console.error('WebSocket error', e.message);
    };

    ws.onclose = (e) => {
      console.log('WebSocket connection closed', e.code, e.reason);
    };

    return () => {
      ws.close();
    };
  }, []);

  const sendMessage = () => {
    if (ws.readyState === WebSocket.OPEN) {
      ws.send(message);
      setMessages((prevMessages) => [...prevMessages, message]);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
        keyExtractor={(item, index) => index.toString()}
      />
      <TextInput
        style={styles.input}
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  message: {
    padding: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginVertical: 8,
  },
});

export default App;
```

**Expected Output:**

A chat interface where users can type and send messages. Messages are displayed in a list and updated in real-time as they are sent and received.

### Example 3: Creating a Peer-to-Peer Video Call with WebRTC

WebRTC (Web Real-Time Communication) is a technology that enables peer-to-peer communication between browsers and mobile applications. It allows for direct audio, video, and data sharing between devices, making it ideal for building applications like video conferencing and live streaming. WebRTC provides high-quality, low-latency communication without requiring an intermediary server for data transfer.

To create a peer-to-peer video call application, you need to set up WebRTC connections between devices, handle media streams, and manage signaling for connection establishment. This example demonstrates how to implement a basic video call feature using the `react-native-webrtc` library.

#### Online Resources
1. [WebRTC in React Native](https://developer.mozilla.org/en-US/docs/Web/API/WebRTC_API)
2. [React Native WebRTC Example](https://github.com/react-native-webrtc/react-native-webrtc)

#### Code to Practice

```javascript
// Install react-native-webrtc package
// npm install react-native-webrtc

import React, { useEffect, useRef } from 'react';
import { View, Button, StyleSheet } from 'react-native';
import { mediaDevices, RTCPeerConnection, RTCView } from 'react-native-webrtc';

const App = () => {
  const localStreamRef = useRef(null);
  const remoteStreamRef = useRef(null);
  const peerConnection = useRef(null);

  useEffect(() => {
    const getMediaStream = async () => {
      const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
      localStreamRef.current.srcObject = stream;
      if (peerConnection.current) {
        stream.getTracks().forEach(track => peerConnection.current.addTrack(track, stream));
      }
    };

    peerConnection.current = new RTCPeerConnection();
    peerConnection.current.onaddstream = (event) => {
      remoteStreamRef.current.srcObject = event.stream;
    };

    getMediaStream();

    return () => {
      peerConnection.current.close();
    };
  }, []);

  const startCall = async () => {
    const offer = await peerConnection.current.createOffer();
    await peerConnection.current.setLocalDescription(offer);
    // Send offer to the remote peer using your signaling mechanism
  };

  return (
    <View style={styles.container}>
      <RTCView streamURL={localStreamRef.current?.toURL()} style={styles.rtc} />
      <RTCView streamURL={remoteStreamRef.current?.toURL()} style={styles.rtc} />
      <Button title="Start Call" onPress={startCall} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  rtc: {
    width: '100%',
    height: '40%',
    backgroundColor: '#000',
  },
});

export default App;
```

**Expected Output:**

A peer-to-peer video call interface where users can start a video call. The local and remote video streams are displayed, and the call is initiated using WebRTC.

---

### Task 19: Implement a Chat Feature with Socket.io

Socket.io is a library that enables real-time, bidirectional communication between clients and servers. It is particularly useful for building applications that require real-time updates, such as chat applications, live notifications, and collaborative tools. Socket.io provides a simple and reliable API for establishing WebSocket connections, with automatic fallback to HTTP long-polling for older browsers or network conditions where WebSockets are not supported. By leveraging Socket.io, developers can create interactive and dynamic applications that respond immediately to user actions and events.

In React Native, implementing a chat feature with Socket.io involves setting up a Socket.io server to handle incoming connections and messages and creating a client in your React Native application to connect to the server and exchange messages. The client and server communicate over a WebSocket connection, enabling real-time updates and instant messaging. By following best practices for Socket.io, such as handling connection events, managing message events, and ensuring proper error handling, developers can build robust and scalable chat applications.

#### Online Resources
1. [Socket.io Official Documentation](https://socket.io/docs/v4/)
2. [Building a Real-Time Chat App with React Native and Socket.io](https://dev.to/novu/building-a-real-time-chat-app-with-react-native-and-socket-io-3npk)

#### Examples to Practice

1. **Setting Up a Socket.io Server**
2. **Connecting to the Socket.io Server from a React Native App**
3. **Building the Chat Interface in React Native**

### Example 1: Setting Up a Socket.io Server

Setting up a Socket.io server involves installing the Socket.io library, creating a server instance, and configuring it to handle incoming connections and messages. The server listens for connection events from clients, manages message events to broadcast messages to connected clients, and handles disconnection events to manage the lifecycle of client connections.

To set up a Socket.io server, you need to create a Node.js application, install the Socket.io library, and write server-side code to manage WebSocket connections. This example demonstrates how to create a simple Socket.io server that listens for chat messages and broadcasts them to all connected clients.

#### Online Resources
1. [Socket.io Server API](https://socket.io/docs/v4/server-api/)
2. [Socket.io Chat Application Example](https://socket.io/get-started/chat)

#### Code to Practice

```javascript
// Install the required packages
// npm install express socket.io

const express = require('express');
const http = require('http');
const socketIo = require('socket.io');

const app = express();
const server = http.createServer(app);
const io = socketIo(server);

io.on('connection', (socket) => {
  console.log('New client connected');

  socket.on('chat message', (message) => {
    io.emit('chat message', message);
  });

  socket.on('disconnect', () => {
    console.log('Client disconnected');
  });
});

server.listen(3000, () => {
  console.log('Server is listening on port 3000');
});
```

**Expected Output:**

A Node.js server running on port 3000 that listens for chat messages from connected clients and broadcasts them to all clients. The server logs connections and disconnections to the console.

### Example 2: Connecting to the Socket.io Server from a React Native App

Connecting to a Socket.io server from a React Native application involves installing the Socket.io client library, creating a Socket.io client instance, and managing connection events and message events. The client establishes a WebSocket connection to the server, allowing it to send and receive real-time messages.

To connect to a Socket.io server, you need to install the Socket.io client library in your React Native project and write client-side code to handle connection events, send messages, and receive messages. This example demonstrates how to connect to a Socket.io server from a React Native app and handle real-time chat messages.

#### Online Resources
1. [Socket.io Client API](https://socket.io/docs/v4/client-api/)
2. [React Native and Socket.io Integration](https://medium.com/@flaviojmendes/socket-io-with-react-native-3703d1d41e1d)

#### Code to Practice

```javascript
// Install the Socket.io client package
// npm install socket.io-client

import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

const App = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on('chat message', (msg) => {
      setMessages((prevMessages) => [...prevMessages, msg]);
    });

    return () => {
      socket.off('chat message');
    };
  }, []);

  const sendMessage = () => {
    socket.emit('chat message', message);
    setMessage('');
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
        keyExtractor={(item, index) => index.toString()}
      />
      <TextInput
        style={styles.input}
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  message: {
    padding: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginVertical: 8,
  },
});

export default App;
```

**Expected Output:**

A React Native app that connects to the Socket.io server, sends chat messages, and displays messages in real-time. Messages are displayed in a list and updated as they are received.

### Example 3: Building the Chat Interface in React Native

Building the chat interface in a React Native application involves creating UI components to display messages, input fields for typing messages, and buttons for sending messages. The chat interface should update in real-time as messages are sent and received, providing a seamless user experience.

To build the chat interface, you need to create React Native components for displaying messages, handling user input, and managing message events. This example demonstrates how to create a complete chat interface in a React Native app, including sending and receiving messages using Socket.io.

#### Online Resources
1. [Building a Chat Interface in React Native](https://reactnative.dev/docs/intro-react-native-components)
2. [React Native Chat App Example](https://medium.com/@dmitrynozhenko/creating-chat-application-with-react-native-744d5d76702f)

#### Code to Practice

```javascript
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import io from 'socket.io-client';

const socket = io('http://localhost:3000');

const App = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    socket.on('chat message', (msg) => {
      setMessages((prevMessages) => [...prevMessages, msg]);
    });

    return () => {
      socket.off('chat message');
    };
  }, []);

  const sendMessage = () => {
    socket.emit('chat message', message);
    setMessage('');
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => <Text style={styles.message}>{item}</Text>}
        keyExtractor={(item, index) => index.toString()}
      />
      <TextInput
        style={styles.input}
        value={message}
        onChangeText={setMessage}
        placeholder="Type a message"
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  message: {
    padding: 8,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginVertical: 8,
  },
});

export default App;
```

**Expected Output:**

A React Native chat interface that allows users to send and receive messages in real-time using Socket.io. The interface includes a list of messages, an input field for typing messages, and a send button.

---

### Task 20: Review and Deploy the Final Project

Reviewing and deploying your React Native project is the final step in the development process. This involves thoroughly testing your application to ensure it is free of bugs, optimizing the code for performance, and preparing it for distribution on app stores. A comprehensive review helps catch any issues that might have been missed during development, while the deployment process ensures that your application meets all necessary guidelines and standards for release.

Deploying a React Native application involves several steps, including configuring app signing, setting up app store accounts, and building the final APK or IPA files. This process also includes setting up continuous integration and delivery (CI/CD) pipelines to automate builds and deployments, making it easier to manage updates and releases. By following best practices for review and deployment, you can ensure a smooth release process and deliver a high-quality product to your users.

#### Online Resources
1. [React Native Testing](https://reactnative.dev/docs/testing-overview)
2. [React Native Deployment](https://reactnative.dev/docs/publishing-to-app-store)

#### Examples to Practice

1. **Testing Your React Native Application**
2. **Optimizing Your React Native Application**
3. **Deploying Your React Native Application**

### Example 1: Testing Your React Native Application

Testing is a crucial step in reviewing your React Native application to ensure it functions as expected and is free of bugs. There are several types of tests you can perform, including unit tests, integration tests, and end-to-end tests. React Native supports popular testing libraries such as Jest for unit testing and Detox for end-to-end testing.

To test your React Native application, you need to write test cases that cover different parts of your application, run the tests, and review the results. This example demonstrates how to set up and run unit tests using Jest.

#### Online Resources
1. [Jest Documentation](https://jestjs.io/docs/en/getting-started)
2. [Testing React Native with Jest](https://reactnative.dev/docs/testing-overview#jest)

#### Code to Practice

```javascript
// Install Jest and the React Native testing library
// npm install jest @testing-library/react-native

// Add Jest configuration to package.json
{
  "scripts": {
    "test": "jest"
  },
  "jest": {
    "preset": "react-native",
    "setupFilesAfterEnv": ["@testing-library/jest-native/extend-expect"]
  }
}

// Example component (App.js)
import React from 'react';
import { View, Text } from 'react-native';

const App = () => (
  <View>
    <Text>Hello, World!</Text>
  </View>
);

export default App;

// Example test case (App.test.js)
import React from 'react';
import { render } from '@testing-library/react-native';
import App from './App';

test('renders hello world text', () => {
  const { getByText } = render(<App />);
  expect(getByText('Hello, World!')).toBeTruthy();
});
```

**Expected Output:**

Running `npm test` will execute the Jest tests and confirm that the "Hello, World!" text is rendered correctly.

### Example 2: Optimizing Your React Native Application

Optimizing your React Native application is essential for ensuring it performs well on a variety of devices. Optimization involves minimizing the app's bundle size, improving rendering performance, and reducing memory usage. Techniques such as code splitting, lazy loading, and using efficient data structures can help achieve these goals.

To optimize your React Native application, you need to identify performance bottlenecks and apply optimization techniques. This example demonstrates how to use the `react-native-bundle-visualizer` tool to analyze your app's bundle size and make improvements.

#### Online Resources
1. [React Native Performance Optimization](https://reactnative.dev/docs/performance)
2. [Using Hermes for React Native](https://reactnative.dev/docs/hermes)

#### Code to Practice

```bash
# Install the react-native-bundle-visualizer tool
npm install --save-dev react-native-bundle-visualizer

# Add a script to visualize the bundle
{
  "scripts": {
    "analyze-bundle": "react-native-bundle-visualizer"
  }
}

# Build the bundle and analyze it
npm run analyze-bundle
```

**Expected Output:**

Running `npm run analyze-bundle` will generate a visual representation of your app's bundle, helping you identify and reduce large dependencies.

### Example 3: Deploying Your React Native Application

Deploying your React Native application involves building the final APK or IPA files and submitting them to app stores. This process includes configuring app signing, setting up app store accounts, and preparing your app for distribution. Using tools like Fastlane can help automate the deployment process and streamline the workflow.

To deploy your React Native application, you need to follow the guidelines provided by app stores and use the appropriate tools for building and signing your app. This example demonstrates how to configure and use Fastlane for deploying a React Native app to the Google Play Store.

#### Online Resources
1. [Fastlane Documentation](https://docs.fastlane.tools/)
2. [Deploying React Native Apps](https://reactnative.dev/docs/publishing-to-app-store)

#### Code to Practice

```bash
# Install Fastlane
brew install fastlane

# Set up Fastlane in your project
cd android
fastlane init

# Example Fastfile for Android deployment
# fastlane/Fastfile
default_platform(:android)

platform :android do
  desc "Deploy to Google Play"
  lane :deploy do
    gradle(task: "assembleRelease")
    upload_to_play_store(track: "alpha")
  end
end

# Run the deployment script
fastlane android deploy
```

**Expected Output:**

Running `fastlane android deploy` will build the release APK, sign it, and upload it to the Google Play Store.

---

