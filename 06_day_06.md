for day 6, tasks listed between
"""
Study forms in React.<br>
Handle form state with `useState`.<br>
Implement controlled components.<br>
Learn about form validation.<br>
Create a form with validation.<br>
Study lifting state up.<br>
Lift state up to a common ancestor.<br>
Understand the concept of composition vs inheritance.<br>
Implement composition in components.<br>
Study performance optimization.<br>
Learn about React.memo.<br>
Use React.memo to optimize components.<br>
Study `useCallback` and `useMemo`.<br>
Practice using `useCallback` and `useMemo`.<br>
Learn about lazy loading components.<br>
Implement lazy loading with `React.lazy`.<br>
Use `Suspense` for fallback rendering.<br>
Study error boundaries.<br>
Create and use error boundaries.<br>
Review and build a more complex project using all covered concepts.<br>
""", for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output"""

---
### Task 1: Study forms in React

**Explanation:**
Forms are a fundamental part of web applications, allowing users to input and submit data. In React, forms work similarly to traditional HTML forms, but managing their state and handling submissions can be more controlled and efficient. React's approach to forms involves using controlled components, where form inputs are managed by the component state, making it easier to handle and validate form data.

Understanding how forms work in React is essential for creating interactive and dynamic applications. Forms can include various input types like text fields, checkboxes, radio buttons, and select dropdowns. Managing form state, handling submissions, and validating input data are key aspects of working with forms in React.

**Resources:**
- [React Official Documentation: Forms](https://reactjs.org/docs/forms.html)
- [W3Schools: React Forms](https://www.w3schools.com/react/react_forms.asp)

**Example 1:**
```javascript
import React, { useState } from 'react';

function SimpleForm() {
  const [name, setName] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted name: ${name}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" value={name} onChange={(e) => setName(e.target.value)} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default SimpleForm;
```

**Example Explanation:**
This example defines a `SimpleForm` component that uses the `useState` hook to manage the form state. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted name. The input field is a controlled component, with its value managed by the `name` state.

**Example 2:**
```javascript
import React, { useState } from 'react';

function MultiInputForm() {
  const [formData, setFormData] = useState({ firstName: '', lastName: '' });

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prevData) => ({ ...prevData, [name]: value }));
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted data: ${JSON.stringify(formData)}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        First Name:
        <input type="text" name="firstName" value={formData.firstName} onChange={handleChange} />
      </label>
      <br />
      <label>
        Last Name:
        <input type="text" name="lastName" value={formData.lastName} onChange={handleChange} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default MultiInputForm;
```

**Example Explanation:**
This example defines a `MultiInputForm` component that uses the `useState` hook to manage multiple form inputs. The `handleChange` function updates the form data state for each input field. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted data as a JSON string.

**Resources:**
- [MDN Web Docs: Handling Forms](https://developer.mozilla.org/en-US/docs/Learn/Forms/Handling_forms)
- [FreeCodeCamp: Controlled vs Uncontrolled Components](https://www.freecodecamp.org/news/controlled-vs-uncontrolled-components-in-react/)

**Expected Output:**
For Example 1:
```
Renders a form with a single input field and displays an alert with the submitted name when the form is submitted
```
For Example 2:
```
Renders a form with multiple input fields and displays an alert with the submitted data as a JSON string when the form is submitted
```

---

### Task 2: Handle form state with `useState`

**Explanation:**
Handling form state with `useState` involves using the `useState` hook to manage the values of form inputs. By creating state variables for each input field, you can easily track and update their values based on user input. This approach allows you to create controlled components, where the component state is the single source of truth for the input values.

Using `useState` to handle form state provides a clear and concise way to manage form data in React. It enables you to implement features like form validation, conditional rendering based on input values, and dynamic form fields. Additionally, it simplifies the process of handling form submissions and extracting the input data.

**Resources:**
- [React Official Documentation: Using the State Hook](https://reactjs.org/docs/hooks-state.html)
- [JavaScript.info: useState Hook](https://javascript.info/react-hooks#usestate-hook)

**Example 1:**
```javascript
import React, { useState } from 'react';

function EmailForm() {
  const [email, setEmail] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted email: ${email}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Email:
        <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default EmailForm;
```

**Example Explanation:**
This example defines an `EmailForm` component that uses the `useState` hook to manage the email input field. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted email. The input field is a controlled component, with its value managed by the `email` state.

**Example 2:**
```javascript
import React, { useState } from 'react';

function FeedbackForm() {
  const [feedback, setFeedback] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted feedback: ${feedback}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Feedback:
        <textarea value={feedback} onChange={(e) => setFeedback(e.target.value)} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default FeedbackForm;
```

**Example Explanation:**
This example defines a `FeedbackForm` component that uses the `useState` hook to manage the feedback textarea. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted feedback. The textarea is a controlled component, with its value managed by the `feedback` state.

**Resources:**
- [W3Schools: React useState Hook](https://www.w3schools.com/react/react_usestate.asp)
- [FreeCodeCamp: How to Use the useState Hook](https://www.freecodecamp.org/news/how-to-use-the-usestate-hook/)

**Expected Output:**
For Example 1:
```
Renders a form with an email input field and displays an alert with the submitted email when the form is submitted
```
For Example 2:
```
Renders a form with a feedback textarea and displays an alert with the submitted feedback when the form is submitted
```

---

### Task 3: Implement controlled components

**Explanation:**
Controlled components in React are form elements that are controlled by the component state. The value of each form element is set by the component state, and any changes to the input are handled by updating the state. This approach ensures that the component state is the single source of truth for the form data.

Implementing controlled components allows you to manage form state more effectively and perform tasks such as form validation, conditional rendering, and dynamic form fields. Controlled components provide a clear and predictable way to handle user input, making it easier to maintain and debug your forms.

**Resources:**
- [React Official Documentation: Forms](https://reactjs.org/docs/forms.html)
- [JavaScript.info: Controlled Components](https://javascript.info/react-forms#controlled-components)

**Example 1:**
```javascript
import React, { useState } from 'react';

function UsernameForm() {
  const [username, setUsername] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted username: ${username}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input type="text" value={username} onChange={(e) => setUsername(e.target.value)} />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default UsernameForm;
```

**Example Explanation:**
This example defines a `UsernameForm` component that uses the `useState` hook to manage the username input field. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted username. The input field is a controlled component, with its value managed by the `username` state.

**Example 2:**
```javascript
import React, { useState } from 'react';

function AgeForm() {
  const [age, setAge] = useState('');

  const handleSubmit = (e) => {
    e.preventDefault();
    alert(`Submitted age: ${age}`);
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Age:
        <input
          type="number"
          value={age}
          onChange={(e) => setAge(e.target.value)}
        />
      </label>
      <button type="submit">Submit</button>
    </form>
  );
}

export default AgeForm;
```

**Example Explanation:**
This example defines an `AgeForm` component that uses the `useState` hook to manage the age input field. The `handleSubmit` function prevents the default form submission behavior and displays an alert with the submitted age. The input field is a controlled component, with its value managed by the `age` state.

**Resources:**
- [MDN Web Docs: Controlled Components](https://developer.mozilla.org/en-US/docs/Web/HTML/Element/input#controlled_components)
- [FreeCodeCamp: Controlled vs Uncontrolled Components](https://www.freecodecamp.org/news/controlled-vs-uncontrolled-components-in-react/)

**Expected Output:**
For Example 1:
```
Renders a form with a username input field and displays an alert with the submitted username when the form is submitted
```
For Example 2:
```
Renders a form with an age input field and displays an alert with the submitted age when the form is submitted
```

---

### Task 4: Learn about form validation

**Explanation:**
Form validation ensures that user input meets specific criteria before the form is submitted. Validation can be performed on the client side using JavaScript and HTML5 attributes like `required`, `pattern`, and `minLength`. In React, form validation can be implemented using controlled components and state to manage validation logic.

Learning about form validation is essential for creating user-friendly and secure forms. Proper validation helps prevent errors, ensures data integrity, and enhances the user experience by providing immediate feedback on input errors.

**Resources:**
- [React Official Documentation: Forms](https://reactjs.org/docs/forms.html#controlled-components)
- [MDN Web Docs: Form Validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)

**Example 1:**
```javascript
import React, { useState } from 'react';

function EmailForm() {
  const [email, setEmail] = useState('');
  const [error, setError] = useState('');

  const validateEmail = (email) => {
    const re = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return re.test(String(email).toLowerCase());
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validateEmail(email)) {
      alert(`Submitted email: ${email}`);
    } else {
      setError('Invalid email address');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Email:
        <input type="email" value={email} onChange={(e) => setEmail(e.target.value)} />
      </label>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <button type="submit">Submit</button>
    </form>
  );
}

export default EmailForm;
```

**Example Explanation:**
This example defines an `EmailForm` component that uses the `useState` hook to manage the email input field and validation error. The `validateEmail` function checks if the email format is valid. The `handleSubmit` function validates the email before submission and displays an error message if the email is invalid.

**Example 2:**
```javascript
import React, { useState } from 'react';

function PasswordForm() {
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');

  const validatePassword = (password) => {
    return password.length >= 8;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    if (validatePassword(password)) {
      alert(`Submitted password: ${password}`);
    } else {
      setError('Password must be at least 8 characters long');
    }
  };

  return (
    <form onSubmit={handleSubmit}>
      <label:
        Password:
        <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
      </label>
      {error && <p style={{ color: 'red' }}>{error}</p>}
      <button type="submit">Submit</button>
    </form>
  );
}

export default PasswordForm;
```

**Example Explanation:**
This example defines a `PasswordForm` component that uses the `useState` hook to manage the password input field and validation error. The `validatePassword` function checks if the password is at least 8 characters long. The `handleSubmit` function validates the password before submission and displays an error message if the password is too short.

**Resources:**
- [W3Schools: Form Validation](https://www.w3schools.com/react/react_form_validation.asp)
- [FreeCodeCamp: Form Validation in React](https://www.freecodecamp.org/news/how-to-build-a-form-in-react-using-react-hook-form/)

**Expected Output:**
For Example 1:
```
Renders a form with an email input field and validates the email format before submission, displaying an error message if the email is invalid
```
For Example 2:
```
Renders a form with a password input field and validates the password length before submission, displaying an error message if the password is too short
```

---

### Task 5: Create a form with validation

**Explanation:**
Creating a form with validation involves implementing logic to check the input values against specific criteria before allowing the form to be submitted. Validation can include checking for required fields, ensuring the input format is correct, and enforcing length or value constraints. In React, form validation can be handled using controlled components and state to manage validation logic.

Creating a form with validation enhances the user experience by providing immediate feedback on input errors and ensuring data integrity. It helps prevent errors and improve the quality of data submitted through the form.

**Resources:**
- [React Official Documentation: Forms](https://reactjs.org/docs/forms.html#controlled-components)
- [MDN Web Docs: Form Validation](https://developer.mozilla.org/en-US/docs/Learn/Forms/Form_validation)

**Example 1:**
```javascript
import React, { useState } from 'react';

function RegistrationForm() {
  const [formData, setFormData] = useState({ username: '', email: '', password: '' });
  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};
    if (!formData.username) newErrors.username = 'Username is required';
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Invalid email address';
    }
    if (!formData.password) {
      newErrors.password = 'Password is required';
    } else if (formData.password.length < 8) {
      newErrors.password = 'Password must be at least 8 characters long';
    }
    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validate();
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
    } else {
      alert(`Submitted data: ${JSON.stringify(formData)}`);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prevData) => ({ ...prevData, [name]: value }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Username:
        <input type="text" name="username" value={formData.username} onChange={handleChange} />
        {errors.username && <p style={{ color: 'red' }}>{errors.username}</p>}
      </label>
      <br />
      <label>
        Email:
        <input type="email" name="email" value={formData.email} onChange={handleChange} />
        {errors.email && <p style={{ color: 'red' }}>{errors.email}</p>}
      </label>
      <br />
      <label>
        Password:
        <input type="password" name="password" value={formData.password} onChange={handleChange} />
        {errors.password && <p style={{ color: 'red' }}>{errors.password}</p>}
      </label>
      <br />
      <button type="submit">Register</button>
    </form>
  );
}

export default RegistrationForm;
```

**Example Explanation:**
This example defines a `RegistrationForm` component that uses the `useState` hook to manage the form data and validation errors. The `validate` function checks the input values for required fields, valid email format, and minimum password length. The `handleSubmit` function validates the form data before submission and displays validation errors if any.

**Example 2:**
```javascript
import React, { useState } from 'react';

function ContactForm() {
  const [formData, setFormData] = useState({ name: '', email: '', message: '' });
  const [errors, setErrors] = useState({});

  const validate = () => {
    const newErrors = {};
    if (!formData.name) newErrors.name = 'Name is required';
    if (!formData.email) {
      newErrors.email = 'Email is required';
    } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.email)) {
      newErrors.email = 'Invalid email address';
    }
    if (!formData.message) {
      newErrors.message =

 'Message is required';
    } else if (formData.message.length < 10) {
      newErrors.message = 'Message must be at least 10 characters long';
    }
    return newErrors;
  };

  const handleSubmit = (e) => {
    e.preventDefault();
    const validationErrors = validate();
    if (Object.keys(validationErrors).length > 0) {
      setErrors(validationErrors);
    } else {
      alert(`Submitted data: ${JSON.stringify(formData)}`);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setFormData((prevData) => ({ ...prevData, [name]: value }));
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>
        Name:
        <input type="text" name="name" value={formData.name} onChange={handleChange} />
        {errors.name && <p style={{ color: 'red' }}>{errors.name}</p>}
      </label>
      <br />
      <label>
        Email:
        <input type="email" name="email" value={formData.email} onChange={handleChange} />
        {errors.email && <p style={{ color: 'red' }}>{errors.email}</p>}
      </label>
      <br />
      <label>
        Message:
        <textarea name="message" value={formData.message} onChange={handleChange} />
        {errors.message && <p style={{ color: 'red' }}>{errors.message}</p>}
      </label>
      <br />
      <button type="submit">Send</button>
    </form>
  );
}

export default ContactForm;
```

**Example Explanation:**
This example defines a `ContactForm` component that uses the `useState` hook to manage the form data and validation errors. The `validate` function checks the input values for required fields, valid email format, and minimum message length. The `handleSubmit` function validates the form data before submission and displays validation errors if any.

**Resources:**
- [W3Schools: Form Validation](https://www.w3schools.com/react/react_form_validation.asp)
- [FreeCodeCamp: Form Validation in React](https://www.freecodecamp.org/news/how-to-build-a-form-in-react-using-react-hook-form/)

**Expected Output:**
For Example 1:
```
Renders a registration form with validation for username, email, and password fields and displays validation errors if any
```
For Example 2:
```
Renders a contact form with validation for name, email, and message fields and displays validation errors if any
```

---

### Task 6: Study lifting state up

**Explanation:**
Lifting state up is a pattern in React where the state is moved to a common ancestor component to share data between sibling components. This approach allows you to manage state in a centralized location and pass it down as props to the child components that need it. Lifting state up helps avoid duplication and keeps the state management logic in one place.

Studying lifting state up is important for understanding how to manage state in complex applications with multiple components. It allows you to create a clear data flow and ensures that components stay in sync with each other.

**Resources:**
- [React Official Documentation: Lifting State Up](https://reactjs.org/docs/lifting-state-up.html)
- [JavaScript.info: Lifting State Up](https://javascript.info/react-lifting-state-up)

**Example 1:**
```javascript
import React, { useState } from 'react';

function Parent() {
  const [sharedState, setSharedState] = useState('');

  return (
    <div>
      <Child1 sharedState={sharedState} setSharedState={setSharedState} />
      <Child2 sharedState={sharedState} />
    </div>
  );
}

function Child1({ sharedState, setSharedState }) {
  return (
    <div>
      <input
        type="text"
        value={sharedState}
        onChange={(e) => setSharedState(e.target.value)}
      />
    </div>
  );
}

function Child2({ sharedState }) {
  return <p>Shared State: {sharedState}</p>;
}

export default Parent;
```

**Example Explanation:**
This example demonstrates lifting state up by moving the `sharedState` to the `Parent` component. The `Parent` component passes the state and the setter function to `Child1`, which updates the state. `Child2` receives the shared state as a prop and displays it.

**Example 2:**
```javascript
import React, { useState } from 'react';

function TemperatureConverter() {
  const [temperature, setTemperature] = useState({ celsius: '', fahrenheit: '' });

  const handleCelsiusChange = (e) => {
    const celsius = e.target.value;
    setTemperature({
      celsius,
      fahrenheit: celsius ? (celsius * 9/5 + 32).toFixed(2) : ''
    });
  };

  const handleFahrenheitChange = (e) => {
    const fahrenheit = e.target.value;
    setTemperature({
      fahrenheit,
      celsius: fahrenheit ? ((fahrenheit - 32) * 5/9).toFixed(2) : ''
    });
  };

  return (
    <div>
      <CelsiusInput temperature={temperature.celsius} onTemperatureChange={handleCelsiusChange} />
      <FahrenheitInput temperature={temperature.fahrenheit} onTemperatureChange={handleFahrenheitChange} />
    </div>
  );
}

function CelsiusInput({ temperature, onTemperatureChange }) {
  return (
    <div>
      <label>
        Celsius:
        <input type="number" value={temperature} onChange={onTemperatureChange} />
      </label>
    </div>
  );
}

function FahrenheitInput({ temperature, onTemperatureChange }) {
  return (
    <div>
      <label:
        Fahrenheit:
        <input type="number" value={temperature} onChange={onTemperatureChange} />
      </label>
    </div>
  );
}

export default TemperatureConverter;
```

**Example Explanation:**
This example demonstrates lifting state up in a temperature converter application. The `TemperatureConverter` component manages the temperature state in both Celsius and Fahrenheit. The state and change handlers are passed down to the `CelsiusInput` and `FahrenheitInput` components, which update the state and display the converted values.

**Resources:**
- [W3Schools: Lifting State Up](https://www.w3schools.com/react/react_lifting_state.asp)
- [FreeCodeCamp: Lifting State Up in React](https://www.freecodecamp.org/news/react-lifting-state-up/)

**Expected Output:**
For Example 1:
```
Renders an input field in Child1 that updates the shared state and displays the shared state in Child2
```
For Example 2:
```
Renders a temperature converter with input fields for Celsius and Fahrenheit that update the shared state and display the converted values
```

---

### Task 7: Lift state up to a common ancestor

**Explanation:**
Lifting state up to a common ancestor involves moving the state to a parent component that is shared by multiple child components. This allows the parent component to manage the state and pass it down as props to the child components that need it. This approach ensures that the state is managed in a centralized location, avoiding duplication and keeping the state management logic in one place.

Lifting state up to a common ancestor is useful for sharing state between sibling components and creating a clear data flow. It helps ensure that components stay in sync and makes it easier to manage and update the state.

**Resources:**
- [React Official Documentation: Lifting State Up](https://reactjs.org/docs/lifting-state-up.html)
- [JavaScript.info: Lifting State Up](https://javascript.info/react-lifting-state-up)

**Example 1:**
```javascript
import React, { useState } from 'react';

function Parent() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <Counter count={count} setCount={setCount} />
      <Display count={count} />
    </div>
  );
}

function Counter({ count, setCount }) {
  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
    </div>
  );
}

function Display({ count }) {
  return <p>Count: {count}</p>;
}

export default Parent;
```

**Example Explanation:**
This example demonstrates lifting state up by moving the `count` state to the `Parent` component. The `Parent` component passes the state and the setter function to `Counter`, which updates the state. `Display` receives the shared state as a prop and displays it.

**Example 2:**
```javascript
import React, { useState } from 'react';

function ShoppingCart() {
  const [cart, setCart] = useState([]);

  const addItemToCart = (item) => {
    setCart((prevCart) => [...prevCart, item]);
  };

  return (
    <div>
      <ProductList addItemToCart={addItemToCart} />
      <Cart cart={cart} />
    </div>
  );
}

function ProductList({ addItemToCart }) {
  const products = ['Apple', 'Banana', 'Orange'];

  return (
    <div>
      <h2>Products</h2>
      <ul>
        {products.map((product) => (
          <li key={product}>
            {product} <button onClick={() => addItemToCart(product)}>Add to

 Cart</button>
          </li>
        ))}
      </ul>
    </div>
  );
}

function Cart({ cart }) {
  return (
    <div>
      <h2>Shopping Cart</h2>
      <ul>
        {cart.map((item, index) => (
          <li key={index}>{item}</li>
        ))}
      </ul>
    </div>
  );
}

export default ShoppingCart;
```

**Example Explanation:**
This example demonstrates lifting state up in a shopping cart application. The `ShoppingCart` component manages the cart state and provides the `addItemToCart` function. The `ProductList` component uses the `addItemToCart` function to add items to the cart. The `Cart` component receives the cart state as a prop and displays the items in the cart.

**Resources:**
- [W3Schools: Lifting State Up](https://www.w3schools.com/react/react_lifting_state.asp)
- [FreeCodeCamp: Lifting State Up in React](https://www.freecodecamp.org/news/react-lifting-state-up/)

**Expected Output:**
For Example 1:
```
Renders a button in Counter that increments the shared state and displays the shared state in Display
```
For Example 2:
```
Renders a shopping cart with a product list and a cart component that share the cart state
```

---

### Task 8: Understand the concept of composition vs inheritance

**Explanation:**
Composition and inheritance are two fundamental concepts in object-oriented programming and React development. Composition involves building complex components by combining simpler components. In React, composition is the preferred approach for reusing code and building component hierarchies. It allows you to create flexible and maintainable components by passing props and children to compose new components.

Inheritance, on the other hand, involves creating new components by extending existing ones. While inheritance can be useful in some cases, it can lead to tightly coupled components and less flexible code. In React, composition is generally favored over inheritance because it promotes better separation of concerns and easier code reuse.

**Resources:**
- [React Official Documentation: Composition vs Inheritance](https://reactjs.org/docs/composition-vs-inheritance.html)
- [JavaScript.info: Composition vs Inheritance](https://javascript.info/composition-vs-inheritance)

**Example 1:**
```javascript
import React from 'react';

function WelcomeMessage({ user }) {
  return <h1>Welcome, {user.name}!</h1>;
}

function App() {
  const user = { name: 'John' };

  return (
    <div>
      <WelcomeMessage user={user} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates composition by passing a `user` prop to the `WelcomeMessage` component. The `App` component composes the `WelcomeMessage` component and passes the `user` object as a prop.

**Example 2:**
```javascript
import React from 'react';

function Button({ children, onClick }) {
  return <button onClick={onClick}>{children}</button>;
}

function App() {
  return (
    <div>
      <Button onClick={() => alert('Button clicked!')}>Click Me</Button>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates composition by using the `children` prop to pass the button text to the `Button` component. The `App` component composes the `Button` component and passes an `onClick` handler and the button text as children.

**Resources:**
- [W3Schools: React Composition vs Inheritance](https://www.w3schools.com/react/react_composition.asp)
- [FreeCodeCamp: Understanding Composition vs Inheritance in React](https://www.freecodecamp.org/news/composition-vs-inheritance-in-react/)

**Expected Output:**
For Example 1:
```
Renders a welcome message using composition to pass the user prop to the WelcomeMessage component
```
For Example 2:
```
Renders a button using composition to pass the button text as children to the Button component
```

---

### Task 9: Implement composition in components

**Explanation:**
Implementing composition in components involves building complex components by combining simpler components and passing props or children to compose new components. Composition allows you to create flexible and maintainable components that can be easily reused and customized.

Using composition in React helps you build a clear component hierarchy and promotes better separation of concerns. It allows you to create small, focused components that can be combined to build more complex functionality.

**Resources:**
- [React Official Documentation: Composition vs Inheritance](https://reactjs.org/docs/composition-vs-inheritance.html)
- [JavaScript.info: Composition vs Inheritance](https://javascript.info/composition-vs-inheritance)

**Example 1:**
```javascript
import React from 'react';

function Card({ children }) {
  return <div className="card">{children}</div>;
}

function App() {
  return (
    <div>
      <Card>
        <h2>Card Title</h2>
        <p>Card content goes here.</p>
      </Card>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates composition by using the `children` prop to pass the card content to the `Card` component. The `App` component composes the `Card` component and passes the card title and content as children.

**Example 2:**
```javascript
import React from 'react';

function Layout({ header, content, footer }) {
  return (
    <div>
      <header>{header}</header>
      <main>{content}</main>
      <footer>{footer}</footer>
    </div>
  );
}

function App() {
  return (
    <Layout
      header={<h1>Header</h1>}
      content={<p>Main content goes here.</p>}
      footer={<p>Footer content goes here.</p>}
    />
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates composition by using props to pass the header, content, and footer to the `Layout` component. The `App` component composes the `Layout` component and passes the header, content, and footer as props.

**Resources:**
- [W3Schools: React Composition](https://www.w3schools.com/react/react_composition.asp)
- [FreeCodeCamp: Understanding Composition in React](https://www.freecodecamp.org/news/composition-in-react/)

**Expected Output:**
For Example 1:
```
Renders a card component using composition to pass the card title and content as children to the Card component
```
For Example 2:
```
Renders a layout component using composition to pass the header, content, and footer as props to the Layout component
```

---

### Task 10: Study performance optimization

**Explanation:**
Performance optimization in React involves various techniques to improve the performance of your application. Common optimization strategies include memoizing components to prevent unnecessary re-renders, using the `useMemo` and `useCallback` hooks to memoize values and functions, and lazy loading components to reduce the initial load time.

Studying performance optimization helps you build faster and more efficient React applications. It allows you to identify and address performance bottlenecks, ensuring that your application remains responsive and performs well under different conditions.

**Resources:**
- [React Official Documentation: Optimizing Performance](https://reactjs.org/docs/optimizing-performance.html)
- [JavaScript.info: Performance Optimization](https://javascript.info/react-performance)

**Example 1:**
```javascript
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ number }) {
  const calculate = (num) => {
    console.log('Calculating...');
    return num * 2;
  };

  const result = useMemo(() => calculate(number), [number]);

  return <p>Result: {result}</p>;
}

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ExpensiveCalculation number={count} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates performance optimization by using the `useMemo` hook to memoize the result of an expensive calculation. The `ExpensiveCalculation` component only recalculates the result when the `number` prop changes, preventing unnecessary recalculations.

**Example 2:**
```javascript
import React, { useState, useCallback } from 'react';

function Button({ onClick }) {
  return <button onClick={onClick}>Click Me</button>;
}

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={handleClick} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates performance optimization by using the `useCallback` hook to memoize the `handleClick` function. The `Button` component receives the memoized function as a prop, preventing unnecessary re-renders.

**Resources:**
- [W3Schools: React Performance Optimization](https://www.w3schools.com/react/react_performance.asp)
- [FreeCodeCamp: React Performance Optimization Techniques](https://www.freecodecamp.org/news/react-performance-optimization-techniques/)

**Expected Output:**
For Example 1:
``:
Renders a button

 and an expensive calculation result, memoizing the calculation result to prevent unnecessary recalculations
```
For Example 2:
``:
Renders a button and a count value, memoizing the click handler to prevent unnecessary re-renders of the Button component
```

---

### Task 11: Learn about React.memo

**Explanation:**
`React.memo` is a higher-order component that memoizes the output of a functional component, preventing it from re-rendering if its props have not changed. This optimization technique is useful for improving the performance of components that receive the same props frequently.

Learning about `React.memo` helps you optimize your React applications by reducing unnecessary re-renders. It is especially beneficial for components that are computationally expensive or that render large parts of the UI.

**Resources:**
- [React Official Documentation: React.memo](https://reactjs.org/docs/react-api.html#reactmemo)
- [JavaScript.info: React.memo](https://javascript.info/react-memo)

**Example 1:**
```javascript
import React, { useState } from 'react';

const Button = React.memo(({ onClick, children }) => {
  console.log('Button rendered');
  return <button onClick={onClick}>{children}</button>;
});

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <Button onClick={() => alert('Button clicked!')}>Click Me</Button>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `React.memo` to memoize the `Button` component. The `Button` component only re-renders if its `onClick` or `children` props change. The console log shows when the `Button` component is rendered, indicating that it does not re-render when the `count` state changes.

**Example 2:**
```javascript
import React, { useState } from 'react';

const List = React.memo(({ items }) => {
  console.log('List rendered');
  return (
    <ul>
      {items.map((item, index) => (
        <li key={index}>{item}</li>
      ))}
    </ul>
  );
});

function App() {
  const [items, setItems] = useState(['Apple', 'Banana', 'Orange']);
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <List items={items} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `React.memo` to memoize the `List` component. The `List` component only re-renders if its `items` prop changes. The console log shows when the `List` component is rendered, indicating that it does not re-render when the `count` state changes.

**Resources:**
- [W3Schools: React.memo](https://www.w3schools.com/react/react_memo.asp)
- [FreeCodeCamp: How to Use React.memo](https://www.freecodecamp.org/news/react-memo-how-to-use-memo-and-memoi/)

**Expected Output:**
For Example 1:
```
Renders a button that does not re-render when the count state changes due to memoization with React.memo
```
For Example 2:
```
Renders a list that does not re-render when the count state changes due to memoization with React.memo
```

---

### Task 12: Use React.memo to optimize components

**Explanation:**
Using `React.memo` to optimize components involves wrapping functional components with `React.memo` to memoize their output. This prevents the component from re-rendering if its props have not changed, reducing unnecessary renders and improving performance.

Optimizing components with `React.memo` helps you build more efficient React applications by reducing the workload on the rendering engine. It is particularly useful for components that are expensive to render or that render large parts of the UI.

**Resources:**
- [React Official Documentation: React.memo](https://reactjs.org/docs/react-api.html#reactmemo)
- [JavaScript.info: React.memo](https://javascript.info/react-memo)

**Example 1:**
```javascript
import React, { useState } from 'react';

const ExpensiveComponent = React.memo(({ number }) => {
  console.log('ExpensiveComponent rendered');
  const result = number * 2;
  return <p>Result: {result}</p>;
});

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ExpensiveComponent number={count} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `React.memo` to optimize the `ExpensiveComponent`. The `ExpensiveComponent` only re-renders if its `number` prop changes. The console log shows when the `ExpensiveComponent` is rendered, indicating that it does not re-render when the `count` state changes.

**Example 2:**
```javascript
import React, { useState } from 'react';

const UserList = React.memo(({ users }) => {
  console.log('UserList rendered');
  return (
    <ul>
      {users.map((user) => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
});

function App() {
  const [users, setUsers] = useState([
    { id: 1, name: 'John' },
    { id: 2, name: 'Jane' },
    { id: 3, name: 'Alice' }
  ]);
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <UserList users={users} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `React.memo` to optimize the `UserList` component. The `UserList` component only re-renders if its `users` prop changes. The console log shows when the `UserList` component is rendered, indicating that it does not re-render when the `count` state changes.

**Resources:**
- [W3Schools: React.memo](https://www.w3schools.com/react/react_memo.asp)
- [FreeCodeCamp: How to Use React.memo](https://www.freecodecamp.org/news/react-memo-how-to-use-memo-and-memoi/)

**Expected Output:**
For Example 1:
```
Renders an expensive component that does not re-render when the count state changes due to memoization with React.memo
```
For Example 2:
```
Renders a user list that does not re-render when the count state changes due to memoization with React.memo
```

---

### Task 13: Study `useCallback` and `useMemo`

**Explanation:**
`useCallback` and `useMemo` are hooks in React that help optimize performance by memoizing functions and values. `useCallback` returns a memoized version of a callback function, preventing it from being recreated on every render. `useMemo` returns a memoized value, recomputing it only when its dependencies change.

Studying `useCallback` and `useMemo` is important for understanding how to optimize React applications by reducing unnecessary re-renders and recomputations. These hooks help you build efficient and performant components.

**Resources:**
- [React Official Documentation: useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)
- [React Official Documentation: useMemo](https://reactjs.org/docs/hooks-reference.html#usememo)

**Example 1:**
```javascript
import React, { useState, useCallback } from 'react';

function Button({ onClick, children }) {
  return <button onClick={onClick}>{children}</button>;
}

function App() {
  const [count, setCount] = useState(0);

  const handleClick = useCallback(() => {
    setCount((prevCount) => prevCount + 1);
  }, []);

  return (
    <div>
      <p>Count: {count}</p>
      <Button onClick={handleClick}>Increment</Button>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using the `useCallback` hook to memoize the `handleClick` function. The `handleClick` function is only recreated if the dependencies change, preventing unnecessary re-renders of the `Button` component.

**Example 2:**
```javascript
import React, { useState, useMemo } from 'react';

function ExpensiveCalculation({ number }) {
  const calculate = (num) => {
    console.log('Calculating...');
    return num * 2;
  };

  const result = useMemo(() => calculate(number), [number]);

  return <p>Result: {result}</p>;
}

function App() {
  const [count, setCount] = useState(0);

  return (
    <div>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <ExpensiveCalculation number={count} />
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using the `useMemo` hook to memoize the result of an expensive calculation. The `ExpensiveCalculation` component only recalculates the result when the

 `number` prop changes, preventing unnecessary recalculations.

**Resources:**
- [W3Schools: useCallback Hook](https://www.w3schools.com/react/react_usecallback.asp)
- [W3Schools: useMemo Hook](https://www.w3schools.com/react/react_usememo.asp)

**Expected Output:**
For Example 1:
```
Renders a button and a count value, memoizing the click handler to prevent unnecessary re-renders of the Button component
```
For Example 2:
```
Renders an expensive calculation result, memoizing the calculation result to prevent unnecessary recalculations
```

---

### Task 14: Practice using `useCallback` and `useMemo`

**Explanation:**
Practicing using `useCallback` and `useMemo` involves applying these hooks in your components to memoize functions and values. By using these hooks, you can optimize your components to prevent unnecessary re-renders and recomputations, improving the performance of your application.

Practicing `useCallback` and `useMemo` helps you become proficient in identifying performance bottlenecks and implementing optimization techniques. It allows you to build efficient and performant React applications.

**Resources:**
- [React Official Documentation: useCallback](https://reactjs.org/docs/hooks-reference.html#usecallback)
- [React Official Documentation: useMemo](https://reactjs.org/docs/hooks-reference.html#usememo)

**Example 1:**
```javascript
import React, { useState, useCallback, useMemo } from 'react';

function ItemList({ items, onItemClick }) {
  return (
    <ul>
      {items.map((item) => (
        <li key={item} onClick={() => onItemClick(item)}>
          {item}
        </li>
      ))}
    </ul>
  );
}

function App() {
  const [items, setItems] = useState(['Apple', 'Banana', 'Orange']);
  const [selectedItem, setSelectedItem] = useState('');

  const handleItemClick = useCallback((item) => {
    setSelectedItem(item);
  }, []);

  const memoizedItems = useMemo(() => items, [items]);

  return (
    <div>
      <ItemList items={memoizedItems} onItemClick={handleItemClick} />
      <p>Selected Item: {selectedItem}</p>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates practicing using `useCallback` and `useMemo`. The `handleItemClick` function is memoized using `useCallback`, and the `items` array is memoized using `useMemo`. This prevents unnecessary re-renders and recomputations in the `ItemList` component.

**Example 2:**
```javascript
import React, { useState, useCallback, useMemo } from 'react';

function NumberList({ numbers, onNumberClick }) {
  return (
    <ul>
      {numbers.map((number) => (
        <li key={number} onClick={() => onNumberClick(number)}>
          {number}
        </li>
      ))}
    </ul>
  );
}

function App() {
  const [numbers, setNumbers] = useState([1, 2, 3, 4, 5]);
  const [selectedNumber, setSelectedNumber] = useState(null);

  const handleNumberClick = useCallback((number) => {
    setSelectedNumber(number);
  }, []);

  const memoizedNumbers = useMemo(() => numbers, [numbers]);

  return (
    <div>
      <NumberList numbers={memoizedNumbers} onNumberClick={handleNumberClick} />
      <p>Selected Number: {selectedNumber}</p>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates practicing using `useCallback` and `useMemo`. The `handleNumberClick` function is memoized using `useCallback`, and the `numbers` array is memoized using `useMemo`. This prevents unnecessary re-renders and recomputations in the `NumberList` component.

**Resources:**
- [W3Schools: useCallback Hook](https://www.w3schools.com/react/react_usecallback.asp)
- [W3Schools: useMemo Hook](https://www.w3schools.com/react/react_usememo.asp)

**Expected Output:**
For Example 1:
```
Renders a list of items and displays the selected item, memoizing the item click handler and the items array to prevent unnecessary re-renders
```
For Example 2:
```
Renders a list of numbers and displays the selected number, memoizing the number click handler and the numbers array to prevent unnecessary re-renders
```

---

### Task 15: Learn about lazy loading components

**Explanation:**
Lazy loading components in React involves loading components only when they are needed, reducing the initial load time of your application. This can be achieved using the `React.lazy` function and the `Suspense` component to handle fallback rendering while the component is being loaded.

Learning about lazy loading components helps you optimize your React applications by reducing the amount of code that needs to be loaded upfront. This improves the performance and user experience, especially for large applications with many components.

**Resources:**
- [React Official Documentation: Code-Splitting](https://reactjs.org/docs/code-splitting.html#reactlazy)
- [JavaScript.info: Lazy Loading](https://javascript.info/react-lazy-loading)

**Example 1:**
```javascript
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates lazy loading a component using `React.lazy`. The `LazyComponent` is only loaded when it is needed, and the `Suspense` component provides a fallback rendering while the component is being loaded.

**Example 2:**
```javascript
import React, { Suspense } from 'react';

const LazyImage = React.lazy(() => import('./LazyImage'));

function App() {
  return (
    <div>
      <h1>Image Gallery</h1>
      <Suspense fallback={<div>Loading image...</div>}>
        <LazyImage />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates lazy loading an image component using `React.lazy`. The `LazyImage` component is only loaded when it is needed, and the `Suspense` component provides a fallback rendering while the image component is being loaded.

**Resources:**
- [W3Schools: React.lazy](https://www.w3schools.com/react/react_lazy.asp)
- [FreeCodeCamp: Lazy Loading in React](https://www.freecodecamp.org/news/react-lazy-loading/)

**Expected Output:**
For Example 1:
```
Renders a heading and lazy loads a component, displaying a loading message while the component is being loaded
```
For Example 2:
```
Renders a heading and lazy loads an image component, displaying a loading message while the image component is being loaded
```

---

### Task 16: Implement lazy loading with `React.lazy`

**Explanation:**
Implementing lazy loading with `React.lazy` involves using the `React.lazy` function to load components dynamically and the `Suspense` component to handle fallback rendering. This approach helps optimize the performance of your application by reducing the initial load time and loading components only when they are needed.

Implementing lazy loading improves the user experience by reducing the time it takes to load the initial page and allowing the application to load additional components on demand. This is particularly useful for large applications with many components.

**Resources:**
- [React Official Documentation: Code-Splitting](https://reactjs.org/docs/code-splitting.html#reactlazy)
- [JavaScript.info: Lazy Loading](https://javascript.info/react-lazy-loading)

**Example 1:**
```javascript
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates implementing lazy loading with `React.lazy`. The `LazyComponent` is loaded dynamically, and the `Suspense` component provides a fallback rendering while the component is being loaded.

**Example 2:**
```javascript
import React, { Suspense } from 'react';

const LazyPage = React.lazy(() => import('./LazyPage'));

function App() {
  return (
    <div>
      <h1>My Application</h1>
      <Suspense fallback={<div>Loading page...</div>}>
        <LazyPage />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates implementing lazy loading for a page component using `React.lazy`. The `LazyPage` component is loaded dynamically, and the `Suspense` component provides a fallback rendering while the page component is being loaded.

**Resources:**
- [W3Schools: React.lazy](https://www.w3schools.com/react/react_lazy.asp)
- [FreeCodeCamp: Lazy Loading in React](https://www.freecodecamp.org/news/react-lazy-loading/)

**Expected Output:**
For Example 1:
```
Renders a heading and lazy

 loads a component, displaying a loading message while the component is being loaded
```
For Example 2:
```
Renders a heading and lazy loads a page component, displaying a loading message while the page component is being loaded
```

---

### Task 17: Use `Suspense` for fallback rendering

**Explanation:**
`Suspense` is a component in React that provides a fallback UI while a lazy-loaded component is being loaded. It works in conjunction with `React.lazy` to dynamically load components and display a loading message or spinner during the loading process.

Using `Suspense` for fallback rendering helps improve the user experience by providing visual feedback while components are being loaded. It ensures that users are informed about the loading state and can see a placeholder content instead of a blank screen.

**Resources:**
- [React Official Documentation: Code-Splitting](https://reactjs.org/docs/code-splitting.html#suspense)
- [JavaScript.info: Suspense](https://javascript.info/react-suspense)

**Example 1:**
```javascript
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <h1>My App</h1>
      <Suspense fallback={<div>Loading...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `Suspense` for fallback rendering while the `LazyComponent` is being loaded. The `Suspense` component displays a loading message until the `LazyComponent` is fully loaded.

**Example 2:**
```javascript
import React, { Suspense } from 'react';

const LazyImage = React.lazy(() => import('./LazyImage'));

function App() {
  return (
    <div>
      <h1>Image Gallery</h1>
      <Suspense fallback={<div>Loading image...</div>}>
        <LazyImage />
      </Suspense>
    </div>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using `Suspense` for fallback rendering while the `LazyImage` component is being loaded. The `Suspense` component displays a loading message until the `LazyImage` is fully loaded.

**Resources:**
- [W3Schools: React Suspense](https://www.w3schools.com/react/react_suspense.asp)
- [FreeCodeCamp: How to Use React Suspense](https://www.freecodecamp.org/news/how-to-use-react-suspense/)

**Expected Output:**
For Example 1:
```
Renders a heading and lazy loads a component, displaying a loading message while the component is being loaded
```
For Example 2:
```
Renders a heading and lazy loads an image component, displaying a loading message while the image component is being loaded
```

---

### Task 18: Study error boundaries

**Explanation:**
Error boundaries are React components that catch JavaScript errors in their child component tree, log those errors, and display a fallback UI instead of crashing the entire application. Error boundaries are implemented using the `componentDidCatch` lifecycle method and the `static getDerivedStateFromError` method.

Studying error boundaries is important for building resilient React applications. They help prevent the entire application from crashing due to errors in a specific part of the component tree, providing a better user experience and easier debugging.

**Resources:**
- [React Official Documentation: Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
- [JavaScript.info: Error Boundaries](https://javascript.info/react-error-boundaries)

**Example 1:**
```javascript
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, 'Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function FaultyComponent() {
  throw new Error('An error occurred!');
  return <div>Faulty Component</div>;
}

function App() {
  return (
    <ErrorBoundary>
      <FaultyComponent />
    </ErrorBoundary>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using an error boundary to catch errors in the `FaultyComponent`. The `ErrorBoundary` component catches the error, logs it, and displays a fallback UI. The `App` component wraps the `FaultyComponent` with the `ErrorBoundary`.

**Example 2:**
```javascript
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, 'Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function SafeComponent() {
  return <div>Safe Component</div>;
}

function App() {
  return (
    <ErrorBoundary>
      <SafeComponent />
      <FaultyComponent />
    </ErrorBoundary>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates using an error boundary to catch errors in the `FaultyComponent` while rendering the `SafeComponent` correctly. The `ErrorBoundary` component catches the error in the `FaultyComponent` and displays a fallback UI, but the `SafeComponent` is rendered without issues.

**Resources:**
- [W3Schools: React Error Boundaries](https://www.w3schools.com/react/react_error_boundaries.asp)
- [FreeCodeCamp: Error Boundaries in React](https://www.freecodecamp.org/news/react-error-boundaries/)

**Expected Output:**
For Example 1:
```
Renders a fallback UI when an error occurs in the FaultyComponent, preventing the entire application from crashing
```
For Example 2:
```
Renders the SafeComponent correctly and a fallback UI when an error occurs in the FaultyComponent, preventing the entire application from crashing
```

---

### Task 19: Create and use error boundaries

**Explanation:**
Creating and using error boundaries in React involves defining a component that catches JavaScript errors in its child component tree, logs those errors, and displays a fallback UI. Error boundaries are implemented using the `componentDidCatch` lifecycle method and the `static getDerivedStateFromError` method.

Using error boundaries helps you build resilient React applications by preventing the entire application from crashing due to errors in specific components. They provide a better user experience and make it easier to debug and handle errors.

**Resources:**
- [React Official Documentation: Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
- [JavaScript.info: Error Boundaries](https://javascript.info/react-error-boundaries)

**Example 1:**
```javascript
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, 'Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function FaultyComponent() {
  throw new Error('An error occurred!');
  return <div>Faulty Component</div>;
}

function App() {
  return (
    <ErrorBoundary>
      <FaultyComponent />
    </ErrorBoundary>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates creating and using an error boundary to catch errors in the `FaultyComponent`. The `ErrorBoundary` component catches the error, logs it, and displays a fallback UI. The `App` component wraps the `FaultyComponent` with the `ErrorBoundary`.

**Example 2:**
```javascript
import React, { Component } from 'react';

class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, 'Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function SafeComponent() {
  return <div>Safe Component</div>;
}

function FaultyComponent() {
  throw new Error('An error occurred!');
  return <div>Faulty Component</div>;
}

function App() {
  return (
    <ErrorBoundary>
      <SafeComponent />
      <FaultyComponent />
    </ErrorBoundary>
  );
}

export default App;
```

**Example Explanation:**
This example demonstrates creating and using an error boundary to catch errors in the `FaultyComponent` while rendering the `SafeComponent` correctly. The `ErrorBoundary` component catches the error in the `Faulty

Component` and displays a fallback UI, but the `SafeComponent` is rendered without issues.

**Resources:**
- [W3Schools: React Error Boundaries](https://www.w3schools.com/react/react_error_boundaries.asp)
- [FreeCodeCamp: Error Boundaries in React](https://www.freecodecamp.org/news/react-error-boundaries/)

**Expected Output:**
For Example 1:
```
Renders a fallback UI when an error occurs in the FaultyComponent, preventing the entire application from crashing
```
For Example 2:
```
Renders the SafeComponent correctly and a fallback UI when an error occurs in the FaultyComponent, preventing the entire application from crashing
```

---

### Task 20: Review and build a more complex project using all covered concepts

**Explanation:**
Reviewing and building a more complex project using all covered concepts involves applying what you have learned about forms, state management, performance optimization, lazy loading, and error handling in a single project. This helps reinforce your knowledge and provides a practical context for how these concepts work together.

Building a more complex project allows you to see the interactions between different concepts and identify best practices for managing state, optimizing performance, handling errors, and implementing lazy loading in a real-world application.

**Resources:**
- [React Official Documentation](https://reactjs.org/docs/getting-started.html)
- [JavaScript.info: React](https://javascript.info/react)

**Example Project:**
```javascript
import React, { useState, useCallback, useMemo, lazy, Suspense, Component } from 'react';

// Lazy loaded components
const LazyProfile = lazy(() => import('./LazyProfile'));
const LazyDashboard = lazy(() => import('./LazyDashboard'));

// Error boundary component
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log('Error:', error, 'Info:', errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Something went wrong.</h1>;
    }
    return this.props.children;
  }
}

function App() {
  const [user, setUser] = useState({ name: '', email: '' });
  const [count, setCount] = useState(0);

  const handleInputChange = useCallback((e) => {
    const { name, value } = e.target;
    setUser((prevUser) => ({ ...prevUser, [name]: value }));
  }, []);

  const memoizedUser = useMemo(() => user, [user]);

  return (
    <div>
      <h1>Complex Project</h1>
      <form>
        <label>
          Name:
          <input type="text" name="name" value={user.name} onChange={handleInputChange} />
        </label>
        <br />
        <label>
          Email:
          <input type="email" name="email" value={user.email} onChange={handleInputChange} />
        </label>
      </form>
      <p>User: {JSON.stringify(memoizedUser)}</p>
      <button onClick={() => setCount(count + 1)}>Increment</button>
      <p>Count: {count}</p>
      <ErrorBoundary>
        <Suspense fallback={<div>Loading Profile...</div>}>
          <LazyProfile user={memoizedUser} />
        </Suspense>
        <Suspense fallback={<div>Loading Dashboard...</div>}>
          <LazyDashboard count={count} />
        </Suspense>
      </ErrorBoundary>
    </div>
  );
}

export default App;
```

**Project Breakdown:**
- **Forms and State Management:** The form manages user input for name and email using the `useState` hook and controlled components.
- **Performance Optimization:** The `handleInputChange` function is memoized using `useCallback`, and the user object is memoized using `useMemo`.
- **Lazy Loading:** The `LazyProfile` and `LazyDashboard` components are lazy-loaded using `React.lazy`, with fallback rendering using `Suspense`.
- **Error Boundaries:** The `ErrorBoundary` component catches errors in the lazy-loaded components and displays a fallback UI.

**Resources:**
- [W3Schools: React](https://www.w3schools.com/react/)
- [FreeCodeCamp: React](https://www.freecodecamp.org/news/tag/react/)

**Expected Output:**
```
A complex React project that integrates forms, state management, performance optimization, lazy loading, and error boundaries
```
---
