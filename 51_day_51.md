### Task 1: Review Advanced State Management with Recoil

Recoil is a state management library for React that provides a powerful and flexible way to manage state in complex applications. Unlike other state management libraries, Recoil is built to seamlessly integrate with React’s concurrent mode and offer fine-grained control over state updates. Recoil introduces the concept of atoms, which are units of state, and selectors, which are derived state that can be computed based on atoms or other selectors. This allows developers to manage global state efficiently and reactively, ensuring that components are re-rendered only when necessary.

Recoil's architecture makes it ideal for managing state in large-scale applications, where performance and scalability are crucial. It supports asynchronous data fetching, dependency tracking, and state persistence out of the box. By leveraging Recoil, developers can create more maintainable and scalable state management solutions, reducing the complexity of managing state across different components and features.

#### Online Resources
1. [Recoil Official Documentation](https://recoiljs.org/docs/introduction/getting-started)
2. [Managing State in React with Recoil](https://blog.logrocket.com/manage-state-react-recoil/)

#### Examples to Practice

1. **Setting Up Recoil in a React Native Project**
2. **Creating and Using Atoms in Recoil**
3. **Implementing Selectors for Derived State**

### Example 1: Setting Up Recoil in a React Native Project

Setting up Recoil in a React Native project involves installing the Recoil library and wrapping your application with the `RecoilRoot` component. This provides the necessary context for using Recoil’s state management capabilities. By setting up Recoil, you can start creating atoms and selectors to manage your application’s state efficiently.

To set up Recoil, you need to install the Recoil package and configure your application to use `RecoilRoot`. This example demonstrates how to set up Recoil in a React Native project and verify that it is working correctly.

#### Online Resources
1. [Recoil Getting Started Guide](https://recoiljs.org/docs/introduction/getting-started)
2. [Recoil Setup in React Native](https://recoiljs.org/docs/basic-tutorial/intro)

#### Code to Practice

```bash
# Install Recoil package
npm install recoil

# Example App setup (App.js)
import React from 'react';
import { RecoilRoot } from 'recoil';
import { View, Text, StyleSheet } from 'react-native';

const App = () => (
  <RecoilRoot>
    <View style={styles.container}>
      <Text>Recoil Setup Example</Text>
    </View>
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with Recoil set up, displaying a simple text message indicating that Recoil has been integrated.

### Example 2: Creating and Using Atoms in Recoil

Atoms are the fundamental units of state in Recoil. They represent pieces of state that can be read and written from any component. When an atom’s state changes, all components that depend on that atom are re-rendered. This makes atoms a powerful tool for managing state in a reactive way.

To create and use atoms, you need to define them using the `atom` function and use the `useRecoilState` hook to read and update their values in components. This example demonstrates how to create an atom and use it to manage state in a React Native component.

#### Online Resources
1. [Recoil Atoms](https://recoiljs.org/docs/basic-tutorial/atoms)
2. [Using Recoil Atoms in React](https://blog.bitsrc.io/using-recoiljs-to-handle-state-management-in-react-9f2b1e10d88a)

#### Code to Practice

```javascript
import React from 'react';
import { atom, useRecoilState } from 'recoil';
import { View, Text, Button, StyleSheet } from 'react-native';

const countState = atom({
  key: 'countState',
  default: 0,
});

const Counter = () => {
  const [count, setCount] = useRecoilState(countState);

  return (
    <View style={styles.container}>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};

const App = () => (
  <RecoilRoot>
    <Counter />
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with a counter that increments when the button is pressed. The counter’s state is managed using a Recoil atom.

### Example 3: Implementing Selectors for Derived State

Selectors in Recoil are used to compute derived state based on atoms or other selectors. They allow you to create reactive data flows, where the derived state is automatically updated when its dependencies change. Selectors can also perform asynchronous data fetching, making them a versatile tool for managing complex state logic.

To implement selectors, you define them using the `selector` function and use the `useRecoilValue` hook to read their values in components. This example demonstrates how to create a selector that computes derived state based on an atom and how to use it in a React Native component.

#### Online Resources
1. [Recoil Selectors](https://recoiljs.org/docs/basic-tutorial/selectors)
2. [Using Recoil Selectors in React](https://blog.bitsrc.io/using-recoiljs-to-handle-state-management-in-react-9f2b1e10d88a)

#### Code to Practice

```javascript
import React from 'react';
import { atom, selector, useRecoilState, useRecoilValue } from 'recoil';
import { View, Text, Button, StyleSheet } from 'react-native';

const countState = atom({
  key: 'countState',
  default: 0,
});

const doubledCountState = selector({
  key: 'doubledCountState',
  get: ({ get }) => {
    const count = get(countState);
    return count * 2;
  },
});

const Counter = () => {
  const [count, setCount] = useRecoilState(countState);
  const doubledCount = useRecoilValue(doubledCountState);

  return (
    <View style={styles.container}>
      <Text>Count: {count}</Text>
      <Text>Doubled Count: {doubledCount}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};

const App = () => (
  <RecoilRoot>
    <Counter />
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with a counter that displays both the current count and its doubled value. The doubled value is computed using a Recoil selector and updates automatically when the count changes.

---

### Task 2: Integrate Recoil for State Management in a Project

Integrating Recoil for state management in a React Native project provides a robust solution for managing global state efficiently. Recoil allows for seamless state updates, efficient rendering, and enhanced state management capabilities, making it a preferred choice for complex applications. By using Recoil, developers can manage application state with fine-grained control over updates, ensuring that only the necessary components are re-rendered when state changes.

To integrate Recoil, you need to set up Recoil in your project, define atoms for individual state units, and create selectors for derived state. This integration enables you to build scalable and maintainable state management solutions. Additionally, Recoil's asynchronous support and dependency tracking capabilities make it easier to handle complex state logic and data fetching.

#### Online Resources
1. [Recoil Official Documentation](https://recoiljs.org/docs/introduction/getting-started)
2. [Recoil in React Native](https://reactnative.dev/docs/recoil-integration)

#### Examples to Practice

1. **Setting Up Recoil in a React Native Project**
2. **Managing State with Atoms**
3. **Using Selectors for Derived State and Asynchronous Data**

### Example 1: Setting Up Recoil in a React Native Project

Setting up Recoil in a React Native project involves installing the Recoil library and configuring your application to use the `RecoilRoot` component. This provides the necessary context for managing state throughout your application. The initial setup is straightforward and allows you to start defining atoms and selectors for state management.

To set up Recoil, you need to install the Recoil package and wrap your application with `RecoilRoot`. This example demonstrates the basic setup process for integrating Recoil into a React Native project.

#### Online Resources
1. [Recoil Getting Started Guide](https://recoiljs.org/docs/introduction/getting-started)
2. [Recoil Setup in React Native](https://recoiljs.org/docs/basic-tutorial/intro)

#### Code to Practice

```bash
# Install Recoil package
npm install recoil

# Example App setup (App.js)
import React from 'react';
import { RecoilRoot } from 'recoil';
import { View, Text, StyleSheet } from 'react-native';

const App = () => (
  <RecoilRoot>
    <View style={styles.container}>
      <Text>Recoil Setup Example</Text>
    </View>
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with Recoil set up, displaying a simple text message indicating that Recoil has been integrated.

### Example 2: Managing State with Atoms

Atoms are the core units of state in Recoil. They represent individual pieces of state that can be read and written from any component. When an atom’s state changes, all components that depend on that atom are automatically re-rendered. This makes atoms a powerful tool for managing state in a reactive manner.

To manage state with atoms, you define them using the `atom` function and use the `useRecoilState` hook to read and update their values in components. This example demonstrates how to create an atom and use it to manage the state of a counter in a React Native component.

#### Online Resources
1. [Recoil Atoms](https://recoiljs.org/docs/basic-tutorial/atoms)
2. [Using Recoil Atoms in React](https://blog.bitsrc.io/using-recoiljs-to-handle-state-management-in-react-9f2b1e10d88a)

#### Code to Practice

```javascript
import React from 'react';
import { atom, useRecoilState } from 'recoil';
import { View, Text, Button, StyleSheet } from 'react-native';

const countState = atom({
  key: 'countState',
  default: 0,
});

const Counter = () => {
  const [count, setCount] = useRecoilState(countState);

  return (
    <View style={styles.container}>
      <Text>Count: {count}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};

const App = () => (
  <RecoilRoot>
    <Counter />
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with a counter that increments when the button is pressed. The counter’s state is managed using a Recoil atom.

### Example 3: Using Selectors for Derived State and Asynchronous Data

Selectors in Recoil are used to compute derived state based on atoms or other selectors. They enable reactive data flows, where the derived state automatically updates when its dependencies change. Selectors can also handle asynchronous data fetching, making them a versatile tool for managing complex state logic.

To use selectors, you define them using the `selector` function and use the `useRecoilValue` hook to read their values in components. This example demonstrates how to create a selector that computes derived state based on an atom and how to use it to fetch asynchronous data.

#### Online Resources
1. [Recoil Selectors](https://recoiljs.org/docs/basic-tutorial/selectors)
2. [Using Recoil Selectors in React](https://blog.bitsrc.io/using-recoiljs-to-handle-state-management-in-react-9f2b1e10d88a)

#### Code to Practice

```javascript
import React, { useEffect } from 'react';
import { atom, selector, useRecoilState, useRecoilValue } from 'recoil';
import { View, Text, Button, StyleSheet } from 'react-native';

const countState = atom({
  key: 'countState',
  default: 0,
});

const doubledCountState = selector({
  key: 'doubledCountState',
  get: ({ get }) => {
    const count = get(countState);
    return count * 2;
  },
});

const Counter = () => {
  const [count, setCount] = useRecoilState(countState);
  const doubledCount = useRecoilValue(doubledCountState);

  return (
    <View style={styles.container}>
      <Text>Count: {count}</Text>
      <Text>Doubled Count: {doubledCount}</Text>
      <Button title="Increment" onPress={() => setCount(count + 1)} />
    </View>
  );
};

const dataState = selector({
  key: 'dataState',
  get: async () => {
    const response = await fetch('https://jsonplaceholder.typicode.com/todos/1');
    const data = await response.json();
    return data;
  },
});

const DataFetcher = () => {
  const data = useRecoilValue(dataState);

  return (
    <View style={styles.container}>
      <Text>Data: {JSON.stringify(data)}</Text>
    </View>
  );
};

const App = () => (
  <RecoilRoot>
    <View style={{ flex: 1 }}>
      <Counter />
      <DataFetcher />
    </View>
  </RecoilRoot>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application with a counter that displays both the current count and its doubled value. Additionally, the app fetches and displays asynchronous data from an external API using a Recoil selector.

---

### Task 3: Study Advanced Caching Techniques

Advanced caching techniques are essential for improving the performance and efficiency of React Native applications. Caching involves storing data locally on the device, allowing the application to access it quickly without the need to repeatedly fetch it from the server. This reduces load times, minimizes network usage, and provides a smoother user experience, especially in scenarios with limited or intermittent connectivity. There are various caching strategies, such as in-memory caching, local storage caching, and persistent storage caching, each with its own use cases and benefits.

In-memory caching, such as using Redux or React's Context API, is suitable for temporary data that does not need to persist between app sessions. Local storage caching, using tools like AsyncStorage, allows data to be stored on the device and accessed even after the app is closed and reopened. Persistent storage caching, using databases like SQLite or libraries like Realm, is ideal for more complex data structures and long-term storage needs. Understanding and implementing these techniques can significantly enhance the performance and reliability of your React Native applications.

#### Online Resources
1. [React Native Caching Strategies](https://reactnative.dev/docs/performance#using-persistent-caching)
2. [Optimizing React Native Apps](https://www.smashingmagazine.com/2020/06/optimize-react-native-application/)

#### Examples to Practice

1. **Using AsyncStorage for Local Storage Caching**
2. **Implementing In-Memory Caching with Context API**
3. **Using SQLite for Persistent Storage Caching**

### Example 1: Using AsyncStorage for Local Storage Caching

AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the app. It is ideal for storing lightweight data such as user preferences, session tokens, or other small pieces of information that need to persist between app launches. AsyncStorage is easy to use and integrates seamlessly with React Native.

To use AsyncStorage, you need to import it from the `@react-native-async-storage/async-storage` package, store data using the `setItem` method, and retrieve data using the `getItem` method. This example demonstrates how to store and retrieve user preferences using AsyncStorage in a React Native application.

#### Online Resources
1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/docs/install/)
2. [Using AsyncStorage in React Native](https://www.digitalocean.com/community/tutorials/react-native-asyncstorage)

#### Code to Practice

```bash
# Install AsyncStorage package
npm install @react-native-async-storage/async-storage

# Example App setup (App.js)
import React, { useState, useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';

const App = () => {
  const [name, setName] = useState('');

  useEffect(() => {
    const fetchName = async () => {
      try {
        const value = await AsyncStorage.getItem('@user_name');
        if (value !== null) {
          setName(value);
        }
      } catch (error) {
        console.error(error);
      }
    };
    fetchName();
  }, []);

  const saveName = async () => {
    try {
      await AsyncStorage.setItem('@user_name', 'John Doe');
      setName('John Doe');
    } catch (error) {
      console.error(error);
    }
  };

  return (
    <View style={styles.container}>
      <Text>Stored Name: {name}</Text>
      <Button title="Save Name" onPress={saveName} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that stores and retrieves a user's name using AsyncStorage. The name is displayed on the screen and can be updated by pressing the "Save Name" button.

### Example 2: Implementing In-Memory Caching with Context API

In-memory caching involves storing data in the application's memory for quick access. The Context API in React is an excellent tool for managing in-memory state that needs to be shared across multiple components. It allows you to create a global state that can be accessed and updated from anywhere in the application.

To implement in-memory caching with the Context API, you need to create a context, provide the context to your component tree, and consume the context in your components. This example demonstrates how to set up and use the Context API for managing user preferences in a React Native application.

#### Online Resources
1. [React Context API Documentation](https://reactjs.org/docs/context.html)
2. [Using React Context for State Management](https://www.taniarascia.com/using-context-api-in-react/)

#### Code to Practice

```javascript
import React, { createContext, useState, useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const PreferencesContext = createContext();

const PreferencesProvider = ({ children }) => {
  const [preferences, setPreferences] = useState({ theme: 'light' });

  const toggleTheme = () => {
    setPreferences((prev) => ({
      ...prev,
      theme: prev.theme === 'light' ? 'dark' : 'light',
    }));
  };

  return (
    <PreferencesContext.Provider value={{ preferences, toggleTheme }}>
      {children}
    </PreferencesContext.Provider>
  );
};

const PreferencesConsumer = () => {
  const { preferences, toggleTheme } = useContext(PreferencesContext);

  return (
    <View style={styles.container}>
      <Text>Current Theme: {preferences.theme}</Text>
      <Button title="Toggle Theme" onPress={toggleTheme} />
    </View>
  );
};

const App = () => (
  <PreferencesProvider>
    <PreferencesConsumer />
  </PreferencesProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that manages user preferences (theme) using the Context API. The theme can be toggled between light and dark by pressing the "Toggle Theme" button, and the current theme is displayed on the screen.

### Example 3: Using SQLite for Persistent Storage Caching

SQLite is a lightweight, disk-based database that provides persistent storage for complex data structures. It is ideal for applications that need to store large amounts of data or require advanced querying capabilities. Using SQLite in React Native involves installing the appropriate library, setting up a database, and performing CRUD operations.

To use SQLite, you need to install the `react-native-sqlite-storage` package, create a database, and write functions to interact with the database. This example demonstrates how to set up SQLite in a React Native application and perform basic CRUD operations.

#### Online Resources
1. [SQLite Documentation](https://www.sqlite.org/docs.html)
2. [Using SQLite in React Native](https://github.com/andpor/react-native-sqlite-storage)

#### Code to Practice

```bash
# Install SQLite package
npm install react-native-sqlite-storage

# Example App setup (App.js)
import React, { useEffect, useState } from 'react';
import { View, Text, Button, StyleSheet, FlatList } from 'react-native';
import SQLite from 'react-native-sqlite-storage';

const db = SQLite.openDatabase(
  {
    name: 'mainDB',
    location: 'default',
  },
  () => {},
  (error) => {
    console.log(error);
  }
);

const App = () => {
  const [items, setItems] = useState([]);

  useEffect(() => {
    createTable();
    getItems();
  }, []);

  const createTable = () => {
    db.transaction((tx) => {
      tx.executeSql(
        'CREATE TABLE IF NOT EXISTS items (id INTEGER PRIMARY KEY AUTOINCREMENT, name TEXT);'
      );
    });
  };

  const getItems = () => {
    db.transaction((tx) => {
      tx.executeSql('SELECT * FROM items', [], (tx, results) => {
        const rows = results.rows;
        let items = [];
        for (let i = 0; i < rows.length; i++) {
          items.push({
            id: rows.item(i).id,
            name: rows.item(i).name,
          });
        }
        setItems(items);
      });
    });
  };

  const addItem = () => {
    db.transaction((tx) => {
      tx.executeSql('INSERT INTO items (name) VALUES (?)', ['Item'], (tx, results) => {
        if (results.rowsAffected > 0) {
          getItems();
        }
      });
    });
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={items}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <Button title="Add Item" onPress={addItem} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that uses SQLite for persistent storage. The app displays a list of items stored in the database and allows users to add new items by pressing the "Add Item" button.

---

### Task 4: Implement Caching Strategies with Apollo Client

Apollo Client is a powerful state management library for JavaScript that enables you to manage both local and remote data with GraphQL. One of its key features is its ability to cache query results, which can significantly improve the performance and responsiveness of your application. Caching strategies in Apollo Client allow you to control how and when data is fetched from the server or retrieved from the cache, ensuring that your application is both efficient and up-to-date.

There are several caching strategies you can implement with Apollo Client, including cache-first, network-first, cache-only, and network-only. These strategies determine how Apollo Client handles data fetching and caching for each query. By selecting the appropriate caching strategy for your use case, you can optimize your application's performance and reduce unnecessary network requests.

#### Online Resources
1. [Apollo Client Caching](https://www.apollographql.com/docs/react/caching/overview/)
2. [GraphQL Query Fetching Strategies](https://www.apollographql.com/docs/react/data/queries/#supported-fetch-policies)

#### Examples to Practice

1. **Setting Up Apollo Client with Cache Configuration**
2. **Implementing Cache-First Strategy**
3. **Implementing Network-First Strategy**

### Example 1: Setting Up Apollo Client with Cache Configuration

Setting up Apollo Client involves installing the necessary packages, configuring the Apollo Client instance, and integrating it with your React Native application. The cache configuration is a crucial part of this setup, as it determines how query results are stored and retrieved.

To set up Apollo Client, you need to install the `@apollo/client` package, configure the Apollo Client with an appropriate cache, and wrap your application with the `ApolloProvider`. This example demonstrates the basic setup process for integrating Apollo Client into a React Native project.

#### Online Resources
1. [Getting Started with Apollo Client](https://www.apollographql.com/docs/react/get-started/)
2. [ApolloProvider Documentation](https://www.apollographql.com/docs/react/api/react/hooks/#the-apolloprovider-component)

#### Code to Practice

```bash
# Install Apollo Client and GraphQL packages
npm install @apollo/client graphql

# Example App setup (App.js)
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider } from '@apollo/client';
import { View, Text, StyleSheet } from 'react-native';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <Text>Apollo Client Setup Example</Text>
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application with Apollo Client set up, displaying a simple text message indicating that Apollo Client has been integrated.

### Example 2: Implementing Cache-First Strategy

The cache-first strategy is the default fetch policy in Apollo Client. This strategy checks the cache for a query result before making a network request. If the data is found in the cache, it returns the cached data. If the data is not found, it fetches the data from the network and stores it in the cache for future use. This strategy is useful for queries where the data does not change frequently.

To implement the cache-first strategy, you need to configure the `fetchPolicy` option in your query. This example demonstrates how to set up a query with the cache-first strategy and handle the query results in a React Native component.

#### Online Resources
1. [Apollo Client Fetch Policies](https://www.apollographql.com/docs/react/data/queries/#supported-fetch-policies)
2. [Cache-First Strategy in Apollo Client](https://www.apollographql.com/docs/react/caching/cache-interaction/#cache-first)

#### Code to Practice

```javascript
import React from 'react';
import { useQuery, gql } from '@apollo/client';
import { View, Text, StyleSheet, FlatList } from 'react-native';

const GET_ITEMS = gql`
  query GetItems {
    items {
      id
      name
    }
  }
`;

const ItemList = () => {
  const { loading, error, data } = useQuery(GET_ITEMS, {
    fetchPolicy: 'cache-first',
  });

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <FlatList
      data={data.items}
      renderItem={({ item }) => <Text>{item.name}</Text>}
      keyExtractor={(item) => item.id.toString()}
    />
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <ItemList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a list of items using the cache-first strategy. If the data is available in the cache, it is used; otherwise, it is fetched from the network.

### Example 3: Implementing Network-First Strategy

The network-first strategy checks the network for a query result before falling back to the cache. If the network request is successful, it updates the cache with the fetched data. If the network request fails (e.g., due to a network error), it returns the cached data. This strategy is useful for queries where the data changes frequently, but you still want to provide a fallback in case of network issues.

To implement the network-first strategy, you need to configure the `fetchPolicy` option in your query. This example demonstrates how to set up a query with the network-first strategy and handle the query results in a React Native component.

#### Online Resources
1. [Network-First Strategy in Apollo Client](https://www.apollographql.com/docs/react/caching/cache-interaction/#network-first)
2. [Handling Network Errors in Apollo Client](https://www.apollographql.com/docs/react/networking/error-handling/)

#### Code to Practice

```javascript
import React from 'react';
import { useQuery, gql } from '@apollo/client';
import { View, Text, StyleSheet, FlatList } from 'react-native';

const GET_ITEMS = gql`
  query GetItems {
    items {
      id
      name
    }
  }
`;

const ItemList = () => {
  const { loading, error, data } = useQuery(GET_ITEMS, {
    fetchPolicy: 'network-first',
  });

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <FlatList
      data={data.items}
      renderItem={({ item }) => <Text>{item.name}</Text>}
      keyExtractor={(item) => item.id.toString()}
    />
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <ItemList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a list of items using the network-first strategy. The application fetches the latest data from the network but falls back to cached data if the network request fails.

---

### Task 5: Study Advanced Networking with GraphQL

GraphQL is a powerful query language for APIs that allows clients to request exactly the data they need, efficiently aggregating multiple resource requests into a single call. This flexibility can significantly optimize the performance and responsiveness of your applications. GraphQL enables more efficient data fetching, supports real-time updates through subscriptions, and allows for better version control of your APIs. By adopting GraphQL, developers can improve the speed and scalability of their applications, reduce the complexity of data management, and provide a more efficient and responsive user experience.

Advanced networking with GraphQL in React Native involves integrating Apollo Client, managing complex queries and mutations, and handling real-time data with subscriptions. Apollo Client is a popular GraphQL client that simplifies data management by providing tools for caching, query batching, and error handling. Mastering these advanced GraphQL techniques can help developers build robust, scalable, and high-performance applications.

#### Online Resources
1. [Apollo Client Documentation](https://www.apollographql.com/docs/react/)
2. [GraphQL Official Documentation](https://graphql.org/learn/)

#### Examples to Practice

1. **Setting Up Apollo Client for GraphQL Queries**
2. **Managing Complex Queries and Mutations**
3. **Implementing Real-Time Data with GraphQL Subscriptions**

### Example 1: Setting Up Apollo Client for GraphQL Queries

Setting up Apollo Client in a React Native project is the first step towards leveraging GraphQL for advanced networking. Apollo Client provides a comprehensive suite of tools for querying, caching, and managing GraphQL data. The setup involves installing the necessary packages, configuring Apollo Client with your GraphQL endpoint, and integrating it with your React Native application.

To set up Apollo Client, you need to install the `@apollo/client` and `graphql` packages, create an Apollo Client instance, and wrap your application with the `ApolloProvider`. This example demonstrates how to configure Apollo Client and execute a basic GraphQL query in a React Native application.

#### Online Resources
1. [Apollo Client Getting Started](https://www.apollographql.com/docs/react/get-started/)
2. [GraphQL Queries with Apollo Client](https://www.apollographql.com/docs/react/data/queries/)

#### Code to Practice

```bash
# Install Apollo Client and GraphQL packages
npm install @apollo/client graphql

# Example App setup (App.js)
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';
import { View, Text, StyleSheet, FlatList } from 'react-native';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const GET_ITEMS = gql`
  query GetItems {
    items {
      id
      name
    }
  }
`;

const ItemList = () => {
  const { loading, error, data } = useQuery(GET_ITEMS);

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <FlatList
      data={data.items}
      renderItem={({ item }) => <Text>{item.name}</Text>}
      keyExtractor={(item) => item.id.toString()}
    />
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <ItemList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a list of items from a GraphQL endpoint using Apollo Client. The items are displayed in a list, and the application handles loading and error states.

### Example 2: Managing Complex Queries and Mutations

Managing complex queries and mutations with GraphQL allows you to handle more sophisticated data interactions in your application. Queries fetch data, while mutations are used to modify server-side data. By combining multiple queries and mutations, you can manage intricate data relationships and perform complex operations efficiently.

To manage complex queries and mutations, you need to define the corresponding GraphQL operations and use Apollo Client's hooks (`useQuery` and `useMutation`) to execute them. This example demonstrates how to perform a mutation to add a new item and update the list of items in a React Native application.

#### Online Resources
1. [GraphQL Mutations with Apollo Client](https://www.apollographql.com/docs/react/data/mutations/)
2. [Handling Complex Queries in Apollo Client](https://www.apollographql.com/docs/react/data/queries/)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, useMutation, gql } from '@apollo/client';
import { View, Text, TextInput, Button, StyleSheet, FlatList } from 'react-native';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const GET_ITEMS = gql`
  query GetItems {
    items {
      id
      name
    }
  }
`;

const ADD_ITEM = gql`
  mutation AddItem($name: String!) {
    addItem(name: $name) {
      id
      name
    }
  }
`;

const ItemList = () => {
  const { loading, error, data } = useQuery(GET_ITEMS);
  const [addItem] = useMutation(ADD_ITEM, {
    refetchQueries: [{ query: GET_ITEMS }],
  });
  const [name, setName] = useState('');

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  const handleAddItem = () => {
    addItem({ variables: { name } });
    setName('');
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={data.items}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <TextInput
        style={styles.input}
        value={name}
        onChangeText={setName}
        placeholder="New item name"
      />
      <Button title="Add Item" onPress={handleAddItem} />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <ItemList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginVertical: 8,
  },
});

export default App;
```

**Expected Output:**

A React Native application that allows users to add new items to the list using a GraphQL mutation. The list of items is automatically updated after a new item is added, demonstrating the use of complex queries and mutations with Apollo Client.

### Example 3: Implementing Real-Time Data with GraphQL Subscriptions

GraphQL subscriptions enable real-time updates by allowing clients to subscribe to specific events and receive updates whenever the event occurs. This is particularly useful for applications that require live data updates, such as chat applications, stock tickers, or collaborative tools. Subscriptions are handled over WebSockets, providing a persistent connection between the client and server.

To implement real-time data with GraphQL subscriptions, you need to set up a WebSocket link for Apollo Client, define the subscription operation, and use the `useSubscription` hook to handle incoming data. This example demonstrates how to set up a real-time chat application using GraphQL subscriptions in a React Native project.

#### Online Resources
1. [GraphQL Subscriptions with Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)
2. [Using WebSockets with Apollo Client](https://www.apollographql.com/docs/react/networking/advanced-http-networking/#websockets)

#### Code to Practice

```bash
# Install necessary packages
npm install @apollo/client graphql @apollo/client/link/ws

# Example App setup (App.js)
import React, { useState } from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useSubscription, useMutation, gql, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { getMainDefinition } from '@apollo/client/utilities';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';

const httpLink = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const wsLink = new WebSocketLink({
  uri: 'wss://example.com/graphql',
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
  },
  wsLink,
  httpLink,
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

const GET_MESSAGES = gql`
  query GetMessages {
    messages {
      id
      content
    }
  }
`;

const MESSAGE_SUBSCRIPTION = gql`
  subscription OnMessageAdded {
    messageAdded {
      id
      content
    }
  }
`;

const ADD_MESSAGE = gql`
  mutation AddMessage($content: String!) {
    addMessage(content: $content) {
      id


      content
    }
  }
`;

const MessageList = () => {
  const { data, error, loading } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [addMessage] = useMutation(ADD_MESSAGE, {
    refetchQueries: [{ query: GET_MESSAGES }],
  });
  const [messages, setMessages] = useState([]);
  const [content, setContent] = useState('');

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  const handleAddMessage = () => {
    addMessage({ variables: { content } });
    setContent('');
  };

  if (data && !messages.some((msg) => msg.id === data.messageAdded.id)) {
    setMessages((prevMessages) => [...prevMessages, data.messageAdded]);
  }

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => <Text>{item.content}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <TextInput
        style={styles.input}
        value={content}
        onChangeText={setContent}
        placeholder="New message"
      />
      <Button title="Send Message" onPress={handleAddMessage} />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <MessageList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginVertical: 8,
  },
});

export default App;
```

**Expected Output:**

A React Native application that allows users to send and receive messages in real-time using GraphQL subscriptions. New messages are displayed as they are received, demonstrating real-time data updates with Apollo Client and WebSockets.

---

### Task 6: Optimize GraphQL Queries and Mutations

Optimizing GraphQL queries and mutations is crucial for improving the performance and efficiency of your React Native applications. By carefully crafting your queries and mutations, you can minimize the amount of data transferred between the client and server, reduce latency, and ensure faster load times. Key strategies for optimization include batching multiple queries, using fragments to reuse common fields, and leveraging the benefits of caching to avoid redundant requests.

Another important aspect of optimization is managing the complexity and size of the GraphQL operations. By paginating large datasets and using efficient filtering techniques, you can limit the amount of data fetched at any given time. Additionally, optimizing the server-side resolvers and ensuring that the database queries are efficient can significantly improve the overall performance of your GraphQL operations. By implementing these strategies, you can enhance the responsiveness and scalability of your applications.

#### Online Resources
1. [Apollo Client Performance Best Practices](https://www.apollographql.com/docs/react/performance/)
2. [GraphQL Query Optimization Techniques](https://blog.logrocket.com/optimize-graphql-queries-performance/)

#### Examples to Practice

1. **Batching Multiple Queries**
2. **Using Fragments to Reuse Common Fields**
3. **Paginating Large Datasets**

### Example 1: Batching Multiple Queries

Batching multiple queries involves combining several queries into a single network request, reducing the number of requests sent to the server. This can significantly improve performance, especially in applications where multiple queries are needed to fetch different pieces of data. Apollo Client supports batching out of the box, making it easy to implement this optimization.

To batch multiple queries, you need to configure the Apollo Client with the `BatchHttpLink` and use it in place of the standard `HttpLink`. This example demonstrates how to set up and use query batching in a React Native application.

#### Online Resources
1. [Apollo Client BatchHttpLink](https://www.apollographql.com/docs/react/api/link/apollo-link-batch-http/)
2. [Batching GraphQL Queries with Apollo](https://www.apollographql.com/blog/apollo-client/next-js/using-apollo-client-with-next-js/)

#### Code to Practice

```bash
# Install Apollo Client and GraphQL packages
npm install @apollo/client graphql

# Example App setup (App.js)
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';
import { BatchHttpLink } from '@apollo/client/link/batch-http';
import { View, Text, StyleSheet, FlatList } from 'react-native';

const batchLink = new BatchHttpLink({
  uri: 'https://example.com/graphql',
  batchMax: 5, // Maximum number of operations to include in one batch
  batchInterval: 20, // Wait time in milliseconds to collect batched operations
});

const client = new ApolloClient({
  link: batchLink,
  cache: new InMemoryCache(),
});

const GET_USERS = gql`
  query GetUsers {
    users {
      id
      name
    }
  }
`;

const GET_POSTS = gql`
  query GetPosts {
    posts {
      id
      title
    }
  }
`;

const DataFetcher = () => {
  const { loading: loadingUsers, error: errorUsers, data: dataUsers } = useQuery(GET_USERS);
  const { loading: loadingPosts, error: errorPosts, data: dataPosts } = useQuery(GET_POSTS);

  if (loadingUsers || loadingPosts) return <Text>Loading...</Text>;
  if (errorUsers || errorPosts) return <Text>Error: {errorUsers?.message || errorPosts?.message}</Text>;

  return (
    <View>
      <Text>Users:</Text>
      <FlatList
        data={dataUsers.users}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <Text>Posts:</Text>
      <FlatList
        data={dataPosts.posts}
        renderItem={({ item }) => <Text>{item.title}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <DataFetcher />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a list of users and posts using batched GraphQL queries. The queries are combined into a single network request, reducing the number of requests sent to the server.

### Example 2: Using Fragments to Reuse Common Fields

Fragments in GraphQL allow you to reuse common fields across multiple queries or mutations. By defining a fragment with the shared fields, you can include it in different operations, reducing duplication and making your code more maintainable. This approach also helps in optimizing the queries by ensuring that only the necessary fields are fetched.

To use fragments, you define them using the `fragment` keyword and include them in your queries or mutations with the `...` syntax. This example demonstrates how to create and use fragments to fetch common fields in a React Native application.

#### Online Resources
1. [GraphQL Fragments Documentation](https://graphql.org/learn/queries/#fragments)
2. [Using Fragments in Apollo Client](https://www.apollographql.com/docs/react/data/fragments/)

#### Code to Practice

```javascript
import React from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';
import { View, Text, StyleSheet, FlatList } from 'react-native';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const USER_FIELDS = gql`
  fragment UserFields on User {
    id
    name
  }
`;

const POST_FIELDS = gql`
  fragment PostFields on Post {
    id
    title
  }
`;

const GET_USERS = gql`
  query GetUsers {
    users {
      ...UserFields
    }
  }
  ${USER_FIELDS}
`;

const GET_POSTS = gql`
  query GetPosts {
    posts {
      ...PostFields
    }
  }
  ${POST_FIELDS}
`;

const DataFetcher = () => {
  const { loading: loadingUsers, error: errorUsers, data: dataUsers } = useQuery(GET_USERS);
  const { loading: loadingPosts, error: errorPosts, data: dataPosts } = useQuery(GET_POSTS);

  if (loadingUsers || loadingPosts) return <Text>Loading...</Text>;
  if (errorUsers || errorPosts) return <Text>Error: {errorUsers?.message || errorPosts?.message}</Text>;

  return (
    <View>
      <Text>Users:</Text>
      <FlatList
        data={dataUsers.users}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <Text>Posts:</Text>
      <FlatList
        data={dataPosts.posts}
        renderItem={({ item }) => <Text>{item.title}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <DataFetcher />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a list of users and posts using GraphQL fragments to reuse common fields. This approach reduces duplication and makes the code more maintainable.

### Example 3: Paginating Large Datasets

Paginating large datasets is an essential optimization technique for handling large amounts of data efficiently. Instead of fetching all the data at once, pagination allows you to fetch a subset of data and load more data as needed. This reduces the load on the server, minimizes network usage, and improves the responsiveness of your application.

To implement pagination, you need to define the GraphQL queries with pagination arguments (such as `limit` and `offset`) and use Apollo Client's fetchMore function to load additional data. This example demonstrates how to implement pagination for a list of items in a React Native application.

#### Online Resources
1. [GraphQL Pagination Techniques](https://graphql.org/learn/pagination/)
2. [Pagination with Apollo Client](https://www.apollographql.com/docs/react/pagination/core-api/)

#### Code to Practice

```javascript
import React, { useState } from 'react';
import { ApolloClient, InMemoryCache, ApolloProvider, useQuery, gql } from '@apollo/client';
import { View, Text, Button, FlatList, StyleSheet } from 'react-native';

const client = new ApolloClient({
  uri: 'https://example.com/graphql',
  cache: new InMemoryCache(),
});

const GET_ITEMS = gql`
  query GetItems($limit: Int!, $offset: Int!) {
    items(limit: $limit, offset: $offset) {
      id
      name
    }
  }
`;

const ITEMS_PER_PAGE = 10;

const ItemList = () => {
  const [offset, setOffset] = useState(0);
  const { loading, error, data, fetchMore } = use

Query(GET_ITEMS, {
    variables: { limit: ITEMS_PER_PAGE, offset: 0 },
  });

  const loadMoreItems = () => {
    fetchMore({
      variables: {
        offset: data.items.length,
      },
      updateQuery: (prev, { fetchMoreResult }) => {
        if (!fetchMoreResult) return prev;
        return Object.assign({}, prev, {
          items: [...prev.items, ...fetchMoreResult.items],
        });
      },
    });
  };

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View>
      <FlatList
        data={data.items}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
      <Button title="Load More" onPress={loadMoreItems} />
    </View>
  );
};

const App = () => (
  <ApolloProvider client={client}>
    <View style={styles.container}>
      <ItemList />
    </View>
  </ApolloProvider>
);

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application that fetches and displays a paginated list of items using GraphQL queries. Users can load more items by pressing the "Load More" button, demonstrating efficient handling of large datasets.

---

### Task 7: Study Server-Side Rendering (SSR) with Next.js

Server-side rendering (SSR) is a technique used to improve the performance and SEO of web applications by rendering pages on the server instead of the client. Next.js is a popular React framework that provides built-in support for SSR, allowing developers to create highly optimized and fast-loading web applications. SSR enables faster initial page loads, better SEO, and a smoother user experience, as the server sends fully rendered HTML to the client, which can be displayed immediately while the JavaScript loads and hydrates the page.

Next.js makes implementing SSR straightforward by offering various data-fetching methods like `getServerSideProps` and `getStaticProps`. These methods allow developers to fetch data and render pages on the server before sending the response to the client. Understanding and implementing SSR with Next.js can significantly enhance the performance and user experience of your React applications.

#### Online Resources
1. [Next.js Documentation](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Next.js Server-Side Rendering Guide](https://www.smashingmagazine.com/2020/07/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Examples to Practice

1. **Setting Up a Next.js Project**
2. **Implementing Server-Side Rendering with `getServerSideProps`**
3. **Using `getStaticProps` for Static Generation**

### Example 1: Setting Up a Next.js Project

Setting up a Next.js project involves creating a new project directory, installing the necessary packages, and configuring the project structure. Next.js provides a simple setup process that allows you to quickly get started with building React applications that support SSR and static site generation (SSG).

To set up a Next.js project, you need to install `next`, `react`, and `react-dom` packages, create the necessary project files, and configure the development server. This example demonstrates the basic setup process for a Next.js project.

#### Online Resources
1. [Getting Started with Next.js](https://nextjs.org/docs/getting-started)
2. [Next.js Project Setup Guide](https://www.taniarascia.com/getting-started-with-next-js/)

#### Code to Practice

```bash
# Create a new Next.js project directory
mkdir nextjs-ssr-example
cd nextjs-ssr-example

# Initialize a new Node.js project
npm init -y

# Install Next.js, React, and ReactDOM
npm install next react react-dom

# Add the following scripts to package.json
# "scripts": {
#   "dev": "next dev",
#   "build": "next build",
#   "start": "next start"
# }

# Create the necessary project files
mkdir pages
touch pages/index.js

# Example index.js file
import React from 'react';

const Home = () => (
  <div>
    <h1>Welcome to Next.js</h1>
  </div>
);

export default Home;

# Start the development server
npm run dev
```

**Expected Output:**

A Next.js project with a simple home page that displays "Welcome to Next.js". The development server runs on `http://localhost:3000`, allowing you to view the application in your browser.

### Example 2: Implementing Server-Side Rendering with `getServerSideProps`

`getServerSideProps` is a Next.js function that enables server-side rendering for a specific page. It runs on the server for every request, allowing you to fetch data and render the page on the server before sending the response to the client. This is useful for pages that need to display dynamic data that changes frequently.

To implement SSR with `getServerSideProps`, you define the function in your page component and fetch the necessary data. This example demonstrates how to use `getServerSideProps` to fetch data from an API and render it on the server.

#### Online Resources
1. [Using getServerSideProps in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Server-Side Rendering with Next.js](https://www.digitalocean.com/community/tutorials/nextjs-getserversideprops)

#### Code to Practice

```javascript
# Create a new page (pages/ssr.js)
import React from 'react';

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const SSRPage = ({ posts }) => (
  <div>
    <h1>Server-Side Rendered Page</h1>
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  </div>
);

export default SSRPage;
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them. The data is fetched on the server for every request, ensuring that the page is always up-to-date.

### Example 3: Using `getStaticProps` for Static Generation

`getStaticProps` is a Next.js function that enables static generation for a specific page. It runs at build time, allowing you to fetch data and generate static HTML files. This is useful for pages that display data that does not change frequently, as it provides better performance and SEO benefits.

To use `getStaticProps`, you define the function in your page component and fetch the necessary data. This example demonstrates how to use `getStaticProps` to fetch data from an API and generate a static page.

#### Online Resources
1. [Using getStaticProps in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Static Generation with Next.js](https://www.smashingmagazine.com/2020/06/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Code to Practice

```javascript
# Create a new page (pages/ssg.js)
import React from 'react';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 10, // Re-generate the page at most once every 10 seconds
  };
}

const SSGPage = ({ posts }) => (
  <div>
    <h1>Static Site Generated Page</h1>
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  </div>
);

export default SSGPage;
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them. The data is fetched at build time, generating a static HTML page that is served to the client. The page is re-generated at most once every 10 seconds.

---

### Implement SSR in a Mobile-Focused Next.js Project

Implementing server-side rendering (SSR) in a mobile-focused Next.js project can greatly enhance the performance, SEO, and user experience of your application. SSR ensures that the HTML content is fully rendered on the server before it is sent to the client, which reduces the initial load time and makes the app more search engine friendly. For mobile users, this means faster load times and a more seamless experience, especially on slower networks.

Next.js provides several built-in methods to handle SSR efficiently, such as `getServerSideProps`, which allows you to fetch data and render it on the server for each request. This is particularly useful for dynamic content that changes frequently. By leveraging SSR in a mobile-focused Next.js project, you can ensure that your application remains performant and responsive across various devices and network conditions.

#### Online Resources
1. [Next.js Documentation](https://nextjs.org/docs/basic-features/pages#server-side-rendering)
2. [Server-Side Rendering with Next.js](https://www.smashingmagazine.com/2020/07/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Task 8: Examples to Practice

1. **Creating a Mobile-Focused Layout with SSR**
2. **Fetching Mobile-Specific Data with `getServerSideProps`**
3. **Optimizing Images for Mobile Devices**

### Example 1: Creating a Mobile-Focused Layout with SSR

Creating a mobile-focused layout involves designing a responsive UI that adapts to different screen sizes. With SSR, you can ensure that the initial HTML sent to the client is already optimized for mobile devices, providing a better user experience. This can include using CSS media queries, responsive grid systems, and flexible images.

To create a mobile-focused layout with SSR, you need to design your components to be responsive and ensure that the server renders the appropriate layout for mobile devices. This example demonstrates how to create a responsive Next.js page that adapts to different screen sizes.

#### Online Resources
1. [Responsive Design with CSS](https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Responsive_Design)
2. [Next.js Responsive Design](https://www.freecodecamp.org/news/learn-responsive-design-in-next-js/)

#### Code to Practice

```javascript
# Create a new page (pages/index.js)
import React from 'react';
import Head from 'next/head';
import styles from '../styles/Home.module.css';

const Home = () => (
  <div className={styles.container}>
    <Head>
      <title>Mobile-Focused Next.js Project</title>
    </Head>
    <header className={styles.header}>
      <h1>Welcome to Our Mobile-Focused Next.js Site</h1>
    </header>
    <main className={styles.main}>
      <p>This is a sample text demonstrating a mobile-friendly layout.</p>
    </main>
  </div>
);

export default Home;

# Create a CSS module for responsive design (styles/Home.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that adapts to different screen sizes, displaying a mobile-friendly layout with responsive design. The layout adjusts automatically for larger screens, providing a better user experience.

### Example 2: Fetching Mobile-Specific Data with `getServerSideProps`

Fetching mobile-specific data involves tailoring the content based on the client's device. With `getServerSideProps`, you can fetch data on the server for each request and render it accordingly. This is useful for providing device-specific content, such as optimized images or layout adjustments for mobile users.

To fetch mobile-specific data, you need to detect the client's device and fetch the appropriate data in the `getServerSideProps` function. This example demonstrates how to fetch and render mobile-specific content using `getServerSideProps`.

#### Online Resources
1. [Using getServerSideProps in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Server-Side Device Detection](https://dev.to/walecloud/device-detection-on-the-server-side-7ho)

#### Code to Practice

```javascript
# Create a new page (pages/mobile.js)
import React from 'react';

export async function getServerSideProps({ req }) {
  const userAgent = req.headers['user-agent'];
  const isMobile = /mobile/i.test(userAgent);

  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
      isMobile,
    },
  };
}

const MobilePage = ({ posts, isMobile }) => (
  <div>
    <h1>{isMobile ? 'Mobile' : 'Desktop'} View</h1>
    <ul>
      {posts.slice(0, 5).map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  </div>
);

export default MobilePage;
```

**Expected Output:**

A Next.js page that detects the user's device and renders mobile-specific content accordingly. The page displays different headings and content optimized for mobile and desktop views.

### Example 3: Optimizing Images for Mobile Devices

Optimizing images for mobile devices involves serving appropriately sized images to reduce load times and improve performance. Next.js provides the `next/image` component, which automatically optimizes images for different devices and screen sizes. By using this component, you can ensure that your images are efficiently loaded and displayed on mobile devices.

To optimize images for mobile devices, you need to use the `next/image` component and configure the image properties to serve different sizes based on the screen resolution. This example demonstrates how to use the `next/image` component to optimize images for mobile devices.

#### Online Resources
1. [Image Optimization with Next.js](https://nextjs.org/docs/basic-features/image-optimization)
2. [Responsive Images in Next.js](https://www.smashingmagazine.com/2021/05/responsive-images-next-js/)

#### Code to Practice

```javascript
# Create a new page (pages/images.js)
import React from 'react';
import Image from 'next/image';

const ImagesPage = () => (
  <div>
    <h1>Optimized Images for Mobile Devices</h1>
    <Image
      src="/path/to/image.jpg"
      alt="Sample Image"
      width={500}
      height={300}
      sizes="(max-width: 600px) 100vw, 50vw"
    />
  </div>
);

export default ImagesPage;

# Add the image to the public directory (public/path/to/image.jpg)
# Ensure the public directory contains the image you want to optimize
```

**Expected Output:**

A Next.js page that displays an optimized image using the `next/image` component. The image is served in different sizes based on the screen resolution, ensuring efficient loading and display on mobile devices.

---

### Task 9: Study Static Site Generation (SSG) with Next.js

Static Site Generation (SSG) is a technique used to generate static HTML pages at build time. Unlike Server-Side Rendering (SSR), which generates pages on each request, SSG pre-renders pages and serves them as static files. This approach can significantly improve performance and reduce server load, as static pages can be served quickly from a CDN or web server. Next.js provides built-in support for SSG through the `getStaticProps` and `getStaticPaths` functions, making it easy to generate static pages with dynamic content.

Next.js's SSG capabilities are particularly useful for content-heavy sites such as blogs, documentation, and e-commerce sites. By pre-rendering pages at build time, you can ensure that your site is fast, SEO-friendly, and highly scalable. Additionally, with incremental static regeneration (ISR), you can update static content without needing to rebuild the entire site, ensuring that your content remains fresh and up-to-date.

#### Online Resources
1. [Next.js Documentation on Static Generation](https://nextjs.org/docs/basic-features/pages#static-generation-recommended)
2. [Static Site Generation with Next.js](https://www.smashingmagazine.com/2020/06/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Examples to Practice

1. **Setting Up a Basic Static Site with Next.js**
2. **Generating Static Pages with Dynamic Content using `getStaticProps`**
3. **Generating Dynamic Routes with `getStaticPaths`**

### Example 1: Setting Up a Basic Static Site with Next.js

Setting up a basic static site with Next.js involves creating a new project, defining pages, and using the `getStaticProps` function to fetch data at build time. This approach ensures that the HTML pages are pre-rendered and served as static files, resulting in faster load times and improved performance.

To set up a basic static site, you need to create a new Next.js project, define some pages, and configure the project to use static generation. This example demonstrates the basic setup process for a static site with Next.js.

#### Online Resources
1. [Getting Started with Next.js](https://nextjs.org/docs/getting-started)
2. [Next.js Static Generation Basics](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)

#### Code to Practice

```bash
# Create a new Next.js project directory
mkdir nextjs-ssg-example
cd nextjs-ssg-example

# Initialize a new Node.js project
npm init -y

# Install Next.js, React, and ReactDOM
npm install next react react-dom

# Add the following scripts to package.json
# "scripts": {
#   "dev": "next dev",
#   "build": "next build",
#   "start": "next start"
# }

# Create the necessary project files
mkdir pages
touch pages/index.js

# Example index.js file
import React from 'react';

const Home = () => (
  <div>
    <h1>Welcome to Next.js Static Site</h1>
  </div>
);

export default Home;

# Start the development server
npm run dev
```

**Expected Output:**

A Next.js project with a simple home page that displays "Welcome to Next.js Static Site". The development server runs on `http://localhost:3000`, allowing you to view the application in your browser.

### Example 2: Generating Static Pages with Dynamic Content using `getStaticProps`

`getStaticProps` is a Next.js function that allows you to fetch data at build time and pre-render static pages with dynamic content. This is useful for creating pages that need to display data fetched from an API or database. By using `getStaticProps`, you can ensure that your pages are pre-rendered and served as static files, improving performance and SEO.

To generate static pages with dynamic content, you need to define the `getStaticProps` function in your page component and fetch the necessary data. This example demonstrates how to use `getStaticProps` to fetch data from an API and generate a static page.

#### Online Resources
1. [Using getStaticProps in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js Data Fetching](https://www.taniarascia.com/getting-started-with-next-js/)

#### Code to Practice

```javascript
# Create a new page (pages/posts.js)
import React from 'react';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const Posts = ({ posts }) => (
  <div>
    <h1>Posts</h1>
    <ul>
      {posts.map((post) => (
        <li key={post.id}>{post.title}</li>
      ))}
    </ul>
  </div>
);

export default Posts;
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them. The data is fetched at build time, and the page is pre-rendered and served as a static file.

### Example 3: Generating Dynamic Routes with `getStaticPaths`

`getStaticPaths` is a Next.js function that allows you to generate dynamic routes based on data fetched at build time. This is useful for creating pages with dynamic content, such as blog posts or product pages, where the routes are determined by the data. By using `getStaticPaths`, you can pre-render all the dynamic routes as static files, improving performance and SEO.

To generate dynamic routes, you need to define the `getStaticPaths` and `getStaticProps` functions in your page component. This example demonstrates how to use `getStaticPaths` and `getStaticProps` to generate dynamic routes for blog posts.

#### Online Resources
1. [Using getStaticPaths in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)
2. [Dynamic Routing with Next.js](https://www.smashingmagazine.com/2020/07/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Code to Practice

```javascript
# Create a new page (pages/posts/[id].js)
import React from 'react';

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
}

const Post = ({ post }) => (
  <div>
    <h1>{post.title}</h1>
    <p>{post.body}</p>
  </div>
);

export default Post;
```

**Expected Output:**

A Next.js page that generates dynamic routes for blog posts based on data fetched from an API. Each post is pre-rendered as a static file, ensuring fast load times and improved performance.

---

### Task 10: Implement SSG in a Mobile-Focused Next.js Project

Static Site Generation (SSG) in Next.js involves pre-rendering pages at build time to serve static HTML files. This approach can greatly enhance the performance, scalability, and SEO of web applications. For mobile-focused projects, SSG ensures that pages load quickly, even on slower mobile networks, providing a smoother and more responsive user experience. With Next.js, implementing SSG is straightforward, thanks to its built-in support for static generation through the `getStaticProps` and `getStaticPaths` functions.

In a mobile-focused Next.js project, you can use SSG to create highly optimized pages that cater to mobile users. By pre-rendering pages and leveraging responsive design principles, you can ensure that your site delivers fast, accessible, and user-friendly content. This approach also reduces the load on your server and enhances the scalability of your application.

#### Online Resources
1. [Next.js Static Generation](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Responsive Design with Next.js](https://www.smashingmagazine.com/2020/06/responsive-design-react-apps-css-in-js/)

#### Examples to Practice

1. **Setting Up a Mobile-Focused Static Site with Next.js**
2. **Generating Static Pages with Dynamic Content using `getStaticProps`**
3. **Creating Responsive Dynamic Routes with `getStaticPaths`**

### Example 1: Setting Up a Mobile-Focused Static Site with Next.js

Setting up a mobile-focused static site with Next.js involves creating a new project, defining responsive pages, and using `getStaticProps` to fetch data at build time. This approach ensures that the HTML pages are pre-rendered and served as static files, resulting in faster load times and improved performance, especially for mobile users.

To set up a mobile-focused static site, you need to create a new Next.js project, define responsive pages, and configure the project to use static generation. This example demonstrates the basic setup process for a static site with a mobile-friendly design using Next.js.

#### Online Resources
1. [Getting Started with Next.js](https://nextjs.org/docs/getting-started)
2. [Next.js Static Generation Basics](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)

#### Code to Practice

```bash
# Create a new Next.js project directory
mkdir nextjs-mobile-ssg
cd nextjs-mobile-ssg

# Initialize a new Node.js project
npm init -y

# Install Next.js, React, and ReactDOM
npm install next react react-dom

# Add the following scripts to package.json
# "scripts": {
#   "dev": "next dev",
#   "build": "next build",
#   "start": "next start"
# }

# Create the necessary project files
mkdir pages
touch pages/index.js

# Example index.js file
import React from 'react';
import Head from 'next/head';
import styles from '../styles/Home.module.css';

const Home = () => (
  <div className={styles.container}>
    <Head>
      <title>Mobile-Focused Static Site</title>
    </Head>
    <header className={styles.header}>
      <h1>Welcome to Our Mobile-Focused Static Site</h1>
    </header>
    <main className={styles.main}>
      <p>This is a sample text demonstrating a mobile-friendly layout.</p>
    </main>
  </div>
);

export default Home;

# Create a CSS module for responsive design (styles/Home.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}

# Start the development server
npm run dev
```

**Expected Output:**

A Next.js project with a responsive home page that adapts to different screen sizes, displaying a mobile-friendly layout. The development server runs on `http://localhost:3000`, allowing you to view the application in your browser.

### Example 2: Generating Static Pages with Dynamic Content using `getStaticProps`

`getStaticProps` is a Next.js function that allows you to fetch data at build time and pre-render static pages with dynamic content. This is useful for creating pages that need to display data fetched from an API or database. By using `getStaticProps`, you can ensure that your pages are pre-rendered and served as static files, improving performance and SEO.

To generate static pages with dynamic content, you need to define the `getStaticProps` function in your page component and fetch the necessary data. This example demonstrates how to use `getStaticProps` to fetch data from an API and generate a static page with a mobile-friendly layout.

#### Online Resources
1. [Using getStaticProps in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Next.js Data Fetching](https://www.taniarascia.com/getting-started-with-next-js/)

#### Code to Practice

```javascript
# Create a new page (pages/posts.js)
import React from 'react';
import Head from 'next/head';
import styles from '../styles/Posts.module.css';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const Posts = ({ posts }) => (
  <div className={styles.container}>
    <Head>
      <title>Posts</title>
    </Head>
    <header className={styles.header}>
      <h1>Posts</h1>
    </header>
    <main className={styles.main}>
      <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  </div>
);

export default Posts;

# Create a CSS module for responsive design (styles/Posts.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them in a mobile-friendly layout. The data is fetched at build time, and the page is pre-rendered and served as a static file.

### Example 3: Creating Responsive Dynamic Routes with `getStaticPaths`

`getStaticPaths` is a Next.js function that allows you to generate dynamic routes based on data fetched at build time. This is useful for creating pages with dynamic content, such as blog posts or product pages, where the routes are determined by the data. By using `getStaticPaths`, you can pre-render all the dynamic routes as static files, improving performance and SEO.

To generate dynamic routes, you need to define the `getStaticPaths` and `getStaticProps` functions in your page component. This example demonstrates how to use `getStaticPaths` and `getStaticProps` to generate dynamic routes for blog posts with a mobile-friendly layout.

#### Online Resources
1. [Using getStaticPaths in Next.js](https://nextjs.org/docs/basic-features/data-fetching#getstaticpaths-static-generation)
2. [Dynamic Routing with Next.js](https://www.smashingmagazine.com/2020/07/introduction-nextjs-static-site-generation-server-side-rendering/)

#### Code to Practice

```javascript
# Create a new page (pages/posts/[id].js)
import React from 'react';
import Head from 'next/head';
import styles from '../../styles/Post.module.css';

export async function getStaticPaths() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  const paths = posts.map((post) => ({
    params: { id: post.id.toString() },
  }));

  return { paths, fallback: false };
}

export async function getStaticProps({ params }) {
  const res = await fetch(`https://jsonplaceholder.typicode.com/posts/${params.id}`);
  const post = await res.json();

  return {
    props: {
      post,
    },
  };
}

const Post = ({ post }) => (
  <div className={styles.container}>
    <Head>
      <title>{post.title}</title>
    </Head>
    <header className={styles.header}>
      <h1>{post.title}</h1>
    </header>
    <main className={styles.main}>
      <p>{post.body}</p>
    </main>
  </div>
);

export default Post;

# Create a CSS module for responsive design (styles/Post.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that generates dynamic routes for blog posts based on data fetched from an API. Each post is pre-rendered as a static file with a mobile-friendly layout, ensuring fast load times and improved performance.

---

### Task 11: Study Hybrid Rendering Techniques

Hybrid rendering techniques combine the benefits of client-side rendering (CSR) and server-side rendering (SSR) to optimize performance and user experience. By using hybrid rendering, developers can pre-render parts of the application on the server while still taking advantage of the interactivity and dynamic capabilities of client-side rendering. This approach is particularly useful for improving initial load times and SEO while maintaining a responsive and interactive user experience.

Hybrid rendering often involves the use of static site generation (SSG) for pages that don't change frequently, SSR for pages that need to be dynamically generated on each request, and CSR for parts of the application that require real-time updates or complex interactions. Understanding and implementing hybrid rendering techniques can help developers build scalable, high-performance applications that provide a seamless user experience across different devices and network conditions.

#### Online Resources
1. [Next.js Hybrid Rendering](https://nextjs.org/docs/basic-features/pages#static-generation-with-data)
2. [Hybrid Rendering in Modern Web Applications](https://blog.logrocket.com/static-dynamic-hybrid-rendering-strategies-modern-web-apps/)

#### Examples to Practice

1. **Implementing Hybrid Rendering with Static Generation and Client-Side Fetching**
2. **Combining SSR and CSR in a Next.js Project**
3. **Using Incremental Static Regeneration (ISR) for Dynamic Content**

### Example 1: Implementing Hybrid Rendering with Static Generation and Client-Side Fetching

Implementing hybrid rendering with static generation and client-side fetching involves pre-rendering the initial HTML on the server and then fetching additional data on the client-side after the initial page load. This approach improves the initial load time and SEO while allowing for dynamic content updates on the client side.

To implement hybrid rendering, you can use `getStaticProps` to generate static pages and the `useEffect` hook to fetch additional data on the client side. This example demonstrates how to pre-render a list of items and then fetch additional details for each item on the client side.

#### Online Resources
1. [Next.js Static Generation with Data](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Client-Side Fetching with React](https://reactjs.org/docs/faq-ajax.html)

#### Code to Practice

```javascript
# Create a new page (pages/hybrid.js)
import React, { useEffect, useState } from 'react';
import Head from 'next/head';
import styles from '../styles/Hybrid.module.css';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const HybridPage = ({ posts }) => {
  const [details, setDetails] = useState([]);

  useEffect(() => {
    const fetchDetails = async () => {
      const res = await fetch('https://jsonplaceholder.typicode.com/comments');
      const data = await res.json();
      setDetails(data);
    };

    fetchDetails();
  }, []);

  return (
    <div className={styles.container}>
      <Head>
        <title>Hybrid Rendering Example</title>
      </Head>
      <header className={styles.header}>
        <h1>Hybrid Rendering with Static Generation and Client-Side Fetching</h1>
      </header>
      <main className={styles.main}>
        <h2>Posts</h2>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
        <h2>Comments</h2>
        {details.length > 0 ? (
          <ul>
            {details.map((comment) => (
              <li key={comment.id}>{comment.body}</li>
            ))}
          </ul>
        ) : (
          <p>Loading comments...</p>
        )}
      </main>
    </div>
  );
};

export default HybridPage;

# Create a CSS module for responsive design (styles/Hybrid.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that pre-renders a list of posts using static generation and fetches additional details (comments) on the client side after the initial load. The page displays a loading message while fetching the comments and updates the UI once the data is available.

### Example 2: Combining SSR and CSR in a Next.js Project

Combining SSR and CSR in a Next.js project involves rendering parts of the application on the server for faster initial load times and SEO benefits while leveraging client-side rendering for interactivity and dynamic updates. This approach provides the best of both worlds, ensuring a performant and responsive application.

To combine SSR and CSR, you can use `getServerSideProps` for server-side rendering and React hooks for client-side interactivity. This example demonstrates how to render a list of items on the server and enable client-side interactions such as filtering and searching.

#### Online Resources
1. [Server-Side Rendering with Next.js](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Client-Side Interactivity in React](https://reactjs.org/docs/hooks-intro.html)

#### Code to Practice

```javascript
# Create a new page (pages/ssr-csr.js)
import React, { useState } from 'react';
import Head from 'next/head';
import styles from '../styles/SSRCSR.module.css';

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const SSRCSRPage = ({ posts }) => {
  const [filter, setFilter] = useState('');

  const filteredPosts = posts.filter((post) =>
    post.title.toLowerCase().includes(filter.toLowerCase())
  );

  return (
    <div className={styles.container}>
      <Head>
        <title>SSR and CSR Example</title>
      </Head>
      <header className={styles.header}>
        <h1>Combining SSR and CSR in Next.js</h1>
      </header>
      <main className={styles.main}>
        <input
          type="text"
          placeholder="Filter posts"
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
        />
        <ul>
          {filteredPosts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      </main>
    </div>
  );
};

export default SSRCSRPage;

# Create a CSS module for responsive design (styles/SSRCSR.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

input {
  margin-bottom: 20px;
  padding: 10px;
  font-size: 16px;
  width: 80%;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }

  input {
    width: 40%;
  }
}
```

**Expected Output:**

A Next.js page that uses server-side rendering to fetch and display a list of posts and allows users to filter the posts using a client-side search input. The initial list is rendered on the server, and the filtering is handled on the client side, providing a responsive and interactive experience.

### Example 3: Using Incremental Static Regeneration (ISR) for Dynamic Content

Incremental Static Regeneration (ISR) allows you to update static pages after the initial build without rebuilding the entire site. This technique is useful for content that changes frequently but does not require real-time updates. ISR ensures that your static pages remain fresh and up-to-date by regenerating them at specific intervals.

To implement ISR, you can use `getStaticProps` with the `revalidate` property to specify the regeneration interval. This example demonstrates how to use ISR to fetch data from an API and regenerate the static pages at regular intervals.

#### Online Resources
1. [Incremental Static Regeneration in Next.js](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [Using ISR for Dynamic Content](https://www.smashingmagazine.com/2021/03/using-nextjs-incremental-static-regeneration/)

#### Code to Practice

```javascript
# Create a new page (pages/isr.js)
import React from 'react';
import Head from 'next/head';
import styles from '../styles/ISR.module.css';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 10, // Regenerate the page at most once every 10 seconds
  };
}

const ISRPage = ({ posts }) => (
  <div className={styles.container}>
    <Head>
      <title>ISR Example</title>
    </Head>
    <header className={styles.header}>
      <h1>Incremental Static Regeneration (ISR) Example</h1>
    </header>
    <main className={styles.main}>
     

 <ul>
        {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  </div>
);

export default ISRPage;

# Create a CSS module for responsive design (styles/ISR.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them. The data is fetched at build time and the page is pre-rendered as a static file. The page is regenerated at most once every 10 seconds, ensuring that the content remains up-to-date without requiring a full rebuild.

---

### Task 12: Implement Hybrid Rendering with Next.js for Mobile

Hybrid rendering with Next.js combines server-side rendering (SSR), static site generation (SSG), and client-side rendering (CSR) to optimize performance and user experience, particularly for mobile users. By leveraging these techniques, developers can ensure that pages load quickly, are SEO-friendly, and provide dynamic interactivity. This approach is especially beneficial for mobile applications where network speeds can vary, and a fast, responsive experience is crucial.

Implementing hybrid rendering in a Next.js project involves using SSR for dynamic content that needs to be rendered on each request, SSG for content that can be pre-rendered at build time, and CSR for interactive elements that require client-side updates. By carefully selecting the appropriate rendering method for each part of the application, developers can create a seamless, performant experience for mobile users.

#### Online Resources
1. [Next.js Hybrid Rendering](https://nextjs.org/docs/basic-features/pages#static-generation-with-data)
2. [Hybrid Rendering in Modern Web Applications](https://blog.logrocket.com/static-dynamic-hybrid-rendering-strategies-modern-web-apps/)

#### Examples to Practice

1. **Implementing Static Generation with Client-Side Data Fetching**
2. **Combining SSR and CSR for Dynamic Interactions**
3. **Using Incremental Static Regeneration for Frequent Updates**

### Example 1: Implementing Static Generation with Client-Side Data Fetching

Static generation with client-side data fetching involves pre-rendering the initial HTML on the server and fetching additional data on the client side after the initial page load. This approach improves the initial load time and SEO while allowing for dynamic content updates on the client side.

To implement this, you can use `getStaticProps` to generate static pages and the `useEffect` hook to fetch additional data on the client side. This example demonstrates how to pre-render a list of items and then fetch additional details for each item on the client side.

#### Online Resources
1. [Next.js Static Generation with Data](https://nextjs.org/docs/basic-features/data-fetching#getstaticprops-static-generation)
2. [Client-Side Fetching with React](https://reactjs.org/docs/faq-ajax.html)

#### Code to Practice

```javascript
// Create a new page (pages/hybrid-static.js)
import React, { useEffect, useState } from 'react';
import Head from 'next/head';
import styles from '../styles/Hybrid.module.css';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const HybridStaticPage = ({ posts }) => {
  const [details, setDetails] = useState([]);

  useEffect(() => {
    const fetchDetails = async () => {
      const res = await fetch('https://jsonplaceholder.typicode.com/comments');
      const data = await res.json();
      setDetails(data);
    };

    fetchDetails();
  }, []);

  return (
    <div className={styles.container}>
      <Head>
        <title>Hybrid Static Rendering Example</title>
      </Head>
      <header className={styles.header}>
        <h1>Hybrid Rendering with Static Generation and Client-Side Fetching</h1>
      </header>
      <main className={styles.main}>
        <h2>Posts</h2>
        <ul>
          {posts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
        <h2>Comments</h2>
        {details.length > 0 ? (
          <ul>
            {details.map((comment) => (
              <li key={comment.id}>{comment.body}</li>
            ))}
          </ul>
        ) : (
          <p>Loading comments...</p>
        )}
      </main>
    </div>
  );
};

export default HybridStaticPage;

// Create a CSS module for responsive design (styles/Hybrid.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that pre-renders a list of posts using static generation and fetches additional details (comments) on the client side after the initial load. The page displays a loading message while fetching the comments and updates the UI once the data is available.

### Example 2: Combining SSR and CSR for Dynamic Interactions

Combining SSR and CSR in a Next.js project involves rendering parts of the application on the server for faster initial load times and SEO benefits while leveraging client-side rendering for interactivity and dynamic updates. This approach provides the best of both worlds, ensuring a performant and responsive application.

To combine SSR and CSR, you can use `getServerSideProps` for server-side rendering and React hooks for client-side interactivity. This example demonstrates how to render a list of items on the server and enable client-side interactions such as filtering and searching.

#### Online Resources
1. [Server-Side Rendering with Next.js](https://nextjs.org/docs/basic-features/data-fetching#getserversideprops-server-side-rendering)
2. [Client-Side Interactivity in React](https://reactjs.org/docs/hooks-intro.html)

#### Code to Practice

```javascript
// Create a new page (pages/hybrid-ssr-csr.js)
import React, { useState } from 'react';
import Head from 'next/head';
import styles from '../styles/SSRCSR.module.css';

export async function getServerSideProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
  };
}

const HybridSSRCSRPage = ({ posts }) => {
  const [filter, setFilter] = useState('');

  const filteredPosts = posts.filter((post) =>
    post.title.toLowerCase().includes(filter.toLowerCase())
  );

  return (
    <div className={styles.container}>
      <Head>
        <title>Hybrid SSR and CSR Example</title>
      </Head>
      <header className={styles.header}>
        <h1>Combining SSR and CSR in Next.js</h1>
      </header>
      <main className={styles.main}>
        <input
          type="text"
          placeholder="Filter posts"
          value={filter}
          onChange={(e) => setFilter(e.target.value)}
        />
        <ul>
          {filteredPosts.map((post) => (
            <li key={post.id}>{post.title}</li>
          ))}
        </ul>
      </main>
    </div>
  );
};

export default HybridSSRCSRPage;

// Create a CSS module for responsive design (styles/SSRCSR.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

input {
  margin-bottom: 20px;
  padding: 10px;
  font-size: 16px;
  width: 80%;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }

  input {
    width: 40%;
  }
}
```

**Expected Output:**

A Next.js page that uses server-side rendering to fetch and display a list of posts and allows users to filter the posts using a client-side search input. The initial list is rendered on the server, and the filtering is handled on the client side, providing a responsive and interactive experience.

### Example 3: Using Incremental Static Regeneration for Frequent Updates

Incremental Static Regeneration (ISR) allows you to update static pages after the initial build without rebuilding the entire site. This technique is useful for content that changes frequently but does not require real-time updates. ISR ensures that your static pages remain fresh and up-to-date by regenerating them at specific intervals.

To implement ISR, you can use `getStaticProps` with the `revalidate` property to specify the regeneration interval. This example demonstrates how to use ISR to fetch data from an API and regenerate the static pages at regular intervals.

#### Online Resources
1. [Incremental Static Regeneration in Next.js](https://nextjs.org/docs/basic-features/data-fetching#incremental-static-regeneration)
2. [Using ISR for Dynamic Content](https://www.smashingmagazine.com/2021/03/using-nextjs-incremental-static-regeneration/)

#### Code to Practice

```javascript
// Create a new page (pages/hybrid-isr.js)
import React from 'react';
import Head from 'next/head';
import styles from '../styles/ISR.module.css';

export async function getStaticProps() {
  const res = await fetch('https://jsonplaceholder.typicode.com/posts');
  const posts = await res.json();

  return {
    props: {
      posts,
    },
    revalidate: 10, // Regenerate the page at most once every 10 seconds
  };
}

const ISRPage = ({ posts }) => (
  <div className={styles.container}>
    <Head>
      <title>ISR Example</title>
    </Head>
    <header className={styles.header}>
      <h1>Incremental Static Regeneration (ISR) Example</h1>
    </header>
    <main className={styles.main}>
      <ul>
       

 {posts.map((post) => (
          <li key={post.id}>{post.title}</li>
        ))}
      </ul>
    </main>
  </div>
);

export default ISRPage;

// Create a CSS module for responsive design (styles/ISR.module.css)
.container {
  padding: 20px;
  font-family: Arial, sans-serif;
}

.header {
  text-align: center;
}

.main {
  display: flex;
  flex-direction: column;
  align-items: center;
}

@media (min-width: 600px) {
  .main {
    flex-direction: row;
    justify-content: space-around;
  }
}
```

**Expected Output:**

A Next.js page that fetches a list of posts from an API and displays them. The data is fetched at build time and the page is pre-rendered as a static file. The page is regenerated at most once every 10 seconds, ensuring that the content remains up-to-date without requiring a full rebuild.

---

### Task 13: Study Advanced Data Synchronization

Advanced data synchronization in mobile applications is critical for ensuring that data is consistent and up-to-date across different devices and platforms. This process involves synchronizing local data with a remote server, handling offline scenarios, resolving conflicts, and ensuring data integrity. Effective data synchronization enhances the user experience by providing seamless access to updated information, even when the device is offline or has intermittent connectivity.

In React Native, advanced data synchronization can be achieved using various techniques and libraries, such as Redux Offline, Apollo Client for GraphQL, or Firebase. These tools provide mechanisms for caching data locally, synchronizing changes with the server, and managing conflicts. By implementing advanced data synchronization, developers can build robust applications that offer a smooth and consistent user experience across different network conditions.

#### Online Resources
1. [Handling Offline Data in React Native](https://medium.com/swlh/handling-offline-data-in-react-native-64e40a11c394)
2. [Advanced Data Synchronization with Apollo Client](https://www.apollographql.com/docs/react/caching/cache-interaction/)

#### Examples to Practice

1. **Using Redux Offline for Data Synchronization**
2. **Implementing Data Synchronization with Apollo Client**
3. **Using Firebase for Real-Time Data Synchronization**

### Example 1: Using Redux Offline for Data Synchronization

Redux Offline is a library that extends Redux to handle offline capabilities and data synchronization. It provides tools for managing application state, caching data locally, and synchronizing changes with a remote server when connectivity is restored. Redux Offline helps manage the complexities of offline-first applications, ensuring that users can continue to work without an internet connection and that their changes are synchronized once they go online.

To use Redux Offline, you need to set up Redux in your React Native project, configure Redux Offline, and define your actions and reducers. This example demonstrates how to configure Redux Offline for data synchronization in a React Native application.

#### Online Resources
1. [Redux Offline Documentation](https://redux-offline.github.io/redux-offline/)
2. [Offline-First Apps with Redux Offline](https://blog.bitsrc.io/offline-first-apps-redux-offline-ef4b66737d85)

#### Code to Practice

```bash
# Install Redux, Redux Offline, and related packages
npm install redux redux-offline redux-offline/redux-saga react-redux

# Create the necessary files
mkdir store
touch store/index.js

# Configure Redux and Redux Offline (store/index.js)
import { createStore, applyMiddleware } from 'redux';
import { offline } from '@redux-offline/redux-offline';
import defaultConfig from '@redux-offline/redux-offline/lib/defaults';
import reducer from './reducer';

const store = createStore(reducer, offline(defaultConfig)(applyMiddleware()));

export default store;

# Define the reducer (store/reducer.js)
const initialState = {
  items: [],
};

const reducer = (state = initialState, action) => {
  switch (action.type) {
    case 'ADD_ITEM':
      return {
        ...state,
        items: [...state.items, action.payload],
      };
    default:
      return state;
  }
};

export default reducer;

# Create the main application file (App.js)
import React, { useState } from 'react';
import { Provider, useDispatch, useSelector } from 'react-redux';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import store from './store';

const App = () => (
  <Provider store={store}>
    <ItemManager />
  </Provider>
);

const ItemManager = () => {
  const [item, setItem] = useState('');
  const dispatch = useDispatch();
  const items = useSelector((state) => state.items);

  const addItem = () => {
    dispatch({ type: 'ADD_ITEM', payload: item });
    setItem('');
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={item}
        onChangeText={setItem}
        placeholder="Add an item"
      />
      <Button title="Add Item" onPress={addItem} />
      <FlatList
        data={items}
        renderItem={({ item }) => <Text>{item}</Text>}
        keyExtractor={(item, index) => index.toString()}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '80%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that allows users to add items to a list. The items are stored locally and can be synchronized with a remote server once connectivity is restored. Redux Offline handles the offline-first capabilities and data synchronization.

### Example 2: Implementing Data Synchronization with Apollo Client

Apollo Client is a powerful state management library for GraphQL that provides tools for caching, querying, and data synchronization. By using Apollo Client, you can efficiently manage data synchronization between your React Native application and a GraphQL server. Apollo Client's caching mechanisms and offline capabilities ensure that your application remains responsive and functional, even when offline.

To implement data synchronization with Apollo Client, you need to set up Apollo Client in your React Native project, define your GraphQL queries and mutations, and configure the client for offline support. This example demonstrates how to configure Apollo Client for data synchronization in a React Native application.

#### Online Resources
1. [Apollo Client Documentation](https://www.apollographql.com/docs/react/)
2. [GraphQL Data Synchronization with Apollo Client](https://www.apollographql.com/docs/react/data/queries/)

#### Code to Practice

```bash
# Install Apollo Client and GraphQL packages
npm install @apollo/client graphql

# Create the necessary files
mkdir graphql
touch graphql/client.js

# Configure Apollo Client (graphql/client.js)
import { ApolloClient, InMemoryCache, createHttpLink } from '@apollo/client';
import { setContext } from '@apollo/client/link/context';
import { ApolloProvider } from '@apollo/client';
import { OfflineLink } from '@apollo/client/link/offline';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = createHttpLink({
  uri: 'https://example.com/graphql',
});

const authLink = setContext((_, { headers }) => {
  const token = localStorage.getItem('token');
  return {
    headers: {
      ...headers,
      authorization: token ? `Bearer ${token}` : '',
    },
  };
});

const offlineLink = new OfflineLink();

const client = new ApolloClient({
  link: offlineLink.concat(authLink.concat(httpLink)),
  cache: new InMemoryCache(),
});

export default client;

# Create the main application file (App.js)
import React, { useState } from 'react';
import { ApolloProvider, useQuery, useMutation, gql } from '@apollo/client';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import client from './graphql/client';

const GET_ITEMS = gql`
  query GetItems {
    items {
      id
      name
    }
  }
`;

const ADD_ITEM = gql`
  mutation AddItem($name: String!) {
    addItem(name: $name) {
      id
      name
    }
  }
`;

const App = () => (
  <ApolloProvider client={client}>
    <ItemManager />
  </ApolloProvider>
);

const ItemManager = () => {
  const { loading, error, data } = useQuery(GET_ITEMS);
  const [addItem] = useMutation(ADD_ITEM, {
    refetchQueries: [{ query: GET_ITEMS }],
  });
  const [item, setItem] = useState('');

  const handleAddItem = () => {
    addItem({ variables: { name: item } });
    setItem('');
  };

  if (loading) return <Text>Loading...</Text>;
  if (error) return <Text>Error: {error.message}</Text>;

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={item}
        onChangeText={setItem}
        placeholder="Add an item"
      />
      <Button title="Add Item" onPress={handleAddItem} />
      <FlatList
        data={data.items}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '80%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that allows users to add items to a list. The items are synchronized with a GraphQL server using Apollo Client. The application supports offline capabilities and data synchronization.

### Example 3: Using Firebase for Real-Time Data Synchronization

Firebase provides real-time data synchronization capabilities through its Firestore database. Firestore allows you to store and sync data between your React Native application and the Firebase server in real-time. This ensures that your application remains up-to-date with the latest data changes, even across multiple devices.

To use Firebase for real-time data synchronization, you need to set up Firebase in your React Native project

, configure Firestore, and implement real-time listeners to sync data. This example demonstrates how to configure Firebase and Firestore for real-time data synchronization in a React Native application.

#### Online Resources
1. [Firebase Firestore Documentation](https://firebase.google.com/docs/firestore)
2. [React Native Firebase Integration](https://rnfirebase.io/)

#### Code to Practice

```bash
# Install Firebase packages
npm install @react-native-firebase/app @react-native-firebase/firestore

# Create the necessary files
mkdir firebase
touch firebase/config.js

# Configure Firebase (firebase/config.js)
import firebase from '@react-native-firebase/app';
import firestore from '@react-native-firebase/firestore';

const firebaseConfig = {
  apiKey: 'YOUR_API_KEY',
  authDomain: 'YOUR_AUTH_DOMAIN',
  projectId: 'YOUR_PROJECT_ID',
  storageBucket: 'YOUR_STORAGE_BUCKET',
  messagingSenderId: 'YOUR_MESSAGING_SENDER_ID',
  appId: 'YOUR_APP_ID',
};

if (!firebase.apps.length) {
  firebase.initializeApp(firebaseConfig);
}

export { firestore };

# Create the main application file (App.js)
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';
import { firestore } from './firebase/config';

const App = () => {
  const [item, setItem] = useState('');
  const [items, setItems] = useState([]);

  useEffect(() => {
    const unsubscribe = firestore().collection('items').onSnapshot((snapshot) => {
      const newItems = snapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      }));
      setItems(newItems);
    });

    return () => unsubscribe();
  }, []);

  const addItem = async () => {
    await firestore().collection('items').add({ name: item });
    setItem('');
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        value={item}
        onChangeText={setItem}
        placeholder="Add an item"
      />
      <Button title="Add Item" onPress={addItem} />
      <FlatList
        data={items}
        renderItem={({ item }) => <Text>{item.name}</Text>}
        keyExtractor={(item) => item.id.toString()}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '80%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that allows users to add items to a list. The items are stored in Firebase Firestore and synchronized in real-time with the Firebase server. The application updates the UI to reflect changes in the data in real-time.

---

### Task 14: Implement Synchronization with GraphQL Subscriptions

GraphQL subscriptions are a powerful feature that enables real-time updates to clients when data changes on the server. Using WebSocket connections, subscriptions provide a mechanism for clients to listen for specific events and automatically receive updates. This is particularly useful in applications that require real-time data synchronization, such as chat applications, live sports updates, or collaborative tools.

By implementing GraphQL subscriptions in a React Native application, you can ensure that your app remains up-to-date with the latest data without requiring manual refreshes or polling. This approach improves user experience by providing instant updates and reducing the load on the server. Tools like Apollo Client make it straightforward to set up and manage GraphQL subscriptions, integrating seamlessly with existing GraphQL queries and mutations.

#### Online Resources
1. [GraphQL Subscriptions with Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)
2. [Building a Real-Time Chat App with GraphQL Subscriptions](https://blog.apollographql.com/tutorial-building-a-realtime-chat-app-with-graphql-subscriptions-555bfc05c39d)

#### Examples to Practice

1. **Setting Up Apollo Client with WebSocket Link for Subscriptions**
2. **Implementing Real-Time Data Synchronization with GraphQL Subscriptions**
3. **Building a Real-Time Chat Application with GraphQL Subscriptions**

### Example 1: Setting Up Apollo Client with WebSocket Link for Subscriptions

To use GraphQL subscriptions in a React Native application, you need to set up Apollo Client with a WebSocket link. This involves configuring the client to use both HTTP and WebSocket links for handling queries, mutations, and subscriptions. The WebSocket link enables the client to establish and maintain a connection with the server for real-time updates.

#### Online Resources
1. [Setting Up Apollo Client](https://www.apollographql.com/docs/react/get-started/)
2. [WebSocket Link in Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/#setting-up-the-websocket-link)

#### Code to Practice

```bash
# Install Apollo Client, GraphQL, and WebSocket packages
npm install @apollo/client graphql subscriptions-transport-ws

# Create the necessary files
mkdir graphql
touch graphql/client.js

# Configure Apollo Client with WebSocket Link (graphql/client.js)
import { ApolloClient, InMemoryCache, split } from '@apollo/client';
import { WebSocketLink } from '@apollo/client/link/ws';
import { HttpLink } from '@apollo/client/link/http';
import { getMainDefinition } from '@apollo/client/utilities';

const httpLink = new HttpLink({
  uri: 'https://example.com/graphql',
});

const wsLink = new WebSocketLink({
  uri: `ws://example.com/graphql`,
  options: {
    reconnect: true,
  },
});

const splitLink = split(
  ({ query }) => {
    const definition = getMainDefinition(query);
    return (
      definition.kind === 'OperationDefinition' &&
      definition.operation === 'subscription'
    );
  },
  wsLink,
  httpLink
);

const client = new ApolloClient({
  link: splitLink,
  cache: new InMemoryCache(),
});

export default client;

# Create the main application file (App.js)
import React from 'react';
import { ApolloProvider } from '@apollo/client';
import client from './graphql/client';
import Chat from './Chat';

const App = () => (
  <ApolloProvider client={client}>
    <Chat />
  </ApolloProvider>
);

export default App;
```

**Expected Output:**

A React Native application with Apollo Client configured to use both HTTP and WebSocket links. This setup enables the application to handle GraphQL queries, mutations, and subscriptions, providing a foundation for real-time data synchronization.

### Example 2: Implementing Real-Time Data Synchronization with GraphQL Subscriptions

Implementing real-time data synchronization with GraphQL subscriptions involves defining the subscription query on the server and subscribing to it on the client. The client listens for updates from the server and automatically updates the local state when new data is received. This example demonstrates how to implement a simple subscription for real-time updates.

#### Online Resources
1. [GraphQL Subscriptions in Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)
2. [Real-Time GraphQL Subscriptions](https://graphql.org/blog/subscriptions-in-graphql-and-relay/)

#### Code to Practice

```bash
# Create a new file for the subscription component (Chat.js)
import React, { useEffect } from 'react';
import { useSubscription, gql } from '@apollo/client';
import { View, Text, FlatList, StyleSheet } from 'react-native';

const MESSAGE_SUBSCRIPTION = gql`
  subscription OnMessageAdded {
    messageAdded {
      id
      content
      user
    }
  }
`;

const Chat = () => {
  const { data, loading } = useSubscription(MESSAGE_SUBSCRIPTION);

  useEffect(() => {
    if (data) {
      console.log('New message:', data.messageAdded);
    }
  }, [data]);

  if (loading) return <Text>Loading...</Text>;

  return (
    <View style={styles.container}>
      <FlatList
        data={data ? [data.messageAdded] : []}
        renderItem={({ item }) => (
          <View style={styles.message}>
            <Text>{item.user}: {item.content}</Text>
          </View>
        )}
        keyExtractor={(item) => item.id}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  message: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
});

export default Chat;
```

**Expected Output:**

A React Native component that subscribes to new messages and updates the UI in real-time when a new message is received. The subscription listens for `messageAdded` events from the server and displays the new messages in a list.

### Example 3: Building a Real-Time Chat Application with GraphQL Subscriptions

Building a real-time chat application with GraphQL subscriptions involves combining queries, mutations, and subscriptions to handle fetching initial data, sending new messages, and receiving updates in real-time. This example demonstrates how to build a simple chat application that supports real-time messaging using GraphQL subscriptions.

#### Online Resources
1. [Building a Chat App with GraphQL Subscriptions](https://www.apollographql.com/blog/tutorial-building-a-realtime-chat-app-with-graphql-subscriptions-555bfc05c39d)
2. [GraphQL Subscriptions with Apollo Client](https://www.apollographql.com/docs/react/data/subscriptions/)

#### Code to Practice

```bash
# Create a new file for the chat application component (ChatApp.js)
import React, { useState, useEffect } from 'react';
import { useQuery, useMutation, useSubscription, gql } from '@apollo/client';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';

const GET_MESSAGES = gql`
  query GetMessages {
    messages {
      id
      content
      user
    }
  }
`;

const ADD_MESSAGE = gql`
  mutation AddMessage($content: String!, $user: String!) {
    addMessage(content: $content, user: $user) {
      id
      content
      user
    }
  }
`;

const MESSAGE_SUBSCRIPTION = gql`
  subscription OnMessageAdded {
    messageAdded {
      id
      content
      user
    }
  }
`;

const ChatApp = () => {
  const { data: queryData, loading: queryLoading } = useQuery(GET_MESSAGES);
  const [addMessage] = useMutation(ADD_MESSAGE);
  const { data: subscriptionData } = useSubscription(MESSAGE_SUBSCRIPTION);
  const [messages, setMessages] = useState([]);
  const [messageContent, setMessageContent] = useState('');
  const [user, setUser] = useState('User1');

  useEffect(() => {
    if (queryData) {
      setMessages(queryData.messages);
    }
  }, [queryData]);

  useEffect(() => {
    if (subscriptionData) {
      setMessages((prevMessages) => [...prevMessages, subscriptionData.messageAdded]);
    }
  }, [subscriptionData]);

  const handleSendMessage = () => {
    addMessage({ variables: { content: messageContent, user } });
    setMessageContent('');
  };

  if (queryLoading) return <Text>Loading...</Text>;

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => (
          <View style={styles.message}>
            <Text>{item.user}: {item.content}</Text>
          </View>
        )}
        keyExtractor={(item) => item.id}
      />
      <TextInput
        style={styles.input}
        value={messageContent}
        onChangeText={setMessageContent}
        placeholder="Type a message"
      />
      <Button title="Send" onPress={handleSendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  message: {
    padding: 10,
    borderBottomWidth: 1,
    borderBottomColor: '#ccc',
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '80%',
  },
});

export default ChatApp;

# Update

 App.js to use ChatApp
import React from 'react';
import { ApolloProvider } from '@apollo/client';
import client from './graphql/client';
import ChatApp from './ChatApp';

const App = () => (
  <ApolloProvider client={client}>
    <ChatApp />
  </ApolloProvider>
);

export default App;
```

**Expected Output:**

A real-time chat application built with React Native and GraphQL subscriptions. Users can send messages, and new messages are received and displayed in real-time. The application uses Apollo Client to handle GraphQL queries, mutations, and subscriptions, ensuring that the chat data is synchronized across all connected clients.

---

### Task 15: Study Secure Storage Solutions

Secure storage solutions are essential in mobile applications to protect sensitive data such as authentication tokens, user credentials, and other personal information. These solutions involve encrypting data at rest, ensuring that unauthorized access is prevented even if the device is compromised. React Native provides several libraries and tools to implement secure storage, such as `react-native-keychain` and `react-native-sensitive-info`, which offer secure storage options by leveraging the underlying operating system's security mechanisms.

Implementing secure storage in a React Native application involves choosing the right library, understanding its capabilities, and integrating it into your app to securely store and retrieve sensitive information. By using secure storage solutions, developers can enhance the security of their applications, comply with data protection regulations, and protect user data from potential breaches.

#### Online Resources
1. [React Native Keychain Documentation](https://github.com/oblador/react-native-keychain)
2. [Secure Storage in React Native](https://medium.com/@ankitvijay009/secure-storage-in-react-native-1bd7b8bf3d0d)

#### Examples to Practice

1. **Using React Native Keychain for Secure Storage**
2. **Implementing Secure Storage with React Native Sensitive Info**
3. **Combining AsyncStorage with Encryption for Secure Data Storage**

### Example 1: Using React Native Keychain for Secure Storage

React Native Keychain is a library that provides secure key/value storage by leveraging the native keychain services on iOS and the Keystore system on Android. It allows you to securely store and retrieve sensitive data such as authentication tokens, user credentials, and other confidential information.

To use React Native Keychain, you need to install the library, configure it in your React Native project, and use its API to store and retrieve data securely. This example demonstrates how to store and retrieve a user's credentials using React Native Keychain.

#### Online Resources
1. [React Native Keychain GitHub](https://github.com/oblador/react-native-keychain)
2. [Using React Native Keychain](https://medium.com/@sajaldua/using-react-native-keychain-for-securely-storing-sensitive-data-in-your-app-e70dbf31d4a5)

#### Code to Practice

```bash
# Install React Native Keychain
npm install react-native-keychain

# Link the library (for React Native <= 0.59)
react-native link react-native-keychain

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import * as Keychain from 'react-native-keychain';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedCredentials, setRetrievedCredentials] = useState(null);

  const storeCredentials = async () => {
    await Keychain.setGenericPassword(username, password);
    alert('Credentials stored successfully!');
  };

  const retrieveCredentials = async () => {
    const credentials = await Keychain.getGenericPassword();
    if (credentials) {
      setRetrievedCredentials(credentials);
    } else {
      alert('No credentials stored');
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <Button title="Store Credentials" onPress={storeCredentials} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} />
      {retrievedCredentials && (
        <Text>
          Retrieved: {retrievedCredentials.username} / {retrievedCredentials.password}
        </Text>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves a user's credentials using React Native Keychain. The credentials are stored in the native keychain services on iOS and the Keystore system on Android.

### Example 2: Implementing Secure Storage with React Native Sensitive Info

React Native Sensitive Info is another library that provides secure storage for sensitive data. It uses the native Keychain on iOS and the Keystore on Android to store key/value pairs securely. This library is suitable for storing sensitive information such as API keys, tokens, and other confidential data.

To use React Native Sensitive Info, you need to install the library, configure it in your React Native project, and use its API to store and retrieve data securely. This example demonstrates how to store and retrieve sensitive information using React Native Sensitive Info.

#### Online Resources
1. [React Native Sensitive Info GitHub](https://github.com/mCodex/react-native-sensitive-info)
2. [Secure Storage in React Native using Sensitive Info](https://medium.com/@ankitvijay009/secure-storage-in-react-native-1bd7b8bf3d0d)

#### Code to Practice

```bash
# Install React Native Sensitive Info
npm install react-native-sensitive-info

# Link the library (for React Native <= 0.59)
react-native link react-native-sensitive-info

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import SInfo from 'react-native-sensitive-info';

const App = () => {
  const [data, setData] = useState('');
  const [retrievedData, setRetrievedData] = useState('');

  const storeData = async () => {
    await SInfo.setItem('secureData', data, {
      sharedPreferencesName: 'mySharedPrefs',
      keychainService: 'myKeychain',
    });
    alert('Data stored securely!');
  };

  const retrieveData = async () => {
    const result = await SInfo.getItem('secureData', {
      sharedPreferencesName: 'mySharedPrefs',
      keychainService: 'myKeychain',
    });
    setRetrievedData(result);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter data"
        value={data}
        onChangeText={setData}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} />
      {retrievedData ? <Text>Retrieved: {retrievedData}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves sensitive information using React Native Sensitive Info. The data is stored in the native Keychain on iOS and the Keystore on Android.

### Example 3: Combining AsyncStorage with Encryption for Secure Data Storage

AsyncStorage is a simple, unencrypted, asynchronous, persistent, key-value storage system that is global to the app. To enhance security, you can combine AsyncStorage with encryption to store data securely. This involves using a library such as `react-native-encrypted-storage` to encrypt data before storing it in AsyncStorage.

To use encrypted storage, you need to install the necessary libraries, configure them in your React Native project, and use their APIs to securely store and retrieve encrypted data. This example demonstrates how to encrypt and store data using `react-native-encrypted-storage`.

#### Online Resources
1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/)
2. [React Native Encrypted Storage GitHub](https://github.com/emeraldsanto/react-native-encrypted-storage)

#### Code to Practice

```bash
# Install AsyncStorage and Encrypted Storage
npm install @react-native-async-storage/async-storage react-native-encrypted-storage

# Link the library (for React Native <= 0.59)
react-native link @react-native-async-storage/async-storage
react-native link react-native-encrypted-storage

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import EncryptedStorage from 'react-native-encrypted-storage';

const App = () => {
  const [data, setData] = useState('');
  const [retrievedData, setRetrievedData] = useState('');

  const storeData = async () => {
    await EncryptedStorage.setItem('secureData', data);
    alert('Data stored securely!');
  };

  const retrieveData = async () => {
    const result = await EncryptedStorage.getItem('secureData');
    setRetrievedData(result);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter data"
        value={data}
        onChangeText={setData}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title

="Retrieve Data" onPress={retrieveData} />
      {retrievedData ? <Text>Retrieved: {retrievedData}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves encrypted data using Encrypted Storage combined with AsyncStorage. The data is encrypted before storage, ensuring secure data storage and retrieval.

---

### Task 16: Implement Secure Storage with SecureStore

Secure storage is critical in mobile applications to protect sensitive data such as authentication tokens, user credentials, and other personal information. SecureStore is a library provided by Expo that allows you to securely store key-value pairs in a way that is encrypted and protected by the underlying operating system's secure storage mechanisms. It is designed to work seamlessly with both iOS and Android, utilizing Keychain Services on iOS and the Keystore system on Android.

Using SecureStore in a React Native application involves installing the Expo SecureStore library, configuring it in your project, and utilizing its API to store and retrieve data securely. By implementing SecureStore, developers can enhance the security of their applications, ensuring that sensitive information is protected from unauthorized access and potential breaches.

#### Online Resources
1. [Expo SecureStore Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
2. [Storing Secure Data in React Native](https://blog.expo.dev/how-to-store-secure-data-in-expo-and-react-native-apps-c3cb35cf5e53)

#### Examples to Practice

1. **Storing and Retrieving Basic Data with SecureStore**
2. **Handling User Authentication Tokens with SecureStore**
3. **Implementing SecureStore in a Real-World Scenario**

### Example 1: Storing and Retrieving Basic Data with SecureStore

Storing and retrieving basic data using SecureStore involves using the `setItemAsync` and `getItemAsync` methods provided by the SecureStore API. These methods allow you to securely store and retrieve key-value pairs in your React Native application.

To practice this, you will create a simple application that stores a user's name securely and retrieves it when needed. This example will help you understand the basic usage of SecureStore in a React Native project.

#### Online Resources
1. [SecureStore Expo Documentation](https://docs.expo.dev/versions/latest/sdk/securestore/)
2. [React Native Secure Storage](https://www.digitalocean.com/community/tutorials/react-native-secure-storage)

#### Code to Practice

```bash
# Install Expo SecureStore
expo install expo-secure-store

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [name, setName] = useState('');
  const [storedName, setStoredName] = useState('');

  const saveName = async () => {
    await SecureStore.setItemAsync('userName', name);
    alert('Name saved successfully!');
  };

  const getName = async () => {
    const result = await SecureStore.getItemAsync('userName');
    setStoredName(result);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter your name"
        value={name}
        onChangeText={setName}
      />
      <Button title="Save Name" onPress={saveName} />
      <Button title="Get Name" onPress={getName} />
      {storedName ? <Text>Retrieved: {storedName}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves a user's name using Expo SecureStore. The user's name is saved securely and can be retrieved and displayed when needed.

### Example 2: Handling User Authentication Tokens with SecureStore

Storing user authentication tokens securely is a common requirement in mobile applications. SecureStore can be used to securely store these tokens, ensuring that they are protected from unauthorized access. This example demonstrates how to store and retrieve an authentication token using SecureStore.

To practice this, you will create an application that stores a user's authentication token securely and retrieves it to simulate a secure login process. This example helps you understand how to handle sensitive information such as tokens securely in a React Native project.

#### Online Resources
1. [Managing Authentication Tokens in React Native](https://dev.to/bespoyasov/secure-authentication-tokens-in-react-native-2p3n)
2. [Secure Token Storage with SecureStore](https://docs.expo.dev/versions/latest/sdk/securestore/)

#### Code to Practice

```bash
# Install Expo SecureStore
expo install expo-secure-store

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [token, setToken] = useState('');
  const [retrievedToken, setRetrievedToken] = useState('');

  const saveToken = async () => {
    await SecureStore.setItemAsync('authToken', token);
    alert('Token saved successfully!');
  };

  const getToken = async () => {
    const result = await SecureStore.getItemAsync('authToken');
    setRetrievedToken(result);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter authentication token"
        value={token}
        onChangeText={setToken}
      />
      <Button title="Save Token" onPress={saveToken} />
      <Button title="Get Token" onPress={getToken} />
      {retrievedToken ? <Text>Retrieved Token: {retrievedToken}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves an authentication token using Expo SecureStore. The token is saved securely and can be retrieved and displayed when needed.

### Example 3: Implementing SecureStore in a Real-World Scenario

Implementing SecureStore in a real-world scenario involves integrating secure storage into your application's authentication flow. This includes storing user credentials or tokens upon login and retrieving them during subsequent app launches to maintain the user's session securely. This example demonstrates how to integrate SecureStore into a real-world authentication flow.

To practice this, you will create an application that simulates a login process, storing the user's credentials securely using SecureStore and retrieving them to maintain the user's session. This example helps you understand how to use SecureStore in a practical, real-world scenario.

#### Online Resources
1. [Expo SecureStore in Authentication Flows](https://blog.expo.dev/how-to-store-secure-data-in-expo-and-react-native-apps-c3cb35cf5e53)
2. [Secure User Authentication in React Native](https://www.smashingmagazine.com/2020/10/secure-user-authentication-graphql-react-native/)

#### Code to Practice

```bash
# Install Expo SecureStore
expo install expo-secure-store

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import * as SecureStore from 'expo-secure-store';

const App = () => {
  const [username, setUsername] = useState('');
  const [password, setPassword] = useState('');
  const [retrievedUsername, setRetrievedUsername] = useState('');

  const login = async () => {
    // Simulate login and store credentials securely
    await SecureStore.setItemAsync('username', username);
    await SecureStore.setItemAsync('password', password);
    alert('Logged in and credentials stored securely!');
  };

  const retrieveCredentials = async () => {
    const storedUsername = await SecureStore.getItemAsync('username');
    const storedPassword = await SecureStore.getItemAsync('password');

    if (storedUsername && storedPassword) {
      setRetrievedUsername(storedUsername);
      alert('Credentials retrieved successfully!');
    } else {
      alert('No credentials stored');
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Username"
        value={username}
        onChangeText={setUsername}
      />
      <TextInput
        style={styles.input}
        placeholder="Password"
        value={password}
        onChangeText={setPassword}
        secureTextEntry
      />
      <Button title="Login" onPress={login} />
      <Button title="Retrieve Credentials" onPress={retrieveCredentials} />
      {retrievedUsername ? <Text>Logged in as: {retrievedUsername}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves user credentials using Expo SecureStore. The credentials are saved securely upon login and can be retrieved to maintain the user's session during subsequent app launches.

---

### Task 17: Study Data Encryption Techniques

Data encryption is a crucial technique in mobile application development to protect sensitive data from unauthorized access. Encryption transforms data into a format that can only be read by someone who has the decryption key. This ensures that even if data is intercepted or accessed by malicious entities, it cannot be read without the proper key. There are two main types of encryption: symmetric encryption, where the same key is used for both encryption and decryption, and asymmetric encryption, where a pair of keys (public and private) is used.

In the context of React Native development, implementing data encryption helps secure sensitive information such as user credentials, tokens, and personal data. Several libraries and tools are available to help developers encrypt data effectively, such as `react-native-crypto` and `react-native-encrypted-storage`. By leveraging these tools, developers can ensure that their applications adhere to security best practices and protect user data from potential breaches.

#### Online Resources
1. [Understanding Data Encryption](https://www.cloudflare.com/learning/ssl/what-is-encryption/)
2. [Implementing Encryption in React Native](https://medium.com/swlh/implementing-encryption-in-react-native-3e7ef90ae3ae)

#### Examples to Practice

1. **Encrypting and Decrypting Data with react-native-crypto**
2. **Using AES Encryption in React Native**
3. **Combining AsyncStorage with Encryption for Secure Data Storage**

### Example 1: Encrypting and Decrypting Data with react-native-crypto

The `react-native-crypto` library provides cryptographic functionality for React Native applications. It allows developers to perform encryption and decryption operations using various algorithms. This example demonstrates how to use `react-native-crypto` to encrypt and decrypt a string using a symmetric encryption algorithm.

#### Online Resources
1. [react-native-crypto GitHub](https://github.com/mvayngrib/react-native-crypto)
2. [Crypto in React Native](https://blog.bitsrc.io/crypto-in-react-native-apps-1d682dcd16d4)

#### Code to Practice

```bash
# Install react-native-crypto and required dependencies
npm install react-native-crypto react-native-randombytes
npm install --save-dev rn-nodeify
# Run the following to configure crypto
rn-nodeify --install crypto --hack

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import crypto from 'crypto';

const App = () => {
  const [data, setData] = useState('');
  const [encryptedData, setEncryptedData] = useState('');
  const [decryptedData, setDecryptedData] = useState('');

  const encryptData = () => {
    const cipher = crypto.createCipher('aes-256-cbc', 'password');
    let encrypted = cipher.update(data, 'utf8', 'hex');
    encrypted += cipher.final('hex');
    setEncryptedData(encrypted);
  };

  const decryptData = () => {
    const decipher = crypto.createDecipher('aes-256-cbc', 'password');
    let decrypted = decipher.update(encryptedData, 'hex', 'utf8');
    decrypted += decipher.final('utf8');
    setDecryptedData(decrypted);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter data to encrypt"
        value={data}
        onChangeText={setData}
      />
      <Button title="Encrypt Data" onPress={encryptData} />
      {encryptedData ? <Text>Encrypted: {encryptedData}</Text> : null}
      <Button title="Decrypt Data" onPress={decryptData} />
      {decryptedData ? <Text>Decrypted: {decryptedData}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that encrypts and decrypts data using the `react-native-crypto` library. The user can input a string, encrypt it, and then decrypt it to see the original data.

### Example 2: Using AES Encryption in React Native

AES (Advanced Encryption Standard) is a widely used symmetric encryption algorithm that is known for its efficiency and security. This example demonstrates how to use AES encryption in a React Native application using the `react-native-aes-crypto` library.

#### Online Resources
1. [AES Encryption Basics](https://www.techtarget.com/searchsecurity/definition/Advanced-Encryption-Standard)
2. [react-native-aes-crypto GitHub](https://github.com/tectiv3/react-native-aes)

#### Code to Practice

```bash
# Install react-native-aes-crypto
npm install react-native-aes-crypto

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import AES from 'react-native-aes-crypto';

const App = () => {
  const [data, setData] = useState('');
  const [encryptedData, setEncryptedData] = useState('');
  const [decryptedData, setDecryptedData] = useState('');

  const encryptData = async () => {
    try {
      const key = await AES.generateKey('password', 128);
      const iv = await AES.generateRandomIV();
      const encrypted = await AES.encrypt(data, key, iv);
      setEncryptedData(encrypted);
    } catch (e) {
      console.error(e);
    }
  };

  const decryptData = async () => {
    try {
      const key = await AES.generateKey('password', 128);
      const iv = await AES.generateRandomIV();
      const decrypted = await AES.decrypt(encryptedData, key, iv);
      setDecryptedData(decrypted);
    } catch (e) {
      console.error(e);
    }
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter data to encrypt"
        value={data}
        onChangeText={setData}
      />
      <Button title="Encrypt Data" onPress={encryptData} />
      {encryptedData ? <Text>Encrypted: {encryptedData}</Text> : null}
      <Button title="Decrypt Data" onPress={decryptData} />
      {decryptedData ? <Text>Decrypted: {decryptedData}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that encrypts and decrypts data using AES encryption with the `react-native-aes-crypto` library. The user can input a string, encrypt it, and then decrypt it to see the original data.

### Example 3: Combining AsyncStorage with Encryption for Secure Data Storage

Combining AsyncStorage with encryption allows you to securely store sensitive data locally in your React Native application. This approach involves encrypting the data before storing it in AsyncStorage and decrypting it when retrieving it. This example demonstrates how to use `react-native-encrypted-storage` to achieve secure data storage.

#### Online Resources
1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/)
2. [react-native-encrypted-storage GitHub](https://github.com/emeraldsanto/react-native-encrypted-storage)

#### Code to Practice

```bash
# Install AsyncStorage and Encrypted Storage
npm install @react-native-async-storage/async-storage react-native-encrypted-storage

# Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import EncryptedStorage from 'react-native-encrypted-storage';

const App = () => {
  const [data, setData] = useState('');
  const [retrievedData, setRetrievedData] = useState('');

  const storeData = async () => {
    await EncryptedStorage.setItem('secureData', data);
    alert('Data stored securely!');
  };

  const retrieveData = async () => {
    const result = await EncryptedStorage.getItem('secureData');
    setRetrievedData(result);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter data"
        value={data}
        onChangeText={setData}
      />
      <Button title="Store Data" onPress={storeData} />
      <Button title="Retrieve Data" onPress={retrieveData} />
      {retrievedData ? <Text>Retrieved: {retrievedData}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',


  },
});

export default App;
```

**Expected Output:**

A React Native application that securely stores and retrieves encrypted data using `react-native-encrypted-storage` combined with AsyncStorage. The data is encrypted before storage, ensuring secure data storage and retrieval.

---

### Task 18: Implement End-to-End Encryption with Web Crypto API

End-to-end encryption (E2EE) ensures that data is encrypted on the sender's side and can only be decrypted by the intended recipient. This means that even if the data is intercepted during transmission, it cannot be read without the appropriate decryption key. E2EE is crucial for protecting sensitive data in communication applications, such as messaging services, where confidentiality and privacy are paramount.

The Web Crypto API provides a standard interface for performing cryptographic operations in web applications, including encryption, decryption, and key management. By leveraging the Web Crypto API in a React Native application, developers can implement robust E2EE, ensuring that data remains secure from the moment it is sent until it is received and decrypted by the intended recipient.

#### Online Resources
1. [Web Crypto API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/Web_Crypto_API)
2. [End-to-End Encryption Explained](https://www.cloudflare.com/learning/ssl/what-is-end-to-end-encryption/)

#### Examples to Practice

1. **Generating and Storing Encryption Keys**
2. **Encrypting and Decrypting Messages**
3. **Implementing E2EE in a Chat Application**

### Example 1: Generating and Storing Encryption Keys

Generating and securely storing encryption keys is the first step in implementing end-to-end encryption. The Web Crypto API provides methods for generating cryptographic keys and storing them securely. This example demonstrates how to generate a pair of public and private keys and store them for later use.

#### Online Resources
1. [Key Generation with Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/generateKey)
2. [Understanding Public Key Cryptography](https://www.cloudflare.com/learning/ssl/how-does-public-key-encryption-work/)

#### Code to Practice

```javascript
// Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const App = () => {
  const [publicKey, setPublicKey] = useState('');
  const [privateKey, setPrivateKey] = useState('');

  const generateKeys = async () => {
    const keyPair = await window.crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      true,
      ['encrypt', 'decrypt']
    );

    const publicKey = await window.crypto.subtle.exportKey('spki', keyPair.publicKey);
    const privateKey = await window.crypto.subtle.exportKey('pkcs8', keyPair.privateKey);

    setPublicKey(publicKey);
    setPrivateKey(privateKey);

    console.log('Public Key:', publicKey);
    console.log('Private Key:', privateKey);
  };

  return (
    <View style={styles.container}>
      <Button title="Generate Keys" onPress={generateKeys} />
      <Text>Public Key: {publicKey ? 'Generated' : 'Not Generated'}</Text>
      <Text>Private Key: {privateKey ? 'Generated' : 'Not Generated'}</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application that generates a pair of RSA keys using the Web Crypto API. The public and private keys are generated and stored in the state, with a message indicating whether the keys have been generated.

### Example 2: Encrypting and Decrypting Messages

Encrypting and decrypting messages using the generated keys is the next step in implementing E2EE. The Web Crypto API provides methods for encrypting and decrypting data using the generated keys. This example demonstrates how to encrypt a message with the public key and decrypt it with the private key.

#### Online Resources
1. [Encrypting and Decrypting Data with Web Crypto API](https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt)
2. [Public Key Encryption Overview](https://www.techtarget.com/searchsecurity/definition/public-key-encryption)

#### Code to Practice

```javascript
// Example App setup (App.js)
import React, { useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';

const App = () => {
  const [publicKey, setPublicKey] = useState(null);
  const [privateKey, setPrivateKey] = useState(null);
  const [message, setMessage] = useState('');
  const [encryptedMessage, setEncryptedMessage] = useState('');
  const [decryptedMessage, setDecryptedMessage] = useState('');

  const generateKeys = async () => {
    const keyPair = await window.crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      true,
      ['encrypt', 'decrypt']
    );

    setPublicKey(keyPair.publicKey);
    setPrivateKey(keyPair.privateKey);
  };

  const encryptMessage = async () => {
    const encodedMessage = new TextEncoder().encode(message);
    const encrypted = await window.crypto.subtle.encrypt(
      { name: 'RSA-OAEP' },
      publicKey,
      encodedMessage
    );
    setEncryptedMessage(encrypted);
  };

  const decryptMessage = async () => {
    const decrypted = await window.crypto.subtle.decrypt(
      { name: 'RSA-OAEP' },
      privateKey,
      encryptedMessage
    );
    const decodedMessage = new TextDecoder().decode(decrypted);
    setDecryptedMessage(decodedMessage);
  };

  return (
    <View style={styles.container}>
      <Button title="Generate Keys" onPress={generateKeys} />
      <TextInput
        style={styles.input}
        placeholder="Enter message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Encrypt Message" onPress={encryptMessage} />
      {encryptedMessage ? <Text>Encrypted: {encryptedMessage}</Text> : null}
      <Button title="Decrypt Message" onPress={decryptMessage} />
      {decryptedMessage ? <Text>Decrypted: {decryptedMessage}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that encrypts a message using the public key and decrypts it using the private key. The user can input a message, encrypt it, and then decrypt it to see the original message.

### Example 3: Implementing E2EE in a Chat Application

Implementing E2EE in a chat application involves encrypting messages before they are sent and decrypting them upon receipt. This ensures that only the intended recipient can read the messages, providing secure communication. This example demonstrates how to implement E2EE in a simple chat application using the Web Crypto API.

#### Online Resources
1. [Building Secure Chat Applications](https://www.okta.com/blog/2019/03/build-secure-chat-app/)
2. [End-to-End Encryption in Messaging Apps](https://www.twilio.com/blog/end-to-end-encryption-messaging-apps)

#### Code to Practice

```javascript
// Example App setup (App.js)
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';

const App = () => {
  const [publicKey, setPublicKey] = useState(null);
  const [privateKey, setPrivateKey] = useState(null);
  const [message, setMessage] = useState('');
  const [encryptedMessage, setEncryptedMessage] = useState('');
  const [decryptedMessage, setDecryptedMessage] = useState('');
  const [messages, setMessages] = useState([]);

  useEffect(() => {
    generateKeys();
  }, []);

  const generateKeys = async () => {
    const keyPair = await window.crypto.subtle.generateKey(
      {
        name: 'RSA-OAEP',
        modulusLength: 2048,
        publicExponent: new Uint8Array([1, 0, 1]),
        hash: 'SHA-256',
      },
      true,
      ['encrypt', 'decrypt']
    );

    setPublicKey(keyPair.publicKey);
    setPrivateKey(keyPair.privateKey);
  };

  const encryptMessage = async () => {
    const encodedMessage = new TextEncoder().encode(message);
    const encrypted = await window.crypto.subtle.encrypt(
      { name: 'RSA-OAEP' },
      publicKey,
      encodedMessage
    );
    setEncryptedMessage(encrypted);
    setMessages([...messages, { type: 'sent', text: message }]);
    setMessage('');
  };

  const decryptMessage = async (encryptedMsg) => {
    const decrypted = await window.crypto.subtle.decrypt(
      { name: 'RSA-OAEP' },
      privateKey,
      encryptedMsg
    );
    const decodedMessage = new TextDecoder().decode(decrypted);
    setDecrypted

Message(decodedMessage);
    setMessages([...messages, { type: 'received', text: decodedMessage }]);
  };

  return (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Enter message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Encrypt and Send Message" onPress={encryptMessage} />
      <FlatList
        data={messages}
        renderItem={({ item }) => (
          <Text style={item.type === 'sent' ? styles.sentMessage : styles.receivedMessage}>
            {item.text}
          </Text>
        )}
        keyExtractor={(item, index) => index.toString()}
      />
      <Button title="Decrypt Last Received Message" onPress={() => decryptMessage(encryptedMessage)} />
      {decryptedMessage ? <Text>Decrypted: {decryptedMessage}</Text> : null}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
  sentMessage: {
    textAlign: 'right',
    color: 'blue',
    marginBottom: 8,
  },
  receivedMessage: {
    textAlign: 'left',
    color: 'green',
    marginBottom: 8,
  },
});

export default App;
```

**Expected Output:**

A simple chat application with end-to-end encryption. Users can send and receive messages securely, with messages being encrypted before sending and decrypted upon receipt.

---

### Task 19: Study Real-Time Communication Techniques

Real-time communication (RTC) is essential in modern mobile applications to provide seamless and instant interactions between users. RTC techniques enable applications to send and receive data with minimal delay, making them ideal for use cases such as messaging, video conferencing, and collaborative work. The key to effective real-time communication lies in low latency, high reliability, and efficient data transfer mechanisms.

Several technologies facilitate RTC in mobile applications, including WebSockets, WebRTC, and MQTT. WebSockets provide a full-duplex communication channel over a single TCP connection, enabling low-latency and real-time data exchange. WebRTC offers peer-to-peer communication capabilities for audio, video, and data sharing directly between browsers or applications. MQTT is a lightweight messaging protocol optimized for low-bandwidth, high-latency networks, commonly used in IoT applications.

#### Online Resources
1. [Real-Time Communication with WebSockets](https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API)
2. [Understanding WebRTC](https://webrtc.org/)

#### Examples to Practice

1. **Implementing Real-Time Chat with WebSockets**
2. **Building a Video Call Application with WebRTC**
3. **Real-Time Data Sync with MQTT**

### Example 1: Implementing Real-Time Chat with WebSockets

WebSockets provide a persistent connection between the client and server, allowing for real-time data exchange with minimal latency. This makes them ideal for chat applications, where instant communication is crucial. By using WebSockets, you can ensure that messages are sent and received in real-time without the overhead of HTTP requests.

#### Online Resources
1. [WebSocket API Documentation](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)
2. [Building a Chat App with WebSockets](https://www.toptal.com/websockets/websocket-tutorial-real-time-node-js)

#### Code to Practice

```javascript
# Example App setup (App.js)
import React, { useState, useEffect } from 'react';
import { View, Text, TextInput, Button, FlatList, StyleSheet } from 'react-native';

const App = () => {
  const [message, setMessage] = useState('');
  const [messages, setMessages] = useState([]);
  const [socket, setSocket] = useState(null);

  useEffect(() => {
    const ws = new WebSocket('ws://example.com/socket');
    ws.onopen = () => {
      console.log('Connected to WebSocket');
    };
    ws.onmessage = (event) => {
      setMessages((prevMessages) => [...prevMessages, { text: event.data, type: 'received' }]);
    };
    ws.onerror = (error) => {
      console.log('WebSocket Error: ', error);
    };
    setSocket(ws);
    return () => ws.close();
  }, []);

  const sendMessage = () => {
    if (socket && message) {
      socket.send(message);
      setMessages((prevMessages) => [...prevMessages, { text: message, type: 'sent' }]);
      setMessage('');
    }
  };

  return (
    <View style={styles.container}>
      <FlatList
        data={messages}
        renderItem={({ item }) => (
          <Text style={item.type === 'sent' ? styles.sentMessage : styles.receivedMessage}>
            {item.text}
          </Text>
        )}
        keyExtractor={(item, index) => index.toString()}
      />
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send" onPress={sendMessage} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
  sentMessage: {
    textAlign: 'right',
    color: 'blue',
    marginBottom: 8,
  },
  receivedMessage: {
    textAlign: 'left',
    color: 'green',
    marginBottom: 8,
  },
});

export default App;
```

**Expected Output:**

A simple React Native chat application that uses WebSockets for real-time communication. Users can send and receive messages instantly, with messages appearing in the chat window as they are exchanged.

### Example 2: Building a Video Call Application with WebRTC

WebRTC (Web Real-Time Communication) enables peer-to-peer audio, video, and data sharing between browsers and mobile applications. It provides a set of APIs to capture media, establish connections, and exchange data. Using WebRTC, developers can build applications that support real-time video calling and conferencing.

#### Online Resources
1. [WebRTC Overview](https://webrtc.org/getting-started/overview)
2. [Building a Video Chat Application with WebRTC](https://www.twilio.com/docs/tutorials/walkthrough/video/node/express)

#### Code to Practice

```javascript
// Example App setup (App.js)
import React, { useEffect, useRef, useState } from 'react';
import { View, Button, StyleSheet } from 'react-native';
import { mediaDevices } from 'react-native-webrtc';

const App = () => {
  const localStreamRef = useRef(null);
  const remoteStreamRef = useRef(null);
  const [peerConnection, setPeerConnection] = useState(null);

  useEffect(() => {
    const startLocalStream = async () => {
      const stream = await mediaDevices.getUserMedia({
        video: true,
        audio: true,
      });
      localStreamRef.current.srcObject = stream;
    };

    const setupWebRTC = async () => {
      const pc = new RTCPeerConnection({
        iceServers: [{ urls: 'stun:stun.l.google.com:19302' }],
      });
      pc.onicecandidate = (event) => {
        if (event.candidate) {
          // Send the candidate to the remote peer
        }
      };
      pc.ontrack = (event) => {
        remoteStreamRef.current.srcObject = event.streams[0];
      };

      const stream = await mediaDevices.getUserMedia({ video: true, audio: true });
      stream.getTracks().forEach((track) => pc.addTrack(track, stream));
      localStreamRef.current.srcObject = stream;

      setPeerConnection(pc);
    };

    startLocalStream();
    setupWebRTC();

    return () => {
      if (peerConnection) {
        peerConnection.close();
      }
    };
  }, []);

  const createOffer = async () => {
    const offer = await peerConnection.createOffer();
    await peerConnection.setLocalDescription(offer);
    // Send the offer to the remote peer
  };

  const createAnswer = async () => {
    const answer = await peerConnection.createAnswer();
    await peerConnection.setLocalDescription(answer);
    // Send the answer to the remote peer
  };

  return (
    <View style={styles.container}>
      <video ref={localStreamRef} autoPlay playsInline style={styles.video} />
      <video ref={remoteStreamRef} autoPlay playsInline style={styles.video} />
      <Button title="Create Offer" onPress={createOffer} />
      <Button title="Create Answer" onPress={createAnswer} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  video: {
    width: '100%',
    height: 200,
    backgroundColor: 'black',
  },
});

export default App;
```

**Expected Output:**

A basic video call application using WebRTC. Users can start a local video stream and connect to a remote peer, establishing a video call with real-time audio and video communication.

### Example 3: Real-Time Data Sync with MQTT

MQTT (Message Queuing Telemetry Transport) is a lightweight messaging protocol designed for low-bandwidth, high-latency networks. It is commonly used in IoT applications for real-time data synchronization. This example demonstrates how to use MQTT to synchronize data in a React Native application.

#### Online Resources
1. [MQTT Protocol Overview](https://mqtt.org/)
2. [Using MQTT in React Native](https://www.hivemq.com/blog/mqtt-client-library-encyclopedia-react-native/)

#### Code to Practice

```bash
# Install MQTT client library
npm install mqtt

# Example App setup (App.js)
import React, { useEffect, useState } from 'react';
import { View, Text, TextInput, Button, StyleSheet } from 'react-native';
import mqtt from 'mqtt';

const App = () => {
  const [message, setMessage] = useState('');
  const [receivedMessages, setReceivedMessages] = useState([]);
  const [client, setClient] = useState(null);

  useEffect(() => {
    const mqttClient = mqtt.connect('mqtt://broker.hivemq.com:1883');
    mqttClient.on('connect', () => {
      console.log('Connected to MQTT broker');
      mqttClient.subscribe('test/topic');
    });
    mqttClient.on('message', (topic, message) => {
      setReceivedMessages((prevMessages) => [...prevMessages, message.toString()]);
    });
    setClient(mqttClient);
    return () => mqttClient.end();
  }, []);

  const sendMessage = () => {
    if (client && message) {
      client.publish('test/topic', message);
      setMessage('');
    }
  };

  return

 (
    <View style={styles.container}>
      <TextInput
        style={styles.input}
        placeholder="Type a message"
        value={message}
        onChangeText={setMessage}
      />
      <Button title="Send" onPress={sendMessage} />
      {receivedMessages.map((msg, index) => (
        <Text key={index}>{msg}</Text>
      ))}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    padding: 16,
  },
  input: {
    borderWidth: 1,
    borderColor: '#ccc',
    padding: 8,
    marginBottom: 16,
    width: '100%',
  },
});

export default App;
```

**Expected Output:**

A React Native application that uses MQTT for real-time data synchronization. Users can send and receive messages instantly, with messages being published and subscribed to a specific topic.

---

### Task 20: Implement Real-Time Notifications with Firebase Cloud Messaging

Firebase Cloud Messaging (FCM) is a cross-platform messaging solution that allows you to send notifications and messages to users across different platforms such as iOS, Android, and web. FCM provides reliable and scalable messaging to ensure that notifications reach users promptly. It supports various message types, including notifications and data messages, which can be used to trigger actions or update the app's content silently.

Using FCM in a React Native application involves setting up Firebase, configuring the app to receive messages, and implementing the logic to handle incoming notifications. This process ensures that users receive timely updates and important information directly on their devices, enhancing user engagement and app interaction.

#### Online Resources
1. [Firebase Cloud Messaging Documentation](https://firebase.google.com/docs/cloud-messaging)
2. [React Native Firebase Messaging](https://rnfirebase.io/messaging/usage)

#### Examples to Practice

1. **Setting Up Firebase Cloud Messaging in a React Native App**
2. **Sending Notifications from the Firebase Console**
3. **Handling Incoming Messages and Notifications**

### Example 1: Setting Up Firebase Cloud Messaging in a React Native App

Setting up Firebase Cloud Messaging in a React Native app involves configuring Firebase in your project, installing the necessary packages, and setting up the FCM service. This example demonstrates how to set up FCM in a React Native application.

#### Online Resources
1. [React Native Firebase Setup](https://rnfirebase.io/)
2. [Firebase Cloud Messaging Setup](https://firebase.google.com/docs/cloud-messaging)

#### Code to Practice

```bash
# Create a new React Native project (if you don't have one)
npx react-native init MyFCMApp

# Navigate to the project directory
cd MyFCMApp

# Install Firebase and React Native Firebase packages
npm install @react-native-firebase/app @react-native-firebase/messaging

# Set up Firebase configuration
# Follow the instructions on the Firebase console to add your app
# to Firebase and download the google-services.json file for Android
# and GoogleService-Info.plist file for iOS. Place these files in
# the appropriate directories as per the documentation.

# Example App setup (App.js)
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import messaging from '@react-native-firebase/messaging';

const App = () => {
  useEffect(() => {
    // Request permissions for iOS
    messaging().requestPermission().then((authStatus) => {
      const enabled =
        authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
        authStatus === messaging.AuthorizationStatus.PROVISIONAL;

      if (enabled) {
        console.log('Authorization status:', authStatus);
      }
    });

    // Get the device token
    messaging()
      .getToken()
      .then((token) => {
        console.log('FCM Token:', token);
      });

    // Listen to whether the token changes
    return messaging().onTokenRefresh((token) => {
      console.log('FCM Token refreshed:', token);
    });
  }, []);

  return (
    <View style={styles.container}>
      <Text>FCM Setup Complete</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application with Firebase Cloud Messaging set up, requesting permissions, and retrieving the FCM token for the device. The token can be used to send notifications to this device.

### Example 2: Sending Notifications from the Firebase Console

Once FCM is set up in your React Native app, you can send notifications from the Firebase Console to test the setup. This example demonstrates how to send a notification to your app using the Firebase Console.

#### Online Resources
1. [Sending Messages with Firebase Console](https://firebase.google.com/docs/cloud-messaging/send-message)
2. [Firebase Notifications Console Guide](https://firebase.google.com/docs/notifications/console)

#### Code to Practice

1. **Step 1: Open the Firebase Console**
   - Navigate to the Firebase Console and select your project.

2. **Step 2: Create a New Notification**
   - Go to the Cloud Messaging section and click on "Send your first message".
   - Enter a notification title and message body.

3. **Step 3: Target Your App**
   - Choose "Single Device" and enter the FCM token retrieved from your app.
   - Click "Send Message" to deliver the notification.

**Expected Output:**

Your React Native application should receive the notification and display it in the notification tray. The notification will appear with the title and body you entered in the Firebase Console.

### Example 3: Handling Incoming Messages and Notifications

Handling incoming messages and notifications involves setting up listeners to handle foreground and background messages, as well as notifications received while the app is in the foreground. This example demonstrates how to handle incoming FCM messages in your React Native application.

#### Online Resources
1. [React Native Firebase Messaging](https://rnfirebase.io/messaging/usage#background--quit-state-messages)
2. [Handling FCM Messages](https://firebase.google.com/docs/cloud-messaging/android/receive)

#### Code to Practice

```javascript
// Example App setup (App.js)
import React, { useEffect } from 'react';
import { View, Text, StyleSheet, Alert } from 'react-native';
import messaging from '@react-native-firebase/messaging';

const App = () => {
  useEffect(() => {
    // Request permissions for iOS
    messaging().requestPermission().then((authStatus) => {
      const enabled =
        authStatus === messaging.AuthorizationStatus.AUTHORIZED ||
        authStatus === messaging.AuthorizationStatus.PROVISIONAL;

      if (enabled) {
        console.log('Authorization status:', authStatus);
      }
    });

    // Get the device token
    messaging()
      .getToken()
      .then((token) => {
        console.log('FCM Token:', token);
      });

    // Listen to whether the token changes
    messaging().onTokenRefresh((token) => {
      console.log('FCM Token refreshed:', token);
    });

    // Handle foreground messages
    const unsubscribe = messaging().onMessage(async (remoteMessage) => {
      Alert.alert('A new FCM message arrived!', JSON.stringify(remoteMessage));
    });

    // Handle background and quit messages
    messaging().setBackgroundMessageHandler(async (remoteMessage) => {
      console.log('Message handled in the background!', remoteMessage);
    });

    return unsubscribe;
  }, []);

  return (
    <View style={styles.container}>
      <Text>FCM Setup Complete</Text>
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
});

export default App;
```

**Expected Output:**

A React Native application that handles incoming FCM messages. When a message is received while the app is in the foreground, an alert is displayed. Background and quit state messages are logged to the console.

---
