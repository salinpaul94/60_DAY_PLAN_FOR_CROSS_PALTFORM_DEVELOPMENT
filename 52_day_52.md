### Task 1: Study Advanced React Native Component Libraries

Studying advanced React Native component libraries is crucial for enhancing the functionality and aesthetics of your mobile applications. These libraries provide pre-built, customizable components that save development time and ensure a consistent user experience across different platforms. They also offer advanced features like animations, form handling, navigation, and theming, which are essential for creating professional and polished mobile apps. By leveraging these libraries, you can focus on building your app's core functionality without reinventing the wheel for common UI elements.

Libraries like React Native Elements, NativeBase, and React Native Paper are among the most popular in the React Native ecosystem. These libraries offer comprehensive sets of components that adhere to platform-specific design guidelines, ensuring a native look and feel. They also provide extensive documentation and community support, making it easier to integrate them into your projects. By mastering these libraries, you'll be able to rapidly prototype and develop high-quality apps that meet industry standards.

#### Resources:
1. [React Native Elements Documentation](https://reactnativeelements.com/docs/)
2. [NativeBase Documentation](https://docs.nativebase.io/)

### Examples to Practice

#### Example 1: Creating a Custom Button with React Native Elements
**Explanation:**  
React Native Elements provides a customizable button component that you can use to enhance the interactivity of your app. By leveraging the built-in styling and configuration options, you can create buttons that fit your app's theme and functionality. This example will help you understand how to use React Native Elements to create a button with custom styles and actions.

**Code:**
```jsx
import React from 'react';
import { View } from 'react-native';
import { Button } from 'react-native-elements';

export default function App() {
  return (
    <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
      <Button
        title="Press Me"
        buttonStyle={{ backgroundColor: 'blue', padding: 10 }}
        onPress={() => alert('Button Pressed!')}
      />
    </View>
  );
}
```

**Expected Output:**  
A centered button on the screen with the label "Press Me". When pressed, an alert saying "Button Pressed!" should appear.

#### Resources:
1. [React Native Elements Button Documentation](https://reactnativeelements.com/docs/button)
2. [React Native Elements GitHub Repository](https://github.com/react-native-elements/react-native-elements)

#### Example 2: Creating a Themed Form with NativeBase
**Explanation:**  
NativeBase is a library that offers a set of cross-platform components for React Native. In this example, you will create a form using NativeBase's components, including input fields, labels, and a submit button. This exercise will help you understand how to use NativeBase to manage form state and validation.

**Code:**
```jsx
import React, { useState } from 'react';
import { View } from 'react-native';
import { Container, Header, Content, Form, Item, Input, Label, Button, Text } from 'native-base';

export default function App() {
  const [form, setForm] = useState({ username: '', password: '' });

  const handleChange = (name, value) => {
    setForm({ ...form, [name]: value });
  };

  const handleSubmit = () => {
    alert(`Username: ${form.username}, Password: ${form.password}`);
  };

  return (
    <Container>
      <Header />
      <Content>
        <Form>
          <Item floatingLabel>
            <Label>Username</Label>
            <Input onChangeText={(text) => handleChange('username', text)} />
          </Item>
          <Item floatingLabel last>
            <Label>Password</Label>
            <Input secureTextEntry onChangeText={(text) => handleChange('password', text)} />
          </Item>
          <Button full onPress={handleSubmit}>
            <Text>Submit</Text>
          </Button>
        </Form>
      </Content>
    </Container>
  );
}
```

**Expected Output:**  
A form with two input fields for username and password, and a submit button. When the button is pressed, an alert showing the entered username and password should appear.

#### Resources:
1. [NativeBase Form Documentation](https://docs.nativebase.io/form)
2. [NativeBase GitHub Repository](https://github.com/GeekyAnts/NativeBase)

#### Example 3: Implementing a List with React Native Paper
**Explanation:**  
React Native Paper is a high-quality, standard-compliant Material Design library that provides a variety of components for building beautiful UIs. This example will demonstrate how to create a list using the `List.Item` component from React Native Paper. You will learn how to customize the list items and handle user interactions.

**Code:**
```jsx
import * as React from 'react';
import { View } from 'react-native';
import { List, Divider } from 'react-native-paper';

export default function App() {
  return (
    <View>
      <List.Item
        title="First Item"
        description="Item description"
        left={() => <List.Icon icon="folder" />}
        onPress={() => alert('First Item Pressed')}
      />
      <Divider />
      <List.Item
        title="Second Item"
        description="Item description"
        left={() => <List.Icon icon="folder" />}
        onPress={() => alert('Second Item Pressed')}
      />
      <Divider />
    </View>
  );
}
```

**Expected Output:**  
A list with two items, each displaying a title, description, and icon. When an item is pressed, an alert with the respective item's title should appear.

#### Resources:
1. [React Native Paper List Documentation](https://callstack.github.io/react-native-paper/list-item.html)
2. [React Native Paper GitHub Repository](https://github.com/callstack/react-native-paper)

---

### Task 2: Integrate NativeBase for UI Components

Integrating NativeBase for UI components can significantly streamline the development process in React Native by providing a rich set of cross-platform UI components that follow native design principles. NativeBase offers a variety of customizable components, such as buttons, forms, modals, and lists, which help developers create aesthetically pleasing and functional user interfaces with minimal effort. Using NativeBase, you can ensure a consistent look and feel across both iOS and Android platforms, enhancing the user experience and reducing the need for platform-specific adjustments.

NativeBase also integrates seamlessly with other libraries and tools in the React Native ecosystem, making it a versatile choice for developing complex applications. Its components are built on top of React Native's core components, ensuring compatibility and ease of integration. Moreover, NativeBase is backed by extensive documentation and a vibrant community, providing ample resources and support for developers. By mastering NativeBase, you can accelerate your development workflow and produce high-quality mobile applications more efficiently.

#### Resources:
1. [NativeBase Documentation](https://docs.nativebase.io/)
2. [NativeBase GitHub Repository](https://github.com/GeekyAnts/NativeBase)

### Examples to Practice

#### Example 1: Creating a Custom Header with NativeBase
**Explanation:**  
A well-designed header is crucial for providing navigation and context within your app. NativeBase offers a highly customizable `Header` component that allows you to add titles, icons, and buttons. This example will demonstrate how to create a header with a title and an icon button, which can be used for navigation or other actions.

**Code:**
```jsx
import React from 'react';
import { View } from 'react-native';
import { Container, Header, Left, Body, Right, Button, Icon, Title } from 'native-base';

export default function App() {
  return (
    <Container>
      <Header>
        <Left>
          <Button transparent>
            <Icon name='menu' />
          </Button>
        </Left>
        <Body>
          <Title>My App</Title>
        </Body>
        <Right>
          <Button transparent>
            <Icon name='search' />
          </Button>
        </Right>
      </Header>
      <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
        <Text>Welcome to My App</Text>
      </View>
    </Container>
  );
}
```

**Expected Output:**  
A header with a menu button on the left, a title in the center, and a search button on the right. The main content area displays a welcome message.

#### Resources:
1. [NativeBase Header Documentation](https://docs.nativebase.io/header)
2. [NativeBase Button Documentation](https://docs.nativebase.io/button)

#### Example 2: Creating a Form with Validation using NativeBase
**Explanation:**  
Forms are essential for collecting user input in mobile applications. NativeBase provides form components that can be easily styled and validated. This example will show how to create a form with input fields for username and password, including basic validation and a submit button that triggers an alert with the entered values.

**Code:**
```jsx
import React, { useState } from 'react';
import { View } from 'react-native';
import { Container, Header, Content, Form, Item, Input, Label, Button, Text } from 'native-base';

export default function App() {
  const [form, setForm] = useState({ username: '', password: '' });
  const [error, setError] = useState('');

  const handleChange = (name, value) => {
    setForm({ ...form, [name]: value });
  };

  const handleSubmit = () => {
    if (form.username === '' || form.password === '') {
      setError('Please fill out all fields.');
    } else {
      setError('');
      alert(`Username: ${form.username}, Password: ${form.password}`);
    }
  };

  return (
    <Container>
      <Header />
      <Content>
        <Form>
          <Item floatingLabel>
            <Label>Username</Label>
            <Input onChangeText={(text) => handleChange('username', text)} />
          </Item>
          <Item floatingLabel last>
            <Label>Password</Label>
            <Input secureTextEntry onChangeText={(text) => handleChange('password', text)} />
          </Item>
          {error ? <Text style={{ color: 'red', textAlign: 'center' }}>{error}</Text> : null}
          <Button full onPress={handleSubmit}>
            <Text>Submit</Text>
          </Button>
        </Form>
      </Content>
    </Container>
  );
}
```

**Expected Output:**  
A form with input fields for username and password, a validation message if fields are empty, and a submit button that shows an alert with the entered data when pressed.

#### Resources:
1. [NativeBase Form Documentation](https://docs.nativebase.io/form)
2. [NativeBase Input Documentation](https://docs.nativebase.io/input)

#### Example 3: Creating a List with Swipeable Items using NativeBase
**Explanation:**  
Lists are commonly used to display data in mobile apps, and NativeBase offers powerful list components that support swipe actions. This example will demonstrate how to create a list with swipeable items, allowing users to perform actions like delete or edit by swiping left or right on list items.

**Code:**
```jsx
import React, { useState } from 'react';
import { View } from 'react-native';
import { Container, Header, Content, List, ListItem, Text, Button, Icon, Left, Right, Body } from 'native-base';

export default function App() {
  const [items, setItems] = useState(['Item 1', 'Item 2', 'Item 3']);

  const handleDelete = (index) => {
    const newItems = [...items];
    newItems.splice(index, 1);
    setItems(newItems);
  };

  return (
    <Container>
      <Header />
      <Content>
        <List>
          {items.map((item, index) => (
            <ListItem
              key={index}
              rightIcon={{
                icon: 'delete',
                style: { color: 'red' },
                onPress: () => handleDelete(index)
              }}
            >
              <Body>
                <Text>{item}</Text>
              </Body>
            </ListItem>
          ))}
        </List>
      </Content>
    </Container>
  );
}
```

**Expected Output:**  
A list of items with a delete icon on the right of each item. Swiping an item to the left reveals the delete button, which removes the item from the list when pressed.

#### Resources:
1. [NativeBase List Documentation](https://docs.nativebase.io/list)
2. [NativeBase ListItem Documentation](https://docs.nativebase.io/listitem)

---

### Task 3: Study Advanced Styling Techniques

Mastering advanced styling techniques in React Native is essential for creating visually appealing and highly responsive applications. Unlike traditional web development, React Native requires an understanding of styling that aligns with both iOS and Android platforms. Advanced styling includes the use of flexbox for layout, dynamic styling with themes, handling different screen sizes and orientations, and optimizing performance with efficient styling practices. By learning these techniques, you can ensure that your app not only looks great but also provides a seamless user experience across different devices.

Another crucial aspect of advanced styling is leveraging libraries such as Styled Components and Emotion, which allow for more modular and maintainable styles. These libraries enable you to write actual CSS to style your components and provide powerful features like theming and component-based styles. Understanding these tools and techniques will help you build scalable and maintainable codebases, making it easier to implement complex UIs and maintain a consistent design system throughout your application.

#### Resources:
1. [React Native Styling Cheatsheet](https://github.com/vhpoet/react-native-styling-cheat-sheet)
2. [Styled Components Documentation](https://styled-components.com/docs)

### Examples to Practice

#### Example 1: Creating a Responsive Layout with Flexbox
**Explanation:**  
Flexbox is a powerful layout model that allows you to design complex layouts with ease. In React Native, flexbox is used extensively to create responsive UIs that adapt to different screen sizes and orientations. This example will demonstrate how to use flexbox properties such as `flexDirection`, `justifyContent`, and `alignItems` to create a responsive layout that works well on both portrait and landscape modes.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <View style={styles.box}><Text>Box 1</Text></View>
      <View style={styles.box}><Text>Box 2</Text></View>
      <View style={styles.box}><Text>Box 3</Text></View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  box: {
    width: 100,
    height: 100,
    backgroundColor: 'lightblue',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Expected Output:**  
Three boxes aligned horizontally and centered vertically within the screen. The boxes should be evenly spaced across the width of the screen, maintaining their layout in both portrait and landscape modes.

#### Resources:
1. [React Native Flexbox Documentation](https://reactnative.dev/docs/flexbox)
2. [CSS Tricks Flexbox Guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

#### Example 2: Theming with Styled Components
**Explanation:**  
Styled Components is a library that allows you to use tagged template literals to style your React Native components. This approach helps in writing modular and reusable styles. In this example, you'll learn how to create a theme and apply it to your components using the ThemeProvider from Styled Components. This technique is particularly useful for maintaining a consistent design system across your application and easily switching between light and dark modes.

**Code:**
```jsx
import React from 'react';
import styled, { ThemeProvider } from 'styled-components/native';

const theme = {
  primaryColor: 'blue',
  secondaryColor: 'green',
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${props => props.theme.primaryColor};
`;

const Button = styled.TouchableOpacity`
  background-color: ${props => props.theme.secondaryColor};
  padding: 10px 20px;
  border-radius: 5px;
`;

const ButtonText = styled.Text`
  color: white;
  font-size: 16px;
`;

export default function App() {
  return (
    <ThemeProvider theme={theme}>
      <Container>
        <Button>
          <ButtonText>Press Me</ButtonText>
        </Button>
      </Container>
    </ThemeProvider>
  );
}
```

**Expected Output:**  
A screen with a blue background and a centered button with a green background. The button text is white, and the overall appearance follows the theme defined in the theme object.

#### Resources:
1. [Styled Components for React Native](https://styled-components.com/docs/basics#react-native)
2. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)

#### Example 3: Handling Different Screen Sizes with Responsive Styles
**Explanation:**  
Handling different screen sizes and resolutions is critical for creating responsive applications that look good on all devices. In this example, you will learn how to use the `Dimensions` API and media queries with libraries like `react-native-responsive-screen` to adjust styles based on the screen size. This ensures that your app provides an optimal viewing experience on both small and large devices.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet, Dimensions } from 'react-native';
import { widthPercentageToDP as wp, heightPercentageToDP as hp } from 'react-native-responsive-screen';

const { width, height } = Dimensions.get('window');

export default function App() {
  return (
    <View style={styles.container}>
      <Text style={styles.text}>Responsive Text</Text>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: width > 400 ? 24 : 18,
    padding: wp('5%'),
    backgroundColor: 'lightgrey',
  },
});
```

**Expected Output:**  
A centered text element that adjusts its font size and padding based on the screen width. On larger screens, the font size is larger, and the padding increases to maintain a balanced layout.

#### Resources:
1. [React Native Dimensions Documentation](https://reactnative.dev/docs/dimensions)
2. [react-native-responsive-screen](https://github.com/marudy/react-native-responsive-screen)

---

### Task 4: Implement Responsive Design with Flexbox

Responsive design is crucial in mobile app development to ensure that the app's UI adjusts seamlessly across various screen sizes and orientations. Flexbox is a powerful layout module that allows you to design complex layouts with ease. In React Native, Flexbox is the default layout model and provides a way to distribute space and align items in a container. Understanding Flexbox properties such as `flexDirection`, `justifyContent`, and `alignItems` can help you create responsive UIs that look great on both small and large screens.

Using Flexbox, you can create layouts that automatically adapt to the screen size, ensuring that your app remains usable and visually appealing regardless of the device. This is especially important in cross-platform development, where the goal is to provide a consistent user experience on both iOS and Android devices. By mastering Flexbox, you can efficiently manage layout, spacing, and alignment, which are critical for building responsive and flexible user interfaces.

#### Resources:
1. [React Native Flexbox Documentation](https://reactnative.dev/docs/flexbox)
2. [CSS Tricks Flexbox Guide](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

### Examples to Practice

#### Example 1: Basic Flexbox Layout
**Explanation:**  
This example demonstrates a basic Flexbox layout with three boxes arranged horizontally and evenly spaced. By setting the `flexDirection` to `row`, the items are placed in a row, and `justifyContent` is used to distribute the space evenly between them. This basic setup helps you understand how Flexbox can control the alignment and distribution of elements in a container.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <View style={styles.box}><Text>Box 1</Text></View>
      <View style={styles.box}><Text>Box 2</Text></View>
      <View style={styles.box}><Text>Box 3</Text></View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  box: {
    width: 100,
    height: 100,
    backgroundColor: 'lightblue',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Expected Output:**  
Three boxes aligned horizontally, centered vertically within the screen, and evenly spaced across the width of the screen.

#### Resources:
1. [React Native Layout with Flexbox](https://reactnative.dev/docs/flexbox)
2. [Flexbox Froggy - A game for learning Flexbox](https://flexboxfroggy.com/)

#### Example 2: Responsive Grid Layout
**Explanation:**  
Creating a responsive grid layout is a common requirement in mobile applications. This example shows how to create a grid of boxes that adjusts based on screen size. By using Flexbox properties like `flexWrap` and `flexBasis`, you can ensure that the grid items wrap to the next line when there isn't enough space, making the layout responsive and adaptable to different screen sizes.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      {Array.from({ length: 10 }).map((_, index) => (
        <View style={styles.box} key={index}>
          <Text>Box {index + 1}</Text>
        </View>
      ))}
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    flexDirection: 'row',
    flexWrap: 'wrap',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  box: {
    width: '45%',
    height: 100,
    margin: 5,
    backgroundColor: 'lightcoral',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Expected Output:**  
A grid of boxes that wraps to the next line when there isn't enough horizontal space, ensuring that the layout adapts to different screen widths.

#### Resources:
1. [CSS Tricks: A Complete Guide to Flexbox](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)
2. [React Native Flexbox Playground](https://yogalayout.com/playground/)

#### Example 3: Complex Layout with Nested Flexbox
**Explanation:**  
This example illustrates how to create a more complex layout using nested Flexbox containers. By nesting Flexbox containers, you can create intricate layouts that adjust dynamically. The example includes a header, a content area with two columns, and a footer, showcasing how to use nested Flexbox properties to achieve a responsive and structured layout.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <View style={styles.header}><Text>Header</Text></View>
      <View style={styles.content}>
        <View style={styles.column}><Text>Column 1</Text></View>
        <View style={styles.column}><Text>Column 2</Text></View>
      </View>
      <View style={styles.footer}><Text>Footer</Text></View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
  },
  header: {
    flex: 1,
    backgroundColor: 'skyblue',
    justifyContent: 'center',
    alignItems: 'center',
  },
  content: {
    flex: 3,
    flexDirection: 'row',
    justifyContent: 'space-around',
    alignItems: 'center',
  },
  column: {
    width: '45%',
    height: '100%',
    backgroundColor: 'lightgreen',
    justifyContent: 'center',
    alignItems: 'center',
  },
  footer: {
    flex: 1,
    backgroundColor: 'lightgrey',
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Expected Output:**  
A layout with a header at the top, two columns in the middle, and a footer at the bottom. The content area adjusts dynamically, maintaining the structure across different screen sizes.

#### Resources:
1. [Flexbox Layout on React Native Docs](https://reactnative.dev/docs/flexbox)
2. [CSS Tricks: Flexbox Tricks](https://css-tricks.com/snippets/css/a-guide-to-flexbox/)

---

### Task 5:  Study Theme Management in React Native

Theme management in React Native involves creating a consistent look and feel throughout your application by defining and applying a set of styles and colors. Effective theme management allows you to easily switch between different themes, such as light and dark modes, and ensures that your app adheres to a coherent design language. This is particularly important in mobile development, where user experience and visual consistency are critical. By leveraging theme management libraries like Styled Components, Emotion, or the built-in theming capabilities of UI libraries like React Native Paper, you can create reusable and maintainable styles that enhance the overall user experience.

Theme management also involves dynamically changing the theme based on user preferences or system settings. This requires a good understanding of context in React, as well as how to manage global state for themes. Implementing a theme switcher allows users to toggle between themes, providing a more personalized experience. With proper theme management, you can make your application visually appealing, accessible, and user-friendly, regardless of the user's device or settings.

#### Resources:
1. [Styled Components Documentation](https://styled-components.com/docs)
2. [React Native Paper Theming](https://callstack.github.io/react-native-paper/theming.html)

### Examples to Practice

#### Example 1: Implementing a Light and Dark Theme with Styled Components
**Explanation:**  
This example demonstrates how to implement a light and dark theme using Styled Components. You will create a theme provider and define two themes: light and dark. The theme provider will be used to switch between these themes dynamically. This exercise helps you understand the basics of theme management and how to apply themes to your components.

**Code:**
```jsx
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import styled, { ThemeProvider } from 'styled-components/native';

const lightTheme = {
  background: '#fff',
  color: '#000',
};

const darkTheme = {
  background: '#000',
  color: '#fff',
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${props => props.theme.background};
`;

const ThemedText = styled.Text`
  color: ${props => props.theme.color};
  font-size: 20px;
  margin-bottom: 20px;
`;

export default function App() {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeProvider theme={theme}>
      <Container>
        <ThemedText>Current Theme</ThemedText>
        <Button title="Toggle Theme" onPress={toggleTheme} />
      </Container>
    </ThemeProvider>
  );
}
```

**Expected Output:**  
A screen displaying text and a button to toggle between light and dark themes. The background and text colors change according to the selected theme.

#### Resources:
1. [Styled Components Theming](https://styled-components.com/docs/advanced#theming)
2. [React Native Theming with Styled Components](https://github.com/styled-components/styled-components/issues/1816)

#### Example 2: Using React Native Paper for Theme Management
**Explanation:**  
React Native Paper is a UI library that provides built-in theming capabilities. This example shows how to use React Native Paper's `Provider` component to implement a light and dark theme. You will create a theme context and a theme switcher to dynamically change themes. This example helps you understand how to leverage a UI library for theme management.

**Code:**
```jsx
import React, { useState, createContext, useContext } from 'react';
import { View, Button } from 'react-native';
import { Provider as PaperProvider, DefaultTheme, DarkTheme, Text } from 'react-native-paper';

const ThemeContext = createContext();

const lightTheme = {
  ...DefaultTheme,
  colors: {
    ...DefaultTheme.colors,
    primary: '#6200ee',
  },
};

const darkTheme = {
  ...DarkTheme,
  colors: {
    ...DarkTheme.colors,
    primary: '#bb86fc',
  },
};

function ThemeToggle() {
  const { toggleTheme } = useContext(ThemeContext);
  return <Button title="Toggle Theme" onPress={toggleTheme} />;
}

function ThemedText() {
  return <Text style={{ marginBottom: 20 }}>Current Theme</Text>;
}

export default function App() {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeContext.Provider value={{ toggleTheme }}>
      <PaperProvider theme={theme}>
        <View style={{ flex: 1, justifyContent: 'center', alignItems: 'center' }}>
          <ThemedText />
          <ThemeToggle />
        </View>
      </PaperProvider>
    </ThemeContext.Provider>
  );
}
```

**Expected Output:**  
A screen with text and a button to toggle between light and dark themes using React Native Paper. The text color and primary color change according to the selected theme.

#### Resources:
1. [React Native Paper Theming Documentation](https://callstack.github.io/react-native-paper/theming.html)
2. [React Native Paper GitHub Repository](https://github.com/callstack/react-native-paper)

#### Example 3: Creating a Custom Theme Context in React Native
**Explanation:**  
This example demonstrates how to create a custom theme context for managing themes in a React Native application. You will define a theme context, a provider, and a hook to use the context. This approach provides more control over theme management and can be easily integrated with other state management solutions like Redux or Context API.

**Code:**
```jsx
import React, { useState, createContext, useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const ThemeContext = createContext();

const lightTheme = {
  background: '#fff',
  color: '#000',
};

const darkTheme = {
  background: '#000',
  color: '#fff',
};

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeContext.Provider value={{ theme, toggleTheme }}>
      {children}
    </ThemeContext.Provider>
  );
};

const useTheme = () => useContext(ThemeContext);

const ThemedView = ({ children }) => {
  const { theme } = useTheme();
  return <View style={[styles.container, { backgroundColor: theme.background }]}>{children}</View>;
};

const ThemedText = ({ children }) => {
  const { theme } = useTheme();
  return <Text style={{ color: theme.color, marginBottom: 20 }}>{children}</Text>;
};

const ThemeToggleButton = () => {
  const { toggleTheme } = useTheme();
  return <Button title="Toggle Theme" onPress={toggleTheme} />;
};

export default function App() {
  return (
    <ThemeProvider>
      <ThemedView>
        <ThemedText>Current Theme</ThemedText>
        <ThemeToggleButton />
      </ThemedView>
    </ThemeProvider>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});
```

**Expected Output:**  
A screen displaying text and a button to toggle between light and dark themes. The background color and text color change according to the selected theme using a custom theme context.

#### Resources:
1. [React Context API](https://reactjs.org/docs/context.html)
2. [Theming in React Native](https://medium.com/@rossbulat/theming-in-react-native-using-context-hooks-styled-components-daf989eced4a)

---

### Task 6: Implement Theme Switching with Styled Components

Theme switching with Styled Components allows you to create a dynamic and user-friendly interface by enabling users to toggle between different visual themes, such as light and dark modes. This is achieved by using the `ThemeProvider` component from Styled Components, which allows you to define and apply themes across your entire application. By integrating theme switching, you can improve user experience by providing a visually appealing interface that adapts to user preferences or system settings.

The ability to switch themes dynamically is particularly useful in cross-platform development, where consistency across different platforms is crucial. Styled Components make it easy to manage and switch themes by encapsulating styles within components and providing a centralized way to handle theming. This not only ensures a consistent look and feel but also simplifies maintenance and scalability of your application's design system.

#### Resources:
1. [Styled Components Documentation](https://styled-components.com/docs)
2. [Theming with Styled Components](https://styled-components.com/docs/advanced#theming)

### Examples to Practice

#### Example 1: Basic Theme Switching
**Explanation:**  
In this example, you will learn how to implement a basic theme switcher using Styled Components. The application will toggle between a light and dark theme when a button is pressed. This example will help you understand the fundamentals of theme management and switching in a React Native application.

**Code:**
```jsx
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';
import styled, { ThemeProvider } from 'styled-components/native';

const lightTheme = {
  background: '#fff',
  color: '#000',
};

const darkTheme = {
  background: '#000',
  color: '#fff',
};

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${props => props.theme.background};
`;

const ThemedText = styled.Text`
  color: ${props => props.theme.color};
  font-size: 20px;
  margin-bottom: 20px;
`;

export default function App() {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeProvider theme={theme}>
      <Container>
        <ThemedText>Current Theme</ThemedText>
        <Button title="Toggle Theme" onPress={toggleTheme} />
      </Container>
    </ThemeProvider>
  );
}
```

**Expected Output:**  
A screen displaying text and a button to toggle between light and dark themes. The background and text colors change according to the selected theme.

#### Resources:
1. [Styled Components Basic Usage](https://styled-components.com/docs/basics#react-native)
2. [React Native and Styled Components](https://reactnative.dev/docs/styling#styled-components)

#### Example 2: Advanced Theme Switching with Context API
**Explanation:**  
This example demonstrates how to implement theme switching using the Context API along with Styled Components. By creating a theme context, you can manage and switch themes more efficiently across your application. This method is particularly useful for larger applications where theme state needs to be accessed by multiple components.

**Code:**
```jsx
import React, { useState, createContext, useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import styled, { ThemeProvider } from 'styled-components/native';

const lightTheme = {
  background: '#fff',
  color: '#000',
};

const darkTheme = {
  background: '#000',
  color: '#fff',
};

const ThemeContext = createContext();

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${props => props.theme.background};
`;

const ThemedText = styled.Text`
  color: ${props => props.theme.color};
  font-size: 20px;
  margin-bottom: 20px;
`;

const ThemeToggleButton = () => {
  const { toggleTheme } = useContext(ThemeContext);
  return <Button title="Toggle Theme" onPress={toggleTheme} />;
};

const ThemeProviderComponent = ({ children }) => {
  const [theme, setTheme] = useState(lightTheme);

  const toggleTheme = () => {
    setTheme(theme === lightTheme ? darkTheme : lightTheme);
  };

  return (
    <ThemeContext.Provider value={{ toggleTheme }}>
      <ThemeProvider theme={theme}>
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

export default function App() {
  return (
    <ThemeProviderComponent>
      <Container>
        <ThemedText>Current Theme</ThemedText>
        <ThemeToggleButton />
      </Container>
    </ThemeProviderComponent>
  );
}
```

**Expected Output:**  
A screen with a text and a button to toggle between light and dark themes using the Context API and Styled Components. The background color and text color change according to the selected theme.

#### Resources:
1. [React Context API](https://reactjs.org/docs/context.html)
2. [Styled Components with Context API](https://medium.com/swlh/theming-your-react-app-with-styled-components-and-context-api-1a144fca72a3)

#### Example 3: Persisting Theme with AsyncStorage
**Explanation:**  
In this example, you will learn how to persist the user's theme preference using `AsyncStorage`. This ensures that the user's selected theme is retained even after the app is closed and reopened. By combining `AsyncStorage` with theme management, you can provide a more personalized and consistent user experience.

**Code:**
```jsx
import React, { useState, useEffect, createContext, useContext } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import AsyncStorage from '@react-native-async-storage/async-storage';
import styled, { ThemeProvider } from 'styled-components/native';

const lightTheme = {
  background: '#fff',
  color: '#000',
};

const darkTheme = {
  background: '#000',
  color: '#fff',
};

const ThemeContext = createContext();

const Container = styled.View`
  flex: 1;
  justify-content: center;
  align-items: center;
  background-color: ${props => props.theme.background};
`;

const ThemedText = styled.Text`
  color: ${props => props.theme.color};
  font-size: 20px;
  margin-bottom: 20px;
`;

const ThemeToggleButton = () => {
  const { toggleTheme } = useContext(ThemeContext);
  return <Button title="Toggle Theme" onPress={toggleTheme} />;
};

const ThemeProviderComponent = ({ children }) => {
  const [theme, setTheme] = useState(lightTheme);

  useEffect(() => {
    (async () => {
      const storedTheme = await AsyncStorage.getItem('theme');
      if (storedTheme) {
        setTheme(storedTheme === 'light' ? lightTheme : darkTheme);
      }
    })();
  }, []);

  const toggleTheme = async () => {
    const newTheme = theme === lightTheme ? darkTheme : lightTheme;
    setTheme(newTheme);
    await AsyncStorage.setItem('theme', newTheme === lightTheme ? 'light' : 'dark');
  };

  return (
    <ThemeContext.Provider value={{ toggleTheme }}>
      <ThemeProvider theme={theme}>
        {children}
      </ThemeProvider>
    </ThemeContext.Provider>
  );
};

export default function App() {
  return (
    <ThemeProviderComponent>
      <Container>
        <ThemedText>Current Theme</ThemedText>
        <ThemeToggleButton />
      </Container>
    </ThemeProviderComponent>
  );
}
```

**Expected Output:**  
A screen displaying text and a button to toggle between light and dark themes, with the user's theme preference persisted across app sessions using `AsyncStorage`.

#### Resources:
1. [AsyncStorage Documentation](https://react-native-async-storage.github.io/async-storage/docs/install/)
2. [Persisting Theme in React Native](https://medium.com/@rossbulat/theming-in-react-native-using-context-hooks-styled-components-daf989eced4a)

---

### Task 7:  Study Accessibility Improvements

Accessibility in React Native involves ensuring that your mobile applications are usable by as many people as possible, including those with disabilities. This includes providing appropriate labels for screen readers, managing focus for navigable components, ensuring sufficient contrast for text and background colors, and supporting larger text sizes and alternative input methods. By improving accessibility, you can enhance the user experience for a broader audience, making your app inclusive and compliant with accessibility standards such as WCAG (Web Content Accessibility Guidelines).

React Native offers various built-in accessibility features and APIs that help developers create accessible applications. Components like `AccessibilityInfo`, `accessibilityLabel`, `accessible`, and `accessibilityRole` allow you to provide necessary information for assistive technologies. Additionally, tools and libraries such as `react-native-a11y` can assist in identifying and fixing accessibility issues. By incorporating these practices and tools, you can ensure that your app is not only functional and visually appealing but also accessible to users with diverse needs.

#### Resources:
1. [React Native Accessibility Guide](https://reactnative.dev/docs/accessibility)
2. [Web Content Accessibility Guidelines (WCAG)](https://www.w3.org/WAI/standards-guidelines/wcag/)

### Examples to Practice

#### Example 1: Adding Accessibility Labels and Roles
**Explanation:**  
In this example, you will learn how to add accessibility labels and roles to your React Native components. Accessibility labels provide screen readers with text descriptions of elements, while accessibility roles indicate the type of UI element. This helps users who rely on screen readers to understand and navigate your app.

**Code:**
```jsx
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Button
        title="Click me"
        accessibilityLabel="Click this button to perform an action"
        accessibilityRole="button"
        onPress={() => alert('Button pressed')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
```

**Expected Output:**  
A screen displaying a welcome message and a button. Screen readers will read out the accessibility labels and roles, providing a better experience for visually impaired users.

#### Resources:
1. [React Native Accessibility Props](https://reactnative.dev/docs/accessibility#accessibility-properties)
2. [Making Apps Accessible in React Native](https://medium.com/@martin_hotell/accessible-apps-in-react-native-57fdb0b1d171)

#### Example 2: Managing Focus and Accessibility Actions
**Explanation:**  
Managing focus and providing accessibility actions are crucial for users who navigate using a keyboard or screen reader. In this example, you will learn how to manage focus using the `accessible` prop and `accessibilityActions` to provide custom actions for assistive technologies.

**Code:**
```jsx
import React, { useRef } from 'react';
import { View, Text, Button, StyleSheet, AccessibilityInfo } from 'react-native';

export default function App() {
  const buttonRef = useRef(null);

  const handleFocus = () => {
    AccessibilityInfo.setAccessibilityFocus(buttonRef.current);
  };

  return (
    <View style={styles.container}>
      <Text
        accessible
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Button
        title="Focus on me"
        ref={buttonRef}
        accessibilityLabel="Click this button to focus"
        accessibilityRole="button"
        onPress={handleFocus}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
```

**Expected Output:**  
A screen with a welcome message and a button. When the button is pressed, the focus shifts to the button, which is announced by the screen reader.

#### Resources:
1. [Managing Focus in React Native](https://reactnative.dev/docs/accessibility#managing-focus)
2. [Accessibility Actions in React Native](https://reactnative.dev/docs/accessibility#accessibility-actions)

#### Example 3: Using AccessibilityInfo API
**Explanation:**  
The `AccessibilityInfo` API provides information about the screen reader status and allows you to handle accessibility events. In this example, you will learn how to use the `AccessibilityInfo` API to detect when a screen reader is enabled and adjust the UI accordingly.

**Code:**
```jsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, StyleSheet, AccessibilityInfo } from 'react-native';

export default function App() {
  const [screenReaderEnabled, setScreenReaderEnabled] = useState(false);

  useEffect(() => {
    AccessibilityInfo.isScreenReaderEnabled().then((enabled) => {
      setScreenReaderEnabled(enabled);
    });

    const subscription = AccessibilityInfo.addEventListener(
      'screenReaderChanged',
      (enabled) => {
        setScreenReaderEnabled(enabled);
      }
    );

    return () => {
      subscription.remove();
    };
  }, []);

  return (
    <View style={styles.container}>
      <Text
        accessible
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Text style={styles.text}>
        Screen reader is {screenReaderEnabled ? 'enabled' : 'disabled'}
      </Text>
      <Button
        title="Click me"
        accessibilityLabel="Click this button to perform an action"
        accessibilityRole="button"
        onPress={() => alert('Button pressed')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
```

**Expected Output:**  
A screen displaying a welcome message, a status message indicating whether the screen reader is enabled, and a button. The status message updates dynamically based on the screen reader state.

#### Resources:
1. [AccessibilityInfo API Documentation](https://reactnative.dev/docs/accessibilityinfo)
2. [Handling Accessibility Events in React Native](https://reactnative.dev/docs/accessibility#accessibility-events)

---

### Task 8: Implement Screen Reader Support

Screen readers are essential tools for users with visual impairments, enabling them to interact with applications through auditory feedback. Implementing screen reader support in React Native involves ensuring that all interactive elements are accessible and provide meaningful information to assistive technologies. This includes using accessibility props like `accessibilityLabel`, `accessibilityRole`, and `accessible` to describe elements and their actions clearly. Proper screen reader support enhances the user experience for visually impaired users, making your app more inclusive and compliant with accessibility standards.

In addition to labeling elements, managing focus and ensuring that the app is navigable using screen readers are crucial. React Native provides the `AccessibilityInfo` API to detect screen reader status and handle accessibility events. By leveraging these tools and best practices, you can create an app that is fully functional for users relying on screen readers, thereby broadening your user base and ensuring compliance with accessibility guidelines.

#### Resources:
1. [React Native Accessibility Guide](https://reactnative.dev/docs/accessibility)
2. [Apple's Accessibility Programming Guide for iOS](https://developer.apple.com/accessibility/ios/)

### Examples to Practice

#### Example 1: Basic Screen Reader Support
**Explanation:**  
In this example, you will learn how to add basic screen reader support to a React Native application. This involves using accessibility props such as `accessibilityLabel` and `accessibilityRole` to provide descriptive labels and roles for UI elements. These properties help screen readers understand and convey the purpose of each element to the user.

**Code:**
```jsx
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

export default function App() {
  return (
    <View style={styles.container}>
      <Text
        accessible
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Button
        title="Click me"
        accessibilityLabel="Click this button to perform an action"
        accessibilityRole="button"
        onPress={() => alert('Button pressed')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
```

**Expected Output:**  
A screen with a welcome message and a button. When using a screen reader, the welcome message and button are announced with their respective labels, providing context to visually impaired users.

#### Resources:
1. [React Native Accessibility Properties](https://reactnative.dev/docs/accessibility#accessibility-properties)
2. [Android Accessibility Developer Guide](https://developer.android.com/guide/topics/ui/accessibility)

#### Example 2: Custom Accessibility Actions
**Explanation:**  
Custom accessibility actions allow you to define specific actions that can be performed on a component, providing additional functionality for screen reader users. In this example, you will learn how to implement custom accessibility actions using the `accessibilityActions` prop and the `onAccessibilityAction` event handler. This can enhance the user experience by offering more interactive options tailored for accessibility.

**Code:**
```jsx
import React from 'react';
import { View, Text, Button, StyleSheet, Alert } from 'react-native';

export default function App() {
  const handleAccessibilityAction = (event) => {
    if (event.nativeEvent.actionName === 'customAction') {
      Alert.alert('Custom action performed');
    }
  };

  return (
    <View style={styles.container}>
      <Text
        accessible
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Button
        title="Click me"
        accessibilityLabel="Click this button to perform an action"
        accessibilityRole="button"
        onPress={() => alert('Button pressed')}
      />
      <View
        accessible
        accessibilityLabel="Custom action example"
        accessibilityActions={[{ name: 'customAction', label: 'Custom Action' }]}
        onAccessibilityAction={handleAccessibilityAction}
        style={styles.customAction}
      >
        <Text style={styles.text}>Perform custom action</Text>
      </View>
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
  customAction: {
    padding: 20,
    backgroundColor: 'lightgray',
    marginTop: 20,
  },
});
```

**Expected Output:**  
A screen with a welcome message, a button, and a custom action example. The custom action example provides an additional action for screen reader users, which, when performed, triggers an alert with a custom message.

#### Resources:
1. [React Native Accessibility Actions](https://reactnative.dev/docs/accessibility#accessibility-actions)
2. [W3C Accessibility Guidelines](https://www.w3.org/WAI/WCAG21/quickref/)

#### Example 3: Detecting Screen Reader Status with AccessibilityInfo
**Explanation:**  
The `AccessibilityInfo` API allows you to detect if a screen reader is enabled on the user's device and respond accordingly. In this example, you will learn how to use `AccessibilityInfo` to check the screen reader status and adjust the UI to provide a better experience for screen reader users. This can include changing layouts, providing additional instructions, or enabling/disabling certain features.

**Code:**
```jsx
import React, { useState, useEffect } from 'react';
import { View, Text, Button, StyleSheet, AccessibilityInfo } from 'react-native';

export default function App() {
  const [screenReaderEnabled, setScreenReaderEnabled] = useState(false);

  useEffect(() => {
    AccessibilityInfo.isScreenReaderEnabled().then((enabled) => {
      setScreenReaderEnabled(enabled);
    });

    const subscription = AccessibilityInfo.addEventListener(
      'screenReaderChanged',
      (enabled) => {
        setScreenReaderEnabled(enabled);
      }
    );

    return () => {
      subscription.remove();
    };
  }, []);

  return (
    <View style={styles.container}>
      <Text
        accessible
        accessibilityLabel="Welcome message"
        style={styles.text}
      >
        Welcome to the app!
      </Text>
      <Text style={styles.text}>
        Screen reader is {screenReaderEnabled ? 'enabled' : 'disabled'}
      </Text>
      <Button
        title="Click me"
        accessibilityLabel="Click this button to perform an action"
        accessibilityRole="button"
        onPress={() => alert('Button pressed')}
      />
    </View>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});
```

**Expected Output:**  
A screen displaying a welcome message, a status message indicating whether the screen reader is enabled, and a button. The status message updates dynamically based on the screen reader state.

#### Resources:
1. [AccessibilityInfo API Documentation](https://reactnative.dev/docs/accessibilityinfo)
2. [Handling Accessibility Events in React Native](https://reactnative.dev/docs/accessibility#accessibility-events)

---

### Task 9: Study Performance Optimization Techniques

Performance optimization in React Native is essential for creating smooth and responsive applications. Poor performance can lead to a negative user experience, including slow navigation, delayed response times, and unresponsive interfaces. Key performance optimization techniques in React Native include optimizing rendering, managing memory efficiently, and minimizing unnecessary re-renders. Techniques such as using `FlatList` for rendering large lists, leveraging `PureComponent` and `React.memo` to prevent unnecessary re-renders, and optimizing image loading can significantly enhance the performance of your application.

Another critical aspect of performance optimization is managing the bridge between JavaScript and native code. Overloading the bridge with too many asynchronous calls can lead to performance bottlenecks. By using techniques like batching updates, reducing the number of passes over the bridge, and using native modules effectively, you can ensure smoother performance. Additionally, profiling and monitoring tools like the React Native Performance Monitor and third-party tools such as Flipper can help identify and address performance issues in your application.

#### Resources:
1. [React Native Performance Optimization Guide](https://reactnative.dev/docs/optimizing-performance)
2. [React Native Performance Monitoring with Flipper](https://fbflipper.com/docs/features/react-native/)

### Examples to Practice

#### Example 1: Using FlatList for Efficient List Rendering
**Explanation:**  
`FlatList` is a performant interface for rendering lists in React Native, especially when dealing with large datasets. Unlike `ScrollView`, which renders all items at once, `FlatList` only renders items that are currently visible on the screen. This improves performance by reducing the memory usage and rendering workload.

**Code:**
```jsx
import React from 'react';
import { FlatList, Text, StyleSheet, View } from 'react-native';

const DATA = Array.from({ length: 1000 }, (_, i) => `Item ${i + 1}`);

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

const App = () => {
  return (
    <FlatList
      data={DATA}
      renderItem={({ item }) => <Item title={item} />}
      keyExtractor={(item, index) => index.toString()}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
});

export default App;
```

**Expected Output:**  
A list of items rendered efficiently using `FlatList`. Only the items visible on the screen are rendered initially, improving performance for large datasets.

#### Resources:
1. [React Native FlatList Documentation](https://reactnative.dev/docs/flatlist)
2. [Optimizing FlatList Configuration](https://medium.com/@houssemh/optimize-flatlist-configuration-for-large-data-in-react-native-125ec14a7457)

#### Example 2: Preventing Unnecessary Re-renders with React.memo
**Explanation:**  
`React.memo` is a higher-order component that prevents unnecessary re-renders of functional components by memoizing their output. This technique is particularly useful for optimizing performance when dealing with components that receive frequently changing props. By using `React.memo`, you can ensure that the component only re-renders when its props actually change, thus reducing the rendering workload.

**Code:**
```jsx
import React, { useState, memo } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

const ChildComponent = memo(({ count }) => {
  console.log('ChildComponent rendered');
  return <Text style={styles.text}>Count: {count}</Text>;
});

const App = () => {
  const [count, setCount] = useState(0);
  const [otherState, setOtherState] = useState(false);

  return (
    <View style={styles.container}>
      <ChildComponent count={count} />
      <Button title="Increment" onPress={() => setCount(count + 1)} />
      <Button title="Toggle" onPress={() => setOtherState(!otherState)} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  text: {
    fontSize: 20,
    marginBottom: 20,
  },
});

export default App;
```

**Expected Output:**  
A screen displaying the count and two buttons. The `ChildComponent` only re-renders when the count changes, as indicated by the console logs, demonstrating the use of `React.memo` to prevent unnecessary re-renders.

#### Resources:
1. [React.memo Documentation](https://reactjs.org/docs/react-api.html#reactmemo)
2. [Performance Optimization with React.memo](https://medium.com/@imranhsayed/performance-optimization-with-react-memo-76beedda63e9)

#### Example 3: Optimizing Image Loading with react-native-fast-image
**Explanation:**  
Loading images efficiently is crucial for maintaining good performance in mobile applications. The `react-native-fast-image` library provides a performant image component that supports caching, priority loading, and progressive loading. By using this library, you can optimize image rendering and improve the overall responsiveness of your app.

**Code:**
```jsx
import React from 'react';
import { View, StyleSheet } from 'react-native';
import FastImage from 'react-native-fast-image';

const App = () => {
  return (
    <View style={styles.container}>
      <FastImage
        style={styles.image}
        source={{
          uri: 'https://example.com/your-image.jpg',
          priority: FastImage.priority.high,
        }}
        resizeMode={FastImage.resizeMode.contain}
      />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  image: {
    width: 200,
    height: 200,
  },
});

export default App;
```

**Expected Output:**  
An image loaded using `react-native-fast-image` with caching and priority loading. The image is displayed efficiently, reducing the time and resources needed to render it.

#### Resources:
1. [react-native-fast-image Documentation](https://github.com/DylanVann/react-native-fast-image)
2. [Optimizing Image Loading in React Native](https://medium.com/@prateeksamal/optimizing-images-in-react-native-81d1a15fd0e9)

---

### Task 10: Optimize Rendering Performance with Virtualized Lists

Virtualized lists are crucial in React Native for rendering large datasets efficiently. Traditional lists render all their items at once, which can lead to performance issues like slow rendering times, high memory usage, and unresponsiveness, especially for large datasets. Virtualized lists, such as `FlatList`, `SectionList`, and `VirtualizedList`, only render items that are currently visible on the screen, along with a few items before and after the viewport. This approach minimizes memory usage and improves rendering performance by reducing the number of components that need to be managed and updated.

Using virtualized lists, you can provide a smoother user experience by ensuring that scrolling remains responsive and fluid, even when dealing with thousands of items. These components come with various performance optimization props like `initialNumToRender`, `maxToRenderPerBatch`, `windowSize`, and more, allowing fine-grained control over the rendering process. By understanding and leveraging these props, developers can significantly enhance the performance of their applications, making them more scalable and efficient.

#### Resources:
1. [React Native FlatList Documentation](https://reactnative.dev/docs/flatlist)
2. [Optimizing FlatList Configuration](https://medium.com/@houssemh/optimize-flatlist-configuration-for-large-data-in-react-native-125ec14a7457)

### Examples to Practice

#### Example 1: Basic Usage of FlatList
**Explanation:**  
In this example, you will learn how to use `FlatList` to render a simple list of items efficiently. `FlatList` is designed to handle large datasets by only rendering the visible items, plus a few additional ones to enhance scrolling performance. This example will help you understand the basic usage of `FlatList` and how to configure it for optimal performance.

**Code:**
```jsx
import React from 'react';
import { FlatList, Text, StyleSheet, View } from 'react-native';

const DATA = Array.from({ length: 1000 }, (_, i) => `Item ${i + 1}`);

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

const App = () => {
  return (
    <FlatList
      data={DATA}
      renderItem={({ item }) => <Item title={item} />}
      keyExtractor={(item, index) => index.toString()}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
});

export default App;
```

**Expected Output:**  
A list of items rendered efficiently using `FlatList`. Only the items visible on the screen are rendered initially, improving performance for large datasets.

#### Resources:
1. [React Native FlatList Documentation](https://reactnative.dev/docs/flatlist)
2. [Efficient FlatList Usage](https://medium.com/@houssemh/optimize-flatlist-configuration-for-large-data-in-react-native-125ec14a7457)

#### Example 2: Implementing a SectionList
**Explanation:**  
`SectionList` is a virtualized list component that renders items in sections, which is useful for grouped data. This example demonstrates how to implement a `SectionList` with section headers. `SectionList` improves performance by only rendering visible sections and items, making it suitable for large datasets organized into sections.

**Code:**
```jsx
import React from 'react';
import { SectionList, Text, StyleSheet, View } from 'react-native';

const DATA = [
  {
    title: "Section 1",
    data: ["Item 1-1", "Item 1-2", "Item 1-3"],
  },
  {
    title: "Section 2",
    data: ["Item 2-1", "Item 2-2", "Item 2-3"],
  },
  {
    title: "Section 3",
    data: ["Item 3-1", "Item 3-2", "Item 3-3"],
  },
];

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

const App = () => {
  return (
    <SectionList
      sections={DATA}
      keyExtractor={(item, index) => item + index}
      renderItem={({ item }) => <Item title={item} />}
      renderSectionHeader={({ section: { title } }) => (
        <Text style={styles.header}>{title}</Text>
      )}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
  header: {
    fontSize: 24,
    backgroundColor: '#fff',
    padding: 10,
  },
});

export default App;
```

**Expected Output:**  
A sectioned list with headers and items rendered efficiently using `SectionList`. Only the visible sections and items are rendered initially, improving performance.

#### Resources:
1. [React Native SectionList Documentation](https://reactnative.dev/docs/sectionlist)
2. [Optimizing SectionList](https://medium.com/@chattycode/react-native-performance-optimization-using-flatlist-and-sectionlist-53ff6b6b49a6)

#### Example 3: Optimizing FlatList with Custom Configuration
**Explanation:**  
This example demonstrates how to optimize `FlatList` by customizing its configuration for better performance. By adjusting props like `initialNumToRender`, `maxToRenderPerBatch`, `windowSize`, and `updateCellsBatchingPeriod`, you can control the rendering behavior and improve the performance of your list.

**Code:**
```jsx
import React from 'react';
import { FlatList, Text, StyleSheet, View } from 'react-native';

const DATA = Array.from({ length: 1000 }, (_, i) => `Item ${i + 1}`);

const Item = ({ title }) => (
  <View style={styles.item}>
    <Text style={styles.title}>{title}</Text>
  </View>
);

const App = () => {
  return (
    <FlatList
      data={DATA}
      renderItem={({ item }) => <Item title={item} />}
      keyExtractor={(item, index) => index.toString()}
      initialNumToRender={10}
      maxToRenderPerBatch={10}
      windowSize={5}
      updateCellsBatchingPeriod={100}
      removeClippedSubviews={true}
    />
  );
};

const styles = StyleSheet.create({
  item: {
    backgroundColor: '#f9c2ff',
    padding: 20,
    marginVertical: 8,
    marginHorizontal: 16,
  },
  title: {
    fontSize: 32,
  },
});

export default App;
```

**Expected Output:**  
A list of items rendered efficiently using `FlatList` with customized configuration. The initial number of items rendered, batch size, window size, and cell update period are optimized for better performance.

#### Resources:
1. [FlatList Optimization Techniques](https://medium.com/@houssemh/optimize-flatlist-configuration-for-large-data-in-react-native-125ec14a7457)
2. [React Native Performance Optimization](https://reactnative.dev/docs/optimizing-performance)

---

### Task 11: Study Advanced Error Handling

Advanced error handling in React Native is crucial for building robust and reliable applications. It involves not just capturing errors but also managing them in a way that ensures a smooth user experience and facilitates easier debugging. Techniques such as using `try-catch` blocks for synchronous code, handling rejected promises, and employing global error boundaries can significantly enhance your app's resilience. Additionally, integrating error tracking tools like Sentry or Bugsnag helps in monitoring, logging, and reporting errors in production, providing valuable insights into issues that users encounter.

Another important aspect of advanced error handling is gracefully recovering from errors. This includes providing user-friendly error messages, fallback UI components, and retry mechanisms for failed network requests. Proper error handling also involves distinguishing between different types of errors (e.g., network errors, API errors, and JavaScript runtime errors) and handling them appropriately. By implementing comprehensive error handling strategies, you can ensure that your application remains functional and user-friendly even when unexpected issues arise.

#### Resources:
1. [React Native Error Handling Guide](https://reactnative.dev/docs/error-boundaries)
2. [Sentry for React Native](https://docs.sentry.io/platforms/react-native/)

### Examples to Practice

#### Example 1: Using Error Boundaries
**Explanation:**  
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of crashing the entire component tree. They are essential for improving the resilience of your application. This example demonstrates how to implement an error boundary in a React Native application.

**Code:**
```jsx
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Something went wrong.</Text>
        </View>
      );
    }

    return this.props.children; 
  }
}

const BuggyComponent = () => {
  throw new Error('I crashed!');
  return <Text>This will not be displayed</Text>;
};

const App = () => {
  return (
    <ErrorBoundary>
      <View style={styles.container}>
        <Text>Click the button to see the error boundary in action:</Text>
        <Button title="Trigger Error" onPress={() => <BuggyComponent />} />
      </View>
    </ErrorBoundary>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'red',
  },
  errorText: {
    color: 'white',
    fontSize: 20,
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, triggers an error in `BuggyComponent`. The error boundary catches the error and displays a fallback UI with an error message instead of crashing the app.

#### Resources:
1. [React Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
2. [Handling Errors in React Native](https://reactnative.dev/docs/error-boundaries)

#### Example 2: Handling Promises and Async Errors
**Explanation:**  
Handling asynchronous errors is crucial in React Native applications, especially when dealing with network requests or other async operations. This example demonstrates how to use `try-catch` blocks with async functions to handle errors gracefully. It also shows how to provide user feedback when an error occurs.

**Code:**
```jsx
import React, { useState } from 'react';
import { View, Text, Button, StyleSheet, ActivityIndicator } from 'react-native';

const fetchData = async () => {
  try {
    const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    const data = await response.json();
    return data;
  } catch (error) {
    throw error;
  }
};

const App = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState(null);

  const handleFetchData = async () => {
    setLoading(true);
    setError(null);
    try {
      const result = await fetchData();
      setData(result);
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <View style={styles.container}>
      <Button title="Fetch Data" onPress={handleFetchData} />
      {loading && <ActivityIndicator size="large" color="#0000ff" />}
      {error && <Text style={styles.errorText}>{error}</Text>}
      {data && (
        <View>
          <Text>Title: {data.title}</Text>
          <Text>Body: {data.body}</Text>
        </View>
      )}
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorText: {
    color: 'red',
    marginTop: 20,
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, fetches data from an API. If the request is successful, the data is displayed; if an error occurs, an error message is shown.

#### Resources:
1. [MDN: Handling JavaScript Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
2. [React Native Networking](https://reactnative.dev/docs/network)

#### Example 3: Integrating Sentry for Error Tracking
**Explanation:**  
Sentry is a popular error tracking tool that helps monitor and fix crashes in real-time. Integrating Sentry into a React Native application allows you to capture and report errors, providing valuable insights into issues users encounter. This example demonstrates how to set up Sentry and configure it to capture errors in a React Native app.

**Code:**
1. Install Sentry:
```bash
npm install @sentry/react-native
```

2. Initialize Sentry in your app:
```jsx
import React from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({ 
  dsn: 'YOUR_SENTRY_DSN',
});

const App = () => {
  const throwError = () => {
    try {
      throw new Error('Test error for Sentry');
    } catch (error) {
      Sentry.captureException(error);
    }
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Error Tracking Example</Text>
      <Button title="Trigger Error" onPress={throwError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, triggers an error that is captured and reported to Sentry. The error can then be viewed and analyzed in the Sentry dashboard.

#### Resources:
1. [Sentry React Native Documentation](https://docs.sentry.io/platforms/react-native/)
2. [Sentry Error Monitoring](https://sentry.io/welcome/)

---

### Task 12: Implement Centralized Error Handling in Your App

Centralized error handling is a technique that allows you to manage and handle errors in a single place within your application. This approach simplifies error management, makes debugging easier, and ensures consistent error handling across your entire app. By using a centralized error handling strategy, you can log errors, display user-friendly messages, and potentially recover from errors without crashing the application. Centralized error handling can be implemented using error boundaries, global error handlers, and third-party error tracking tools like Sentry or Bugsnag.

In a React Native application, centralized error handling involves setting up a global error boundary component, managing uncaught promise rejections, and integrating with an error tracking service. Error boundaries catch rendering errors in React components, while global error handlers capture errors that occur outside of the React component lifecycle. This comprehensive approach ensures that all types of errors are caught, logged, and handled appropriately, providing a robust and user-friendly experience.

#### Resources:
1. [React Native Error Handling Guide](https://reactnative.dev/docs/error-boundaries)
2. [Sentry for React Native](https://docs.sentry.io/platforms/react-native/)

### Examples to Practice

#### Example 1: Setting Up a Global Error Boundary
**Explanation:**  
Error boundaries in React are components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI. This prevents the whole app from crashing and provides a better user experience. In this example, you will create a global error boundary component and use it to catch errors in your React Native application.

**Code:**
```jsx
import React from 'react';
import { View, Text, StyleSheet } from 'react-native';

class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error) {
    return { hasError: true };
  }

  componentDidCatch(error, errorInfo) {
    console.log(error, errorInfo);
  }

  render() {
    if (this.state.hasError) {
      return (
        <View style={styles.errorContainer}>
          <Text style={styles.errorText}>Something went wrong.</Text>
        </View>
      );
    }

    return this.props.children; 
  }
}

const BuggyComponent = () => {
  throw new Error('I crashed!');
  return <Text>This will not be displayed</Text>;
};

const App = () => {
  return (
    <ErrorBoundary>
      <View style={styles.container}>
        <Text>Click the button to see the error boundary in action:</Text>
        <Button title="Trigger Error" onPress={() => <BuggyComponent />} />
      </View>
    </ErrorBoundary>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
  errorContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    backgroundColor: 'red',
  },
  errorText: {
    color: 'white',
    fontSize: 20,
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, triggers an error in `BuggyComponent`. The error boundary catches the error and displays a fallback UI with an error message instead of crashing the app.

#### Resources:
1. [React Error Boundaries](https://reactjs.org/docs/error-boundaries.html)
2. [Handling Errors in React Native](https://reactnative.dev/docs/error-boundaries)

#### Example 2: Global Error Handler for Unhandled Rejections
**Explanation:**  
Unhandled promise rejections can occur when async functions fail without proper error handling. This example demonstrates how to set up a global error handler for unhandled promise rejections in a React Native application. By catching these errors globally, you can log them and provide fallback logic or user feedback.

**Code:**
```jsx
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet, Alert } from 'react-native';

const handleUnhandledRejections = (event) => {
  console.log('Unhandled rejection:', event.reason);
  Alert.alert('Error', 'An unexpected error occurred.');
};

const App = () => {
  useEffect(() => {
    window.addEventListener('unhandledrejection', handleUnhandledRejections);
    return () => {
      window.removeEventListener('unhandledrejection', handleUnhandledRejections);
    };
  }, []);

  const throwAsyncError = async () => {
    return Promise.reject(new Error('Async error'));
  };

  return (
    <View style={styles.container}>
      <Text>Click the button to trigger an unhandled rejection:</Text>
      <Button title="Trigger Async Error" onPress={throwAsyncError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, triggers an unhandled promise rejection. The global error handler catches the rejection and displays an alert with an error message.

#### Resources:
1. [MDN: Handling JavaScript Promises](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Using_promises)
2. [React Native Networking](https://reactnative.dev/docs/network)

#### Example 3: Integrating Sentry for Centralized Error Tracking
**Explanation:**  
Sentry is a popular error tracking tool that helps monitor and fix crashes in real-time. Integrating Sentry into a React Native application allows you to capture and report errors, providing valuable insights into issues users encounter. This example demonstrates how to set up Sentry and configure it to capture errors in a React Native app.

**Code:**
1. Install Sentry:
```bash
npm install @sentry/react-native
```

2. Initialize Sentry in your app:
```jsx
import React, { useEffect } from 'react';
import { View, Text, Button, StyleSheet } from 'react-native';
import * as Sentry from '@sentry/react-native';

Sentry.init({ 
  dsn: 'YOUR_SENTRY_DSN',
});

const App = () => {
  useEffect(() => {
    Sentry.setTag("myTag", "tagValue");
  }, []);

  const throwError = () => {
    try {
      throw new Error('Test error for Sentry');
    } catch (error) {
      Sentry.captureException(error);
    }
  };

  return (
    <View style={styles.container}>
      <Text>Sentry Error Tracking Example</Text>
      <Button title="Trigger Error" onPress={throwError} />
    </View>
  );
};

const styles = StyleSheet.create({
  container: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
  },
});

export default App;
```

**Expected Output:**  
A screen with a button that, when pressed, triggers an error that is captured and reported to Sentry. The error can then be viewed and analyzed in the Sentry dashboard.

#### Resources:
1. [Sentry React Native Documentation](https://docs.sentry.io/platforms/react-native/)
2. [Sentry Error Monitoring](https://sentry.io/welcome/)

---

### Task 13: Study Testing Strategies

Testing strategies in React Native are essential for ensuring the reliability, performance, and correctness of your application. Effective testing helps identify bugs, regressions, and potential performance issues before they reach production. The main types of tests you should consider include unit tests, integration tests, and end-to-end (E2E) tests. Unit tests focus on individual components and functions, ensuring they work as expected in isolation. Integration tests verify the interactions between different parts of the application, and E2E tests simulate real user scenarios to test the entire application workflow.

In addition to these testing types, it is crucial to use the right tools and frameworks for testing React Native applications. Popular choices include Jest for unit and integration testing, React Native Testing Library for more intuitive component testing, and Detox or Appium for E2E testing. These tools provide robust features and integrations that streamline the testing process, allowing you to write effective tests and maintain high code quality.

#### Resources:
1. [React Native Testing Library Documentation](https://callstack.github.io/react-native-testing-library/)
2. [Jest Documentation](https://jestjs.io/docs/en/getting-started)

### Examples to Practice

#### Example 1: Writing Unit Tests with Jest
**Explanation:**  
Unit tests are designed to test individual components or functions in isolation. Jest is a powerful testing framework that allows you to write and run unit tests easily. In this example, you will write a unit test for a simple function using Jest. This will help you understand the basics of Jest and how to write effective unit tests for your React Native application.

**Code:**
1. Install Jest:
```bash
npm install --save-dev jest @testing-library/react-native @testing-library/jest-native
```

2. Create a simple function and test it:
```jsx
// sum.js
export const sum = (a, b) => a + b;

// sum.test.js
import { sum } from './sum';

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

3. Add a test script to your `package.json`:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

4. Run the test:
```bash
npm test
```

**Expected Output:**  
The test should pass, confirming that the `sum` function works correctly. The output should indicate that Jest ran the test and found no errors.

#### Resources:
1. [Jest Official Documentation](https://jestjs.io/docs/en/getting-started)
2. [Testing React Native Apps with Jest](https://reactnative.dev/docs/testing-overview)

#### Example 2: Testing Components with React Native Testing Library
**Explanation:**  
React Native Testing Library is a library for testing React Native components in a way that resembles how users interact with your app. It provides utilities for rendering components and querying them based on their accessibility properties. This example demonstrates how to write tests for a simple React Native component using React Native Testing Library.

**Code:**
1. Install the necessary libraries:
```bash
npm install --save-dev @testing-library/react-native
```

2. Create a simple component and test it:
```jsx
// MyComponent.js
import React from 'react';
import { View, Text, Button } from 'react-native';

const MyComponent = ({ onPress, text }) => (
  <View>
    <Text>{text}</Text>
    <Button title="Press me" onPress={onPress} />
  </View>
);

export default MyComponent;

// MyComponent.test.js
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import MyComponent from './MyComponent';

test('it renders correctly and responds to button press', () => {
  const mockFn = jest.fn();
  const { getByText } = render(<MyComponent onPress={mockFn} text="Hello, world!" />);

  expect(getByText('Hello, world!')).toBeTruthy();
  fireEvent.press(getByText('Press me'));
  expect(mockFn).toHaveBeenCalledTimes(1);
});
```

3. Run the test:
```bash
npm test
```

**Expected Output:**  
The test should pass, confirming that the component renders correctly and the button press triggers the mock function. The output should indicate that Jest ran the test and found no errors.

#### Resources:
1. [React Native Testing Library Documentation](https://callstack.github.io/react-native-testing-library/)
2. [Testing React Native Components](https://www.smashingmagazine.com/2020/06/testing-approaches-react-native-applications/)

#### Example 3: End-to-End Testing with Detox
**Explanation:**  
End-to-end (E2E) testing simulates real user interactions with the application, testing the entire app workflow. Detox is an E2E testing framework for React Native apps that enables automated testing of your app on real devices and emulators. This example demonstrates how to set up and write E2E tests for a simple React Native app using Detox.

**Code:**
1. Install Detox and its dependencies:
```bash
npm install --save-dev detox
detox init -r jest
```

2. Configure Detox in `package.json`:
```json
{
  "scripts": {
    "test:e2e": "detox test",
    "build:e2e": "detox build"
  },
  "detox": {
    "configurations": {
      "ios.sim.debug": {
        "binaryPath": "ios/build/Build/Products/Debug-iphonesimulator/YourApp.app",
        "build": "xcodebuild -workspace ios/YourApp.xcworkspace -scheme YourApp -configuration Debug -sdk iphonesimulator -derivedDataPath ios/build",
        "type": "ios.simulator",
        "name": "iPhone 11"
      }
    }
  }
}
```

3. Create a simple test:
```jsx
// e2e/firstTest.e2e.js
describe('Example', () => {
  beforeAll(async () => {
    await device.launchApp();
  });

  it('should have welcome screen', async () => {
    await expect(element(by.id('welcome'))).toBeVisible();
  });

  it('should show hello screen after tap', async () => {
    await element(by.id('hello_button')).tap();
    await expect(element(by.text('Hello!!!'))).toBeVisible();
  });
});
```

4. Add test IDs to your components:
```jsx
// App.js
import React from 'react';
import { View, Text, Button } from 'react-native';

const App = () => {
  const [message, setMessage] = React.useState('Welcome');

  return (
    <View>
      <Text testID="welcome">{message}</Text>
      <Button
        testID="hello_button"
        title="Say Hello"
        onPress={() => setMessage('Hello!!!')}
      />
    </View>
  );
};

export default App;
```

5. Build and run the tests:
```bash
npm run build:e2e
npm run test:e2e
```

**Expected Output:**  
The tests should pass, confirming that the app displays the welcome message initially and changes the message to "Hello!!!" when the button is pressed. The output should indicate that Detox ran the tests and found no errors.

#### Resources:
1. [Detox Documentation](https://wix.github.io/Detox/docs/introduction/getting-started/)
2. [End-to-End Testing with Detox](https://medium.com/wix-engineering/end-to-end-testing-for-react-native-apps-quick-start-guide-8dd4e8d4c0b3)

---

### Task 14: Write Comprehensive Unit Tests with Jest

Unit testing is a critical part of software development that involves testing individual components or functions in isolation to ensure they work as expected. Jest is a powerful and flexible testing framework widely used in the React Native ecosystem for writing and running unit tests. It provides a robust set of features such as mocking, snapshot testing, and coverage reports, making it an excellent choice for ensuring your codebase is reliable and maintainable.

In React Native, comprehensive unit tests help catch bugs early, facilitate refactoring, and provide documentation for your code. By writing tests for different scenarios, edge cases, and error conditions, you can ensure that each component or function behaves correctly under various conditions. This leads to more stable and predictable applications, reducing the risk of issues in production.

#### Resources:
1. [Jest Documentation](https://jestjs.io/docs/en/getting-started)
2. [Testing React Native Apps with Jest](https://reactnative.dev/docs/testing-overview)

### Examples to Practice

#### Example 1: Testing a Simple Function
**Explanation:**  
This example demonstrates how to write a unit test for a simple utility function using Jest. The function `sum` adds two numbers, and the test ensures it returns the correct result. This example helps you understand the basics of writing and running unit tests with Jest.

**Code:**
1. Create the function and test:
```jsx
// sum.js
export const sum = (a, b) => a + b;

// sum.test.js
import { sum } from './sum';

test('adds 1 + 2 to equal 3', () => {
  expect(sum(1, 2)).toBe(3);
});
```

2. Add a test script to your `package.json`:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

3. Run the test:
```bash
npm test
```

**Expected Output:**  
The test should pass, confirming that the `sum` function works correctly. Jest should output the test results, indicating that it ran one test and found no errors.

#### Resources:
1. [Jest Basic Tutorial](https://jestjs.io/docs/en/getting-started)
2. [MDN: Writing Testable JavaScript](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Cross_browser_testing/Your_own_testing_server/Writing_testable_code)

#### Example 2: Testing a React Native Component
**Explanation:**  
This example shows how to write a unit test for a React Native component using Jest and React Native Testing Library. The component `MyComponent` renders a text and a button, and the test checks if they are rendered correctly and if the button press updates the text. This helps you learn how to test component behavior and interactions.

**Code:**
1. Install the necessary libraries:
```bash
npm install --save-dev @testing-library/react-native
```

2. Create the component and test:
```jsx
// MyComponent.js
import React, { useState } from 'react';
import { View, Text, Button } from 'react-native';

const MyComponent = () => {
  const [text, setText] = useState('Hello, world!');

  return (
    <View>
      <Text>{text}</Text>
      <Button title="Press me" onPress={() => setText('Button pressed!')} />
    </View>
  );
};

export default MyComponent;

// MyComponent.test.js
import React from 'react';
import { render, fireEvent } from '@testing-library/react-native';
import MyComponent from './MyComponent';

test('it renders correctly and responds to button press', () => {
  const { getByText } = render(<MyComponent />);

  expect(getByText('Hello, world!')).toBeTruthy();
  fireEvent.press(getByText('Press me'));
  expect(getByText('Button pressed!')).toBeTruthy();
});
```

3. Run the test:
```bash
npm test
```

**Expected Output:**  
The test should pass, confirming that the component renders correctly and the button press updates the text as expected. Jest should output the test results, indicating that it ran the test and found no errors.

#### Resources:
1. [React Native Testing Library Documentation](https://callstack.github.io/react-native-testing-library/)
2. [Testing React Native Components](https://www.smashingmagazine.com/2020/06/testing-approaches-react-native-applications/)

#### Example 3: Testing Asynchronous Functions
**Explanation:**  
Testing asynchronous functions can be challenging, but Jest provides tools to handle async operations effectively. This example demonstrates how to test an asynchronous function that fetches data from an API. The test mocks the API call and checks if the function returns the correct data. This helps you understand how to handle promises and async/await in your tests.

**Code:**
1. Create the async function and test:
```jsx
// fetchData.js
export const fetchData = async () => {
  const response = await fetch('https://jsonplaceholder.typicode.com/posts/1');
  const data = await response.json();
  return data;
};

// fetchData.test.js
import { fetchData } from './fetchData';

global.fetch = jest.fn(() =>
  Promise.resolve({
    json: () => Promise.resolve({ id: 1, title: 'Test Post' }),
  })
);

test('fetches data correctly', async () => {
  const data = await fetchData();
  expect(data.title).toBe('Test Post');
});
```

2. Run the test:
```bash
npm test
```

**Expected Output:**  
The test should pass, confirming that the asynchronous function fetches and returns the correct data. Jest should output the test results, indicating that it ran the test and found no errors.

#### Resources:
1. [Jest Asynchronous Testing](https://jestjs.io/docs/en/asynchronous)
2. [MDN: Using Fetch](https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch)

---

### Task 15: Study Continuous Integration Best Practices

Continuous Integration (CI) is a software development practice where developers frequently integrate their code changes into a shared repository, often several times a day. Each integration is automatically verified by automated builds and tests, allowing teams to detect problems early. The main goals of CI are to enhance software quality, reduce integration problems, and enable faster release cycles. For React Native applications, CI helps ensure that code changes do not break the app and that it works as expected across different environments.

Implementing CI best practices involves setting up a CI server, writing automated tests, and creating build scripts. Tools like GitHub Actions, CircleCI, and Travis CI are commonly used for setting up CI pipelines. These tools automate the process of building, testing, and deploying your application, providing immediate feedback on the state of your codebase. By following CI best practices, you can maintain a high level of code quality, improve collaboration among team members, and ensure a more reliable and efficient development workflow.

#### Resources:
1. [Continuous Integration (CI) - ThoughtWorks](https://www.thoughtworks.com/continuous-integration)
2. [GitHub Actions Documentation](https://docs.github.com/en/actions)

### Examples to Practice

#### Example 1: Setting Up GitHub Actions for React Native
**Explanation:**  
GitHub Actions is a powerful CI/CD tool integrated with GitHub that allows you to automate workflows directly from your GitHub repository. This example demonstrates how to set up a simple CI pipeline using GitHub Actions to build and test a React Native application. The workflow will run on every push and pull request to the `main` branch.

**Code:**
1. Create a `.github/workflows/ci.yml` file in your repository:
```yaml
name: CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:

    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Install dependencies
      run: npm install
    - name: Run tests
      run: npm test
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

**Expected Output:**  
When you push changes or create a pull request to the `main` branch, GitHub Actions will automatically run the workflow. The CI pipeline will check out the code, set up Node.js, install dependencies, and run the tests. You can view the results in the "Actions" tab of your GitHub repository.

#### Resources:
1. [GitHub Actions Documentation](https://docs.github.com/en/actions)
2. [Setting Up CI with GitHub Actions](https://reactnative.dev/docs/environment-setup#continuous-integration)

#### Example 2: Using CircleCI for React Native
**Explanation:**  
CircleCI is a popular CI/CD tool that supports automated testing and deployment. This example demonstrates how to set up CircleCI to build and test a React Native application. The configuration file specifies the steps CircleCI should follow to build the project and run tests on every commit.

**Code:**
1. Create a `.circleci/config.yml` file in your repository:
```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install
      - run:
          name: Run tests
          command: npm test

workflows:
  version: 2
  build_and_test:
    jobs:
      - build
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

**Expected Output:**  
When you push changes to the repository, CircleCI will automatically run the workflow defined in the configuration file. The CI pipeline will check out the code, set up the environment, install dependencies, and run the tests. You can view the build and test results on the CircleCI dashboard.

#### Resources:
1. [CircleCI Documentation](https://circleci.com/docs/)
2. [Setting Up CircleCI for React Native](https://circleci.com/docs/2.0/language-javascript/)

#### Example 3: Integrating Travis CI with React Native
**Explanation:**  
Travis CI is another widely used CI/CD tool that integrates with GitHub repositories. This example demonstrates how to configure Travis CI to build and test a React Native application. The configuration file defines the steps Travis CI should follow to install dependencies, run tests, and build the project.

**Code:**
1. Create a `.travis.yml` file in your repository:
```yaml
language: node_js
node_js:
  - '14'
cache: npm
install:
  - npm install
script:
  - npm test
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

**Expected Output:**  
When you push changes to the repository, Travis CI will automatically run the workflow defined in the `.travis.yml` file. The CI pipeline will set up the environment, install dependencies, and run the tests. You can view the build and test results on the Travis CI dashboard.

#### Resources:
1. [Travis CI Documentation](https://docs.travis-ci.com/)
2. [Setting Up Travis CI for React Native](https://docs.travis-ci.com/user/languages/javascript-with-nodejs/)

---

### Task 16: Set up CI Pipelines with CircleCI

Setting up Continuous Integration (CI) pipelines with CircleCI for React Native projects ensures that your code is automatically tested and built whenever changes are made. CircleCI provides powerful and flexible tools to automate the build, test, and deployment processes, which helps to maintain high code quality and accelerate development workflows. By integrating CircleCI into your React Native project, you can catch bugs early, streamline your development process, and ensure that your application performs well across different environments.

CircleCI uses configuration files to define the steps required to build and test your project. These files are typically written in YAML and include instructions for setting up the environment, installing dependencies, running tests, and other tasks. The platform supports a variety of build environments, including Docker, macOS, and Linux, making it versatile and suitable for different project needs. By leveraging CircleCI's capabilities, you can create robust CI pipelines that enhance your development workflow and ensure the reliability of your React Native applications.

#### Resources:
1. [CircleCI Documentation](https://circleci.com/docs/)
2. [Setting Up CircleCI for React Native](https://circleci.com/docs/2.0/language-javascript/)

### Examples to Practice

#### Example 1: Basic CI Pipeline Setup
**Explanation:**  
In this example, you will create a basic CI pipeline for a React Native project using CircleCI. The pipeline will check out the code from the repository, set up the Node.js environment, install dependencies, and run tests. This foundational setup ensures that your codebase is always in a testable state and that any issues are caught early.

**Code:**
1. Create a `.circleci/config.yml` file in your repository:
```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install
      - run:
          name: Run tests
          command: npm test

workflows:
  version: 2
  build_and_test:
    jobs:
      - build
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

3. Run the pipeline by pushing changes to your repository.

**Expected Output:**  
CircleCI will automatically run the pipeline on every push to the repository. It will check out the code, set up Node.js, install dependencies, and run tests. You can view the results on the CircleCI dashboard, ensuring that all tests pass before merging code changes.

#### Resources:
1. [CircleCI Getting Started Guide](https://circleci.com/docs/2.0/first-steps/)
2. [Jest Documentation](https://jestjs.io/docs/en/getting-started)

#### Example 2: Configuring Workflows for Parallel Jobs
**Explanation:**  
This example demonstrates how to configure CircleCI workflows to run jobs in parallel, which can significantly reduce build times. By splitting tasks into separate jobs and running them concurrently, you can optimize the CI process and speed up feedback loops. This setup is particularly useful for larger projects with multiple test suites or lengthy build processes.

**Code:**
1. Update your `.circleci/config.yml` file to define parallel jobs:
```yaml
version: 2.1

jobs:
  install_dependencies:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install

  run_tests:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Run tests
          command: npm test

workflows:
  version: 2
  build_and_test:
    jobs:
      - install_dependencies
      - run_tests:
          requires:
            - install_dependencies
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

3. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will run the `install_dependencies` and `run_tests` jobs in parallel, reducing the overall build time. You can view the results on the CircleCI dashboard, ensuring that dependencies are installed and tests are run efficiently.

#### Resources:
1. [CircleCI Workflows Documentation](https://circleci.com/docs/2.0/workflows/)
2. [Optimizing CI Build Times](https://circleci.com/docs/2.0/optimizations/)

#### Example 3: Adding Deployment to the CI Pipeline
**Explanation:**  
In this example, you will extend the CI pipeline to include deployment steps. After successfully building and testing the application, the pipeline will deploy the application to a staging environment. This ensures that only code that passes all tests gets deployed, enhancing the reliability of your deployments.

**Code:**
1. Update your `.circleci/config.yml` file to include a deployment job:
```yaml
version: 2.1

jobs:
  install_dependencies:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install

  run_tests:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Run tests
          command: npm test

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to staging
          command: ./deploy.sh

workflows:
  version: 2
  build_test_and_deploy:
    jobs:
      - install_dependencies
      - run_tests:
          requires:
            - install_dependencies
      - deploy:
          requires:
            - run_tests
```

2. Create a simple deployment script `deploy.sh`:
```bash
#!/bin/bash
echo "Deploying to staging environment..."
# Add your deployment commands here
```

3. Make the script executable:
```bash
chmod +x deploy.sh
```

4. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will run the `install_dependencies` and `run_tests` jobs in parallel. If all tests pass, it will then execute the `deploy` job, running the `deploy.sh` script to deploy the application. You can view the results on the CircleCI dashboard, ensuring that only tested code is deployed.

#### Resources:
1. [CircleCI Deployment Documentation](https://circleci.com/docs/2.0/deployment-integrations/)
2. [Shell Scripting Tutorial](https://www.shellscript.sh/)

---

### Task 18: Study Continuous Deployment Best Practices

Continuous Deployment (CD) is an extension of Continuous Integration (CI) where code changes are automatically deployed to a production environment once they pass the necessary tests. This practice ensures that the software is always in a deployable state, allowing for rapid and reliable releases. Implementing CD involves setting up automated pipelines that handle the entire deployment process, from building and testing to deploying the application. CD reduces the time and effort required to release new features and fixes, enhances collaboration, and ensures that the application is always up-to-date.

Best practices for continuous deployment include maintaining a robust CI pipeline, ensuring comprehensive test coverage, and setting up automated rollback mechanisms. It is crucial to use tools that support version control, monitoring, and alerting to handle any issues that might arise during deployment. Additionally, adopting a canary deployment strategy, where updates are initially rolled out to a small subset of users before a full release, can help identify potential issues without affecting the entire user base. By following these best practices, you can achieve a smooth and reliable continuous deployment process.

#### Resources:
1. [Continuous Deployment - Atlassian](https://www.atlassian.com/continuous-delivery/continuous-deployment)
2. [Continuous Delivery & DevOps - ThoughtWorks](https://www.thoughtworks.com/continuous-delivery)

### Examples to Practice

#### Example 1: Setting Up a Simple Continuous Deployment Pipeline with CircleCI
**Explanation:**  
This example demonstrates how to set up a basic continuous deployment pipeline using CircleCI. The pipeline will automatically build, test, and deploy your React Native application to a staging environment whenever changes are pushed to the main branch. This setup ensures that your application is always in a deployable state and can be released with minimal effort.

**Code:**
1. Create a `.circleci/config.yml` file in your repository:
```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install
      - run:
          name: Run tests
          command: npm test

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to staging
          command: ./deploy.sh

workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
```

2. Create a simple deployment script `deploy.sh`:
```bash
#!/bin/bash
echo "Deploying to staging environment..."
# Add your deployment commands here
```

3. Make the script executable:
```bash
chmod +x deploy.sh
```

4. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

5. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will automatically run the pipeline on every push to the main branch. It will check out the code, set up Node.js, install dependencies, run tests, and then execute the `deploy.sh` script to deploy the application to the staging environment. You can view the results on the CircleCI dashboard.

#### Resources:
1. [CircleCI Deployment Documentation](https://circleci.com/docs/2.0/deployment-integrations/)
2. [Jest Documentation](https://jestjs.io/docs/en/getting-started)

#### Example 2: Implementing Canary Deployment with AWS CodeDeploy
**Explanation:**  
Canary deployment is a strategy that gradually rolls out changes to a small subset of users before deploying to the entire user base. This example demonstrates how to set up a canary deployment using AWS CodeDeploy, ensuring that any issues are caught early without affecting all users. AWS CodeDeploy automates the deployment process and provides the tools needed to manage and monitor the deployment.

**Code:**
1. Create an `appspec.yml` file for AWS CodeDeploy:
```yaml
version: 0.0
os: linux
files:
  - source: /
    destination: /var/www/myapp
hooks:
  ApplicationStart:
    - location: scripts/start.sh
      timeout: 300
      runas: root
```

2. Create a simple start script `scripts/start.sh`:
```bash
#!/bin/bash
echo "Starting application..."
# Add commands to start your application
```

3. Make the script executable:
```bash
chmod +x scripts/start.sh
```

4. Set up AWS CodeDeploy application and deployment group:
   - Create an application in the AWS CodeDeploy console.
   - Create a deployment group with the canary deployment strategy.

5. Integrate AWS CodeDeploy into your CI pipeline:
```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install
      - run:
          name: Run tests
          command: npm test

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to AWS CodeDeploy
          command: ./scripts/deploy-to-aws.sh

workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
```

6. Create the deployment script `scripts/deploy-to-aws.sh`:
```bash
#!/bin/bash
aws deploy create-deployment \
  --application-name MyApp \
  --deployment-group-name MyDeploymentGroup \
  --s3-location bucket=my-bucket,key=my-app.zip,bundleType=zip \
  --deployment-config-name CodeDeployDefault.OneAtATime \
  --description "My deployment description"
```

**Expected Output:**  
CircleCI will automatically build, test, and deploy the application to AWS CodeDeploy using the canary deployment strategy. Only a small subset of users will receive the update initially, allowing for monitoring and rollback if issues arise. You can view deployment details in the AWS CodeDeploy console.

#### Resources:
1. [AWS CodeDeploy Documentation](https://docs.aws.amazon.com/codedeploy/)
2. [Canary Deployment Strategy](https://martinfowler.com/bliki/CanaryRelease.html)

#### Example 3: Implementing Rollback Mechanism with GitHub Actions
**Explanation:**  
A rollback mechanism is essential for quickly reverting to a previous stable state if a deployment fails. This example demonstrates how to set up a rollback mechanism using GitHub Actions. The workflow will deploy the application and automatically rollback to the previous version if any errors are detected during deployment.

**Code:**
1. Create a `.github/workflows/deploy.yml` file in your repository:
```yaml
name: Deploy

on:
  push:
    branches: [ main ]

jobs:
  deploy:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    - name: Set up Node.js
      uses: actions/setup-node@v2
      with:
        node-version: '14'
    - name: Install dependencies
      run: npm install
    - name: Run tests
      run: npm test
    - name: Deploy to production
      run: ./deploy.sh
      if: success()
    - name: Rollback on failure
      run: ./rollback.sh
      if: failure()
```

2. Create a simple deployment script `deploy.sh`:
```bash
#!/bin/bash
echo "Deploying to production..."
# Add your deployment commands here
# Simulate a failure for demonstration purposes
exit 1
```

3. Create a simple rollback script `rollback.sh`:
```bash
#!/bin/bash
echo "Rolling back to the previous version..."
# Add your rollback commands here
```

4. Make the scripts executable:
```bash
chmod +x deploy.sh rollback.sh
```

5. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

6. Push changes to your repository to trigger the workflow.

**Expected Output:**  
GitHub Actions will automatically run the workflow on every push to the main branch. It will check out the code, set up Node.js, install dependencies, run tests, deploy the application, and rollback if any errors are detected. You can view the results on the GitHub Actions dashboard.

#### Resources:
1. [GitHub Actions Documentation](https://docs.github.com/en/actions)
2. [Creating a Rollback Plan](https://www.atlassian.com/continuous-delivery/software/deployment)

---

### Task 18: Implement CD Pipelines with CircleCI

Continuous Deployment (CD) pipelines with CircleCI automate the entire process of deploying your React Native applications. By setting up a CD pipeline, you can ensure that your application is automatically deployed to a staging or production environment after passing all necessary tests. This not only reduces the manual effort required for deployment but also ensures that new features and bug fixes reach users faster and more reliably.

Setting up a CD pipeline with CircleCI involves creating a configuration file that defines the steps needed to build, test, and deploy your application. CircleCI's configuration files are written in YAML and can include various jobs that run in sequence or parallel. You can also leverage CircleCI's caching, parallelism, and environment variable features to optimize the performance and security of your deployment process.

#### Resources:
1. [CircleCI Documentation](https://circleci.com/docs/)
2. [CircleCI Configuration Reference](https://circleci.com/docs/2.0/configuration-reference/)

### Examples to Practice

#### Example 1: Basic Continuous Deployment Pipeline
**Explanation:**  
This example demonstrates how to set up a basic continuous deployment pipeline for a React Native application using CircleCI. The pipeline will build the project, run tests, and deploy the application to a staging environment. This setup ensures that only code that passes all tests gets deployed, enhancing the reliability of your deployments.

**Code:**
1. Create a `.circleci/config.yml` file in your repository:
```yaml
version: 2.1

jobs:
  build:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install
      - run:
          name: Run tests
          command: npm test

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to staging
          command: ./deploy.sh

workflows:
  version: 2
  build_and_deploy:
    jobs:
      - build
      - deploy:
          requires:
            - build
```

2. Create a simple deployment script `deploy.sh`:
```bash
#!/bin/bash
echo "Deploying to staging environment..."
# Add your deployment commands here
```

3. Make the script executable:
```bash
chmod +x deploy.sh
```

4. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

5. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will automatically run the pipeline on every push to the repository. It will check out the code, set up Node.js, install dependencies, run tests, and then execute the `deploy.sh` script to deploy the application to the staging environment. You can view the results on the CircleCI dashboard.

#### Resources:
1. [CircleCI Getting Started Guide](https://circleci.com/docs/2.0/first-steps/)
2. [Jest Documentation](https://jestjs.io/docs/en/getting-started)

#### Example 2: Setting Up a Parallel Job Pipeline
**Explanation:**  
This example demonstrates how to configure CircleCI workflows to run jobs in parallel, which can significantly reduce build times. By splitting tasks into separate jobs and running them concurrently, you can optimize the CI process and speed up feedback loops. This setup is particularly useful for larger projects with multiple test suites or lengthy build processes.

**Code:**
1. Update your `.circleci/config.yml` file to define parallel jobs:
```yaml
version: 2.1

jobs:
  install_dependencies:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install

  run_tests:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Run tests
          command: npm test

  deploy:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to staging
          command: ./deploy.sh

workflows:
  version: 2
  build_and_deploy:
    jobs:
      - install_dependencies
      - run_tests:
          requires:
            - install_dependencies
      - deploy:
          requires:
            - run_tests
```

2. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

3. Create a simple deployment script `deploy.sh`:
```bash
#!/bin/bash
echo "Deploying to staging environment..."
# Add your deployment commands here
```

4. Make the script executable:
```bash
chmod +x deploy.sh
```

5. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will run the `install_dependencies`, `run_tests`, and `deploy` jobs in parallel where appropriate, reducing the overall build time. The pipeline ensures that dependencies are installed, tests are run, and the application is deployed to the staging environment. You can view the results on the CircleCI dashboard.

#### Resources:
1. [CircleCI Workflows Documentation](https://circleci.com/docs/2.0/workflows/)
2. [Optimizing CI Build Times](https://circleci.com/docs/2.0/optimizations/)

#### Example 3: Adding Environment-Specific Deployments
**Explanation:**  
This example shows how to set up environment-specific deployments in CircleCI. The pipeline will deploy to different environments (e.g., staging and production) based on the branch that triggers the build. This allows you to maintain separate workflows for different stages of development and ensure that only stable code reaches the production environment.

**Code:**
1. Update your `.circleci/config.yml` file to include environment-specific jobs:
```yaml
version: 2.1

jobs:
  install_dependencies:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Install dependencies
          command: npm install

  run_tests:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Run tests
          command: npm test

  deploy_staging:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to staging
          command: ./deploy_staging.sh

  deploy_production:
    docker:
      - image: circleci/node:14
    steps:
      - checkout
      - run:
          name: Deploy to production
          command: ./deploy_production.sh

workflows:
  version: 2
  build_and_deploy:
    jobs:
      - install_dependencies
      - run_tests:
          requires:
            - install_dependencies
      - deploy_staging:
          requires:
            - run_tests
          filters:
            branches:
              only: [develop]
      - deploy_production:
          requires:
            - run_tests
          filters:
            branches:
              only: [main]
```

2. Create deployment scripts for staging and production:
```bash
# deploy_staging.sh
#!/bin/bash
echo "Deploying to staging environment..."
# Add your deployment commands here

# deploy_production.sh
#!/bin/bash
echo "Deploying to production environment..."
# Add your deployment commands here
```

3. Make the scripts executable:
```bash
chmod +x deploy_staging.sh deploy_production.sh
```

4. Ensure your `package.json` has a test script:
```json
{
  "scripts": {
    "test": "jest"
  }
}
```

5. Push changes to your repository to trigger the pipeline.

**Expected Output:**  
CircleCI will run the pipeline on every push to the repository. Depending on the branch, it will either deploy to the staging environment (for `develop` branch) or the production environment (for `main` branch). You can view the results on the CircleCI dashboard.

#### Resources:
1. [CircleCI Configuration Reference](https://circleci.com/docs/2.0/configuration-reference/)
2. [Managing Multiple Environments with CircleCI](https://circleci.com/blog/managing-multiple-environments-with-circleci/)

---

### Task 19: Study Analytics Integration

Integrating analytics into a React Native application is crucial for understanding user behavior, tracking app performance, and making data-driven decisions to improve the user experience. Analytics tools provide insights into how users interact with your app, which features are most popular, where users are dropping off, and much more. These insights can help you optimize your app, tailor features to user needs, and ultimately increase user engagement and retention.

There are various analytics platforms available for React Native applications, including Google Analytics, Firebase Analytics, and Segment. These platforms offer different features and capabilities, such as real-time tracking, custom event logging, and audience segmentation. Integrating these tools involves setting up the analytics service, installing the necessary SDKs, and implementing event tracking in your application. By leveraging analytics, you can gain valuable insights into your app's performance and user behavior, helping you to make informed decisions and drive your app's success.

#### Resources:
1. [Google Analytics for Firebase](https://firebase.google.com/docs/analytics)
2. [Segment Documentation](https://segment.com/docs/)

### Examples to Practice

#### Example 1: Integrating Firebase Analytics
**Explanation:**  
Firebase Analytics is a free app measurement solution that provides insights on app usage and user engagement. It integrates seamlessly with other Firebase services and offers powerful features like real-time reporting, user segmentation, and custom event tracking. This example demonstrates how to integrate Firebase Analytics into a React Native application to track user interactions.

**Code:**
1. Install the Firebase and Firebase Analytics packages:
```bash
npm install @react-native-firebase/app @react-native-firebase/analytics
```

2. Initialize Firebase in your application:
```jsx
// App.js
import React from 'react';
import { View, Text, Button } from 'react-native';
import analytics from '@react-native-firebase/analytics';

const App = () => {
  const logEvent = async () => {
    await analytics().logEvent('button_press', {
      item: 'Test Button',
      description: 'Testing button press event',
    });
  };

  return (
    <View>
      <Text>Firebase Analytics Example</Text>
      <Button title="Press me" onPress={logEvent} />
    </View>
  );
};

export default App;
```

3. Set up Firebase in your project by following the official [React Native Firebase documentation](https://rnfirebase.io/).

4. Run the application.

**Expected Output:**  
When you press the button in the application, a "button_press" event is logged to Firebase Analytics. You can view the event data in the Firebase console, providing insights into user interactions.

#### Resources:
1. [React Native Firebase Documentation](https://rnfirebase.io/)
2. [Firebase Analytics Documentation](https://firebase.google.com/docs/analytics)

#### Example 2: Integrating Google Analytics with React Native
**Explanation:**  
Google Analytics is a powerful analytics tool that provides detailed insights into app usage and user behavior. This example demonstrates how to integrate Google Analytics into a React Native application using the `react-native-google-analytics-bridge` package. You will track screen views and custom events to gain insights into user interactions.

**Code:**
1. Install the `react-native-google-analytics-bridge` package:
```bash
npm install react-native-google-analytics-bridge
```

2. Initialize Google Analytics in your application:
```jsx
// App.js
import React from 'react';
import { View, Text, Button } from 'react-native';
import { GoogleAnalyticsTracker } from 'react-native-google-analytics-bridge';

const tracker = new GoogleAnalyticsTracker('YOUR_TRACKING_ID');

const App = () => {
  const logEvent = () => {
    tracker.trackEvent('TestCategory', 'Button Press');
  };

  const trackScreenView = () => {
    tracker.trackScreenView('HomeScreen');
  };

  React.useEffect(() => {
    trackScreenView();
  }, []);

  return (
    <View>
      <Text>Google Analytics Example</Text>
      <Button title="Press me" onPress={logEvent} />
    </View>
  );
};

export default App;
```

3. Replace `YOUR_TRACKING_ID` with your Google Analytics tracking ID.

4. Run the application.

**Expected Output:**  
When you open the application, a screen view event is tracked, and pressing the button logs a custom event to Google Analytics. You can view the event data in the Google Analytics console, providing insights into user interactions and screen views.

#### Resources:
1. [Google Analytics for Firebase](https://firebase.google.com/docs/analytics)
2. [react-native-google-analytics-bridge Documentation](https://github.com/idehub/react-native-google-analytics-bridge)

#### Example 3: Integrating Segment Analytics
**Explanation:**  
Segment is a customer data platform that collects and routes data to various analytics and marketing tools. This example demonstrates how to integrate Segment into a React Native application to track user interactions. Segment allows you to send data to multiple destinations from a single integration point, making it a versatile tool for analytics and marketing.

**Code:**
1. Install the Segment package:
```bash
npm install @segment/analytics-react-native
npm install @segment/analytics-react-native-mixpanel @segment/analytics-react-native-firebase
```

2. Initialize Segment in your application:
```jsx
// App.js
import React from 'react';
import { View, Text, Button } from 'react-native';
import { createClient } from '@segment/analytics-react-native';
import { FirebasePlugin } from '@segment/analytics-react-native-firebase';
import { MixpanelPlugin } from '@segment/analytics-react-native-mixpanel';

const segmentClient = createClient({
  writeKey: 'YOUR_SEGMENT_WRITE_KEY',
  plugins: [new FirebasePlugin(), new MixpanelPlugin('YOUR_MIXPANEL_TOKEN')],
});

const App = () => {
  const logEvent = () => {
    segmentClient.track('Button Pressed', {
      category: 'Test',
      label: 'Testing button press event',
    });
  };

  return (
    <View>
      <Text>Segment Analytics Example</Text>
      <Button title="Press me" onPress={logEvent} />
    </View>
  );
};

export default App;
```

3. Replace `YOUR_SEGMENT_WRITE_KEY` and `YOUR_MIXPANEL_TOKEN` with your Segment and Mixpanel credentials.

4. Run the application.

**Expected Output:**  
When you press the button in the application, a "Button Pressed" event is logged to Segment. Segment then routes this event to configured destinations like Firebase and Mixpanel. You can view the event data in the respective analytics dashboards, providing insights into user interactions.

#### Resources:
1. [Segment Documentation](https://segment.com/docs/)
2. [Segment React Native Library](https://github.com/segmentio/analytics-react-native)

---

### Task 20: Implement Event Tracking with Segment

Event tracking with Segment in a React Native application allows you to gather detailed insights into user interactions and behavior. Segment acts as a data hub, collecting event data from your app and forwarding it to various analytics and marketing platforms such as Google Analytics, Mixpanel, and Firebase. This centralized approach simplifies the integration process and enables you to manage all your analytics tools from a single point.

By implementing event tracking with Segment, you can capture important events such as user sign-ups, button clicks, and page views. This data helps you understand how users interact with your app, identify popular features, and detect potential issues. With Segment's robust tracking capabilities, you can make data-driven decisions to enhance user experience and drive app growth.

#### Resources:
1. [Segment Documentation](https://segment.com/docs/)
2. [Segment React Native Library](https://github.com/segmentio/analytics-react-native)

### Examples to Practice

#### Example 1: Basic Event Tracking with Segment
**Explanation:**  
This example demonstrates how to set up basic event tracking in a React Native application using Segment. You will initialize the Segment client and track a simple event when a button is pressed. This setup is fundamental to understanding how event tracking works and how to log user interactions.

**Code:**
1. Install the Segment package:
```bash
npm install @segment/analytics-react-native
```

2. Initialize Segment in your application:
```jsx
// App.js
import React from 'react';
import { View, Text, Button } from 'react-native';
import { createClient } from '@segment/analytics-react-native';

const segmentClient = createClient({
  writeKey: 'YOUR_SEGMENT_WRITE_KEY',
});

const App = () => {
  const logEvent = () => {
    segmentClient.track('Button Pressed', {
      category: 'Test',
      label: 'Testing button press event',
    });
  };

  return (
    <View>
      <Text>Segment Event Tracking Example</Text>
      <Button title="Press me" onPress={logEvent} />
    </View>
  );
};

export default App;
```

3. Replace `YOUR_SEGMENT_WRITE_KEY` with your Segment write key.

4. Run the application.

**Expected Output:**  
When you press the button in the application, a "Button Pressed" event is logged to Segment. You can view the event data in the Segment dashboard, providing insights into user interactions.

#### Resources:
1. [Segment Event Tracking](https://segment.com/docs/spec/track/)
2. [Segment React Native Integration](https://github.com/segmentio/analytics-react-native)

#### Example 2: Tracking Page Views with Segment
**Explanation:**  
This example demonstrates how to track page views in a React Native application using Segment. By tracking page views, you can gather data on which screens users visit most frequently and how they navigate through your app. This information is valuable for understanding user behavior and optimizing the app's navigation flow.

**Code:**
1. Install the Segment package (if not already installed):
```bash
npm install @segment/analytics-react-native
```

2. Initialize Segment and track page views:
```jsx
// App.js
import React, { useEffect } from 'react';
import { View, Text, Button } from 'react-native';
import { createClient } from '@segment/analytics-react-native';

const segmentClient = createClient({
  writeKey: 'YOUR_SEGMENT_WRITE_KEY',
});

const App = () => {
  useEffect(() => {
    segmentClient.screen('Home Screen');
  }, []);

  const logEvent = () => {
    segmentClient.track('Button Pressed', {
      category: 'Test',
      label: 'Testing button press event',
    });
  };

  return (
    <View>
      <Text>Segment Page View Tracking Example</Text>
      <Button title="Press me" onPress={logEvent} />
    </View>
  );
};

export default App;
```

3. Replace `YOUR_SEGMENT_WRITE_KEY` with your Segment write key.

4. Run the application.

**Expected Output:**  
When the application is opened, a "Home Screen" page view event is logged to Segment. Additionally, pressing the button logs a "Button Pressed" event. You can view the page view and event data in the Segment dashboard.

#### Resources:
1. [Segment Screen Tracking](https://segment.com/docs/spec/screen/)
2. [Segment React Native Integration](https://github.com/segmentio/analytics-react-native)

#### Example 3: Tracking User Sign-Ups with Segment
**Explanation:**  
This example demonstrates how to track user sign-ups in a React Native application using Segment. Tracking user sign-ups helps you understand how many new users are joining your app and analyze their behavior after registration. This information is crucial for measuring the effectiveness of your user acquisition strategies.

**Code:**
1. Install the Segment package (if not already installed):
```bash
npm install @segment/analytics-react-native
```

2. Initialize Segment and track user sign-ups:
```jsx
// App.js
import React, { useState } from 'react';
import { View, Text, TextInput, Button } from 'react-native';
import { createClient } from '@segment/analytics-react-native';

const segmentClient = createClient({
  writeKey: 'YOUR_SEGMENT_WRITE_KEY',
});

const App = () => {
  const [email, setEmail] = useState('');

  const handleSignUp = () => {
    segmentClient.identify('userId123', {
      email: email,
    });
    segmentClient.track('User Signed Up', {
      email: email,
    });
  };

  return (
    <View>
      <Text>Segment User Sign-Up Tracking Example</Text>
      <TextInput
        placeholder="Enter your email"
        value={email}
        onChangeText={setEmail}
      />
      <Button title="Sign Up" onPress={handleSignUp} />
    </View>
  );
};

export default App;
```

3. Replace `YOUR_SEGMENT_WRITE_KEY` with your Segment write key.

4. Run the application.

**Expected Output:**  
When a user enters their email and presses the "Sign Up" button, an "identify" event and a "User Signed Up" event are logged to Segment. You can view the user identification and event data in the Segment dashboard, providing insights into user registrations.

#### Resources:
1. [Segment Identify Method](https://segment.com/docs/spec/identify/)
2. [Segment Track Method](https://segment.com/docs/spec/track/)

---
