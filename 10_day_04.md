# prompt
## split day 4 studying to 20 tasks to complete, for each task give me 2 paragraphs explaining the topic, 2 online resources to refer, 2 examples to practice, 2 paragraph explaining each example, 2 online resources to refer, also give me the code that i should use to practice and give the expected output

### Day 4 Study Plan: React.js Fundamentals

#### Task 1: Introduction to React.js
**Explanation:**
React.js is a JavaScript library for building user interfaces, developed by Facebook. It is component-based, which means that the UI is built from small, reusable pieces of code called components. Components can be class-based or function-based and can maintain their own state and lifecycle methods.

React uses a virtual DOM to optimize updates and rendering, making it highly efficient. When the state of a component changes, React updates the virtual DOM and then efficiently updates the real DOM to match. This results in fast and responsive user interfaces.

**Online Resources:**
1. [React Official Documentation](https://reactjs.org/docs/getting-started.html)
2. [React Introduction - MDN Web Docs](https://developer.mozilla.org/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started)

**Example 1: Creating a Simple React Component**
1. **Component Definition:** Define a simple functional component in React.
2. **Rendering the Component:** Render the component to the DOM using `ReactDOM.render`.

**Explanation for Example 1:**
A functional component in React is a JavaScript function that returns JSX, which is a syntax extension for JavaScript that looks similar to HTML. The `ReactDOM.render` method is used to render the React component into the DOM.

**Example 2: JSX Syntax**
1. **Using JSX:** Write a component that returns JSX to create a simple UI.
2. **Embedding Expressions:** Embed JavaScript expressions within JSX using curly braces.

**Explanation for Example 2:**
JSX allows you to write HTML-like syntax directly within JavaScript, making it easier to create and visualize the UI structure. You can embed JavaScript expressions within JSX by enclosing them in curly braces, enabling dynamic content generation.

**Online Resources:**
1. [React Component](https://reactjs.org/docs/components-and-props.html)
2. [JSX in Depth](https://reactjs.org/docs/jsx-in-depth.html)

**Code and Expected Output:**
```jsx
// Creating a Simple React Component
import React from 'react';
import ReactDOM from 'react-dom';

function HelloWorld() {
    return <h1>Hello, World!</h1>;
}

ReactDOM.render(<HelloWorld />, document.getElementById('root'));
// Expected Output: A webpage displaying "Hello, World!"
```

```jsx
// JSX Syntax
import React from 'react';
import ReactDOM from 'react-dom';

function Greeting() {
    const name = 'Alice';
    return <h1>Hello, {name}!</h1>;
}

ReactDOM.render(<Greeting />, document.getElementById('root'));
// Expected Output: A webpage displaying "Hello, Alice!"
```

#### Task 2: Setting Up a React Project
**Explanation:**
Setting up a React project typically involves using Create React App (CRA), a tool that sets up a new React project with a modern build setup. CRA handles the configuration of Webpack, Babel, and other tools, allowing developers to focus on writing code.

Create React App provides a development server, hot reloading, and a build script to bundle the application for production. This makes it easy to start a new React project without worrying about the complexities of setting up the build environment.

**Online Resources:**
1. [Create React App](https://reactjs.org/docs/create-a-new-react-app.html)
2. [Getting Started with Create React App](https://create-react-app.dev/docs/getting-started/)

**Example 1: Installing Create React App**
1. **Installing via npm:** Use npm to install Create React App globally.
2. **Creating a New Project:** Create a new React project using Create React App.

**Explanation for Example 1:**
Installing Create React App globally allows you to use the `create-react-app` command to generate new React projects easily. Creating a new project initializes a directory with all necessary files and configurations to start developing a React application.

**Example 2: Running the Development Server**
1. **Starting the Server:** Use the provided script to start the development server.
2. **Viewing the Application:** Access the running application in a web browser.

**Explanation for Example 2:**
The development server provided by Create React App supports hot reloading, which automatically updates the application when changes are made to the code. This makes development faster and more efficient.

**Online Resources:**
1. [Create React App Documentation](https://create-react-app.dev/docs/getting-started/)
2. [Setting Up a React Environment](https://www.freecodecamp.org/news/setting-up-a-react-environment-using-webpack-and-babel-5114a14a47b7/)

**Code and Expected Output:**
```sh
// Installing Create React App
npm install -g create-react-app

// Creating a New Project
create-react-app my-app

// Changing to the Project Directory
cd my-app

// Starting the Development Server
npm start
// Expected Output: A development server running at http://localhost:3000 displaying the default React welcome page.
```

#### Task 3: React Components and Props
**Explanation:**
In React, components are the building blocks of the user interface. There are two main types of components: functional components and class components. Functional components are simple functions that return JSX, while class components are ES6 classes that extend `React.Component`.

Props (short for properties) are used to pass data from a parent component to a child component. Props are read-only and cannot be modified by the child component, ensuring that data flows in one direction, from parent to child. This helps maintain a predictable and manageable component structure.

**Online Resources:**
1. [Components and Props - React](https://reactjs.org/docs/components-and-props.html)
2. [React Props Tutorial](https://www.w3schools.com/react/react_props.asp)

**Example 1: Functional Components and Props**
1. **Defining a Functional Component:** Create a functional component that accepts props.
2. **Passing Props:** Pass props from a parent component to the child component.

**Explanation for Example 1:**
Functional components are simple functions that return JSX and can accept props as an argument. Passing props from a parent component to a child component allows the parent to control the child's data and behavior.

**Example 2: Class Components and Props**
1. **Defining a Class Component:** Create a class component that accepts props.
2. **Rendering with Props:** Use props within the render method of the class component.

**Explanation for Example 2:**
Class components extend `React.Component` and must include a `render` method that returns JSX. Props can be accessed using `this.props` within the class component, allowing the component to render dynamic content based on the passed props.

**Online Resources:**
1. [React Functional Components](https://reactjs.org/docs/components-and-props.html#function-and-class-components)
2. [React Class Components](https://reactjs.org/docs/react-component.html)

**Code and Expected Output:**
```jsx
// Functional Components and Props
import React from 'react';
import ReactDOM from 'react-dom';

function Welcome(props) {
    return <h1>Hello, {props.name}!</h1>;
}

function App() {
    return <Welcome name="Alice" />;
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A webpage displaying "Hello, Alice!"
```

```jsx
// Class Components and Props
import React from 'react';
import ReactDOM from 'react-dom';

class Welcome extends React.Component {
    render() {
        return <h1>Hello, {this.props.name}!</h1>;
    }
}

class App extends React.Component {
    render() {
        return <Welcome name="Bob" />;
    }
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A webpage displaying "Hello, Bob!"
```

#### Task 4: State and Lifecycle in React
**Explanation:**
State in React is used to manage the data that changes over time within a component. State is mutable and can be modified using the `setState` method. Class components use the `this.state` property to define the initial state, while functional components use the `useState` hook introduced in React 16.8.

Lifecycle methods are special methods in class components that are called at different stages of a component's lifecycle, such as mounting, updating, and unmounting. Common lifecycle methods include `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`. Understanding state and lifecycle methods is crucial for managing component behavior and side effects.

**Online Resources:**
1. [State and Lifecycle - React](https://reactjs.org/docs/state-and-lifecycle.html)
2. [React Component Lifecycle](https://www.w3schools.com/react/react_lifecycle.asp)

**Example 1: State in Class Components**
1. **Defining State:** Define the initial state in a class component's constructor.
2. **Updating State:** Use `setState` to update the component's state.

**Explanation for Example 1:**
Class components define the initial state in the constructor using `this.state`. The `setState` method is used to update the state, which triggers a re-render of the component to reflect the new state.

**Example 2: State in Functional Components**
1. **Using useState:** Use the `useState` hook to manage state in a functional component.
2. **Updating State:** Update the state using the state updater function returned by `useState`.

**Explanation for Example 2:**
The `useState` hook is used in functional components to manage state. It returns an array with the current state value and a function to update the state. Using the state updater function, you can modify

 the state and trigger a re-render of the component.

**Online Resources:**
1. [React State](https://reactjs.org/docs/state-and-lifecycle.html#adding-local-state-to-a-class)
2. [Using the State Hook](https://reactjs.org/docs/hooks-state.html)

**Code and Expected Output:**
```jsx
// State in Class Components
import React from 'react';
import ReactDOM from 'react-dom';

class Counter extends React.Component {
    constructor(props) {
        super(props);
        this.state = { count: 0 };
    }

    increment = () => {
        this.setState({ count: this.state.count + 1 });
    };

    render() {
        return (
            <div>
                <p>Count: {this.state.count}</p>
                <button onClick={this.increment}>Increment</button>
            </div>
        );
    }
}

ReactDOM.render(<Counter />, document.getElementById('root'));
// Expected Output: A counter that increments the count when the button is clicked.
```

```jsx
// State in Functional Components
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

ReactDOM.render(<Counter />, document.getElementById('root'));
// Expected Output: A counter that increments the count when the button is clicked.
```

#### Task 5: Handling Events in React
**Explanation:**
Handling events in React is similar to handling events in plain JavaScript, but with some syntactic differences. React events are named using camelCase, and you pass the event handler function as a property, rather than using a string. Common events include `onClick`, `onChange`, `onSubmit`, and `onMouseOver`.

React provides a synthetic event system that normalizes events across different browsers, ensuring consistent behavior. Event handlers can access the event object and update the component's state in response to user interactions. Understanding how to handle events is essential for creating interactive and responsive user interfaces.

**Online Resources:**
1. [Handling Events - React](https://reactjs.org/docs/handling-events.html)
2. [React Event Handling](https://www.w3schools.com/react/react_events.asp)

**Example 1: Handling Click Events**
1. **Defining an Event Handler:** Define a function to handle click events in a component.
2. **Attaching the Event Handler:** Attach the event handler to a button's `onClick` event.

**Explanation for Example 1:**
Defining an event handler function allows you to specify what should happen when an event occurs. Attaching the event handler to a button's `onClick` event enables the component to respond to user interactions, such as button clicks.

**Example 2: Handling Form Events**
1. **Handling Input Change:** Define an event handler to update the component's state when an input field changes.
2. **Handling Form Submission:** Define an event handler to handle form submissions and prevent the default behavior.

**Explanation for Example 2:**
Handling input change events allows you to update the component's state based on user input, enabling real-time updates to the UI. Handling form submission events allows you to process form data and perform actions, such as validation or sending data to a server.

**Online Resources:**
1. [React Form Handling](https://reactjs.org/docs/forms.html)
2. [React Input Handling](https://www.tutorialspoint.com/reactjs/reactjs_forms.htm)

**Code and Expected Output:**
```jsx
// Handling Click Events
import React from 'react';
import ReactDOM from 'react-dom';

class ClickHandler extends React.Component {
    handleClick = () => {
        alert('Button clicked!');
    };

    render() {
        return <button onClick={this.handleClick}>Click Me</button>;
    }
}

ReactDOM.render(<ClickHandler />, document.getElementById('root'));
// Expected Output: An alert saying "Button clicked!" when the button is clicked.
```

```jsx
// Handling Form Events
import React from 'react';
import ReactDOM from 'react-dom';

class FormHandler extends React.Component {
    constructor(props) {
        super(props);
        this.state = { value: '' };
    }

    handleChange = (event) => {
        this.setState({ value: event.target.value });
    };

    handleSubmit = (event) => {
        alert('Form submitted with value: ' + this.state.value);
        event.preventDefault();
    };

    render() {
        return (
            <form onSubmit={this.handleSubmit}>
                <input type="text" value={this.state.value} onChange={this.handleChange} />
                <button type="submit">Submit</button>
            </form>
        );
    }
}

ReactDOM.render(<FormHandler />, document.getElementById('root'));
// Expected Output: An alert showing the input value when the form is submitted.
```

#### Task 6: Conditional Rendering in React
**Explanation:**
Conditional rendering in React allows you to render different components or elements based on certain conditions. This is often used to display different UI elements depending on the state or props of a component. You can use JavaScript conditional operators such as `if`, `else`, and ternary operators to implement conditional rendering.

React's ability to conditionally render components makes it highly flexible and dynamic. This feature is essential for creating complex user interfaces that respond to user interactions and application state changes.

**Online Resources:**
1. [Conditional Rendering - React](https://reactjs.org/docs/conditional-rendering.html)
2. [React Conditional Rendering Tutorial](https://www.w3schools.com/react/react_conditional_rendering.asp)

**Example 1: Using if-else Statements**
1. **Conditional Rendering with if-else:** Use an if-else statement to conditionally render components based on state.
2. **Rendering Different Components:** Render different components based on the condition.

**Explanation for Example 1:**
Using if-else statements allows you to conditionally render different components based on the state or props of the parent component. This technique is useful for displaying different UI elements under different conditions.

**Example 2: Using Ternary Operators**
1. **Conditional Rendering with Ternary Operators:** Use a ternary operator to conditionally render components in a concise manner.
2. **Rendering Inline Elements:** Render inline elements based on the condition using a ternary operator.

**Explanation for Example 2:**
Ternary operators provide a shorthand way to conditionally render components or elements. This method is useful for simple conditions and can make the code more concise and readable.

**Online Resources:**
1. [React Ternary Conditional Operator](https://www.digitalocean.com/community/tutorials/react-conditional-rendering)
2. [Conditional Rendering in React](https://www.tutorialspoint.com/reactjs/reactjs_conditional_rendering.htm)

**Code and Expected Output:**
```jsx
// Using if-else Statements
import React from 'react';
import ReactDOM from 'react-dom';

class ConditionalRender extends React.Component {
    constructor(props) {
        super(props);
        this.state = { isLoggedIn: false };
    }

    toggleLogin = () => {
        this.setState({ isLoggedIn: !this.state.isLoggedIn });
    };

    render() {
        if (this.state.isLoggedIn) {
            return (
                <div>
                    <h1>Welcome, User!</h1>
                    <button onClick={this.toggleLogin}>Logout</button>
                </div>
            );
        } else {
            return (
                <div>
                    <h1>Please log in.</h1>
                    <button onClick={this.toggleLogin}>Login</button>
                </div>
            );
        }
    }
}

ReactDOM.render(<ConditionalRender />, document.getElementById('root'));
// Expected Output: A login button that toggles between login and logout states.
```

```jsx
// Using Ternary Operators
import React from 'react';
import ReactDOM from 'react-dom';

class ConditionalRender extends React.Component {
    constructor(props) {
        super(props);
        this.state = { isLoggedIn: false };
    }

    toggleLogin = () => {
        this.setState({ isLoggedIn: !this.state.isLoggedIn });
    };

    render() {
        return (
            <div>
                <h1>{this.state.isLoggedIn ? 'Welcome, User!' : 'Please log in.'}</h1>
                <button onClick={this.toggleLogin}>
                    {this.state.isLoggedIn ? 'Logout' : 'Login'}
                </button>
            </div>
        );
    }
}

ReactDOM.render(<ConditionalRender />, document.getElementById('root'));
// Expected Output: A login button that toggles between login and logout states with a ternary operator.
```

#### Task 7: Lists and Keys in React
**Explanation:**
Rendering lists in React involves mapping over an array of data and returning a React element for each item. Keys are a special attribute that must be included when creating lists of elements. They help React identify which items have changed, been added, or removed, improving performance and ensuring the correct elements are updated.

Keys should be unique among siblings to prevent conflicts and ensure efficient updates. They can be derived from the data being rendered, such as unique IDs or indexes, but using unique IDs is generally recommended for better performance and stability.

**Online Resources:**
1. [Lists and Keys - React](https://reactjs.org/docs/lists-and-keys.html)
2. [React Lists and Keys Tutorial](https://www.w3

schools.com/react/react_lists.asp)

**Example 1: Rendering Lists with Keys**
1. **Mapping over Data:** Use the `map` function to render a list of elements.
2. **Adding Keys:** Add unique keys to each element in the list.

**Explanation for Example 1:**
Mapping over an array of data and returning a React element for each item allows you to dynamically render lists based on the data. Adding unique keys ensures that React can efficiently update the list when the data changes.

**Example 2: Dynamic Lists with Keys**
1. **Rendering a Dynamic List:** Render a list of items dynamically based on the component's state.
2. **Updating the List:** Update the list by modifying the state and ensuring the keys remain unique.

**Explanation for Example 2:**
Rendering a dynamic list based on the component's state allows you to update the list in response to user interactions or other events. Ensuring that keys remain unique prevents rendering issues and maintains performance.

**Online Resources:**
1. [React List Rendering](https://reactjs.org/docs/lists-and-keys.html#rendering-multiple-components)
2. [Using Keys in React](https://www.tutorialspoint.com/reactjs/reactjs_lists.htm)

**Code and Expected Output:**
```jsx
// Rendering Lists with Keys
import React from 'react';
import ReactDOM from 'react-dom';

const numbers = [1, 2, 3, 4, 5];
const listItems = numbers.map((number) =>
    <li key={number.toString()}>{number}</li>
);

ReactDOM.render(<ul>{listItems}</ul>, document.getElementById('root'));
// Expected Output: A list of numbers from 1 to 5.
```

```jsx
// Dynamic Lists with Keys
import React from 'react';
import ReactDOM from 'react-dom';

class DynamicList extends React.Component {
    constructor(props) {
        super(props);
        this.state = { items: ['Apple', 'Banana', 'Cherry'] };
    }

    addItem = () => {
        const newItem = `Item ${this.state.items.length + 1}`;
        this.setState({ items: [...this.state.items, newItem] });
    };

    render() {
        const listItems = this.state.items.map((item, index) =>
            <li key={index}>{item}</li>
        );
        return (
            <div>
                <ul>{listItems}</ul>
                <button onClick={this.addItem}>Add Item</button>
            </div>
        );
    }
}

ReactDOM.render(<DynamicList />, document.getElementById('root'));
// Expected Output: A dynamic list that adds new items when the button is clicked.
```

#### Task 8: Forms in React
**Explanation:**
Forms in React are used to collect user input and manage form data. React handles form elements using controlled components, where the form data is managed by the component's state. This allows you to have full control over the form data and handle changes dynamically.

Controlled components ensure that form data is always in sync with the component's state, making it easier to validate and process the input. You can handle form submissions, update state on input changes, and provide feedback to the user based on the input.

**Online Resources:**
1. [Forms - React](https://reactjs.org/docs/forms.html)
2. [React Forms Tutorial](https://www.w3schools.com/react/react_forms.asp)

**Example 1: Controlled Components**
1. **Defining Controlled Components:** Define input elements controlled by the component's state.
2. **Handling Input Changes:** Handle input change events to update the state.

**Explanation for Example 1:**
Controlled components use the component's state to manage form data, ensuring that the input elements are always in sync with the state. Handling input change events allows you to update the state dynamically based on user input.

**Example 2: Form Submission**
1. **Handling Form Submission:** Define an event handler to handle form submissions and prevent the default behavior.
2. **Processing Form Data:** Process the form data and provide feedback to the user.

**Explanation for Example 2:**
Handling form submission events allows you to process the form data and perform actions, such as validation or sending data to a server. Preventing the default behavior ensures that the form is not submitted to the server in the traditional way, allowing you to handle the submission in React.

**Online Resources:**
1. [React Controlled Components](https://reactjs.org/docs/forms.html#controlled-components)
2. [React Form Handling](https://www.tutorialspoint.com/reactjs/reactjs_forms.htm)

**Code and Expected Output:**
```jsx
// Controlled Components
import React from 'react';
import ReactDOM from 'react-dom';

class ControlledForm extends React.Component {
    constructor(props) {
        super(props);
        this.state = { value: '' };
    }

    handleChange = (event) => {
        this.setState({ value: event.target.value });
    };

    render() {
        return (
            <form>
                <label>
                    Name:
                    <input type="text" value={this.state.value} onChange={this.handleChange} />
                </label>
                <p>Entered Name: {this.state.value}</p>
            </form>
        );
    }
}

ReactDOM.render(<ControlledForm />, document.getElementById('root'));
// Expected Output: An input field that displays the entered name below it.
```

```jsx
// Form Submission
import React from 'react';
import ReactDOM from 'react-dom';

class ControlledForm extends React.Component {
    constructor(props) {
        super(props);
        this.state = { value: '' };
    }

    handleChange = (event) => {
        this.setState({ value: event.target.value });
    };

    handleSubmit = (event) => {
        alert('A name was submitted: ' + this.state.value);
        event.preventDefault();
    };

    render() {
        return (
            <form onSubmit={this.handleSubmit}>
                <label>
                    Name:
                    <input type="text" value={this.state.value} onChange={this.handleChange} />
                </label>
                <button type="submit">Submit</button>
            </form>
        );
    }
}

ReactDOM.render(<ControlledForm />, document.getElementById('root'));
// Expected Output: An alert showing the entered name when the form is submitted.
```

#### Task 9: Lifting State Up in React
**Explanation:**
Lifting state up in React involves moving state from a child component to a common parent component. This is done to share the state between multiple child components or to manage the state in a single place. By lifting state up, you can avoid duplicating state and ensure consistent data across components.

Lifting state up is often necessary when multiple components need to reflect the same state. The parent component holds the state and passes it down to the child components via props, allowing them to communicate and stay synchronized.

**Online Resources:**
1. [Lifting State Up - React](https://reactjs.org/docs/lifting-state-up.html)
2. [React Lifting State Up Tutorial](https://www.w3schools.com/react/react_lifecycle.asp)

**Example 1: Lifting State Up for Sibling Components**
1. **Defining State in Parent:** Define the state in the parent component.
2. **Passing State to Children:** Pass the state and state updater function to child components via props.

**Explanation for Example 1:**
Defining the state in the parent component allows you to manage the state in a single place. Passing the state and updater function to child components via props ensures that they can access and update the shared state.

**Example 2: Synchronizing State Between Components**
1. **Updating State from Children:** Update the state from child components using the passed updater function.
2. **Reflecting State Changes:** Reflect the state changes in both child components to keep them synchronized.

**Explanation for Example 2:**
Updating the state from child components using the passed updater function ensures that the state remains consistent. Reflecting the state changes in both child components allows them to stay synchronized and display the updated data.

**Online Resources:**
1. [React State Management](https://reactjs.org/docs/state-and-lifecycle.html)
2. [Lifting State Up in React](https://www.digitalocean.com/community/tutorials/react-lifting-state-up)

**Code and Expected Output:**
```jsx
// Lifting State Up for Sibling Components
import React from 'react';
import ReactDOM from 'react-dom';

class ParentComponent extends React.Component {
    constructor(props) {
        super(props);
        this.state = { sharedValue: '' };
    }

    updateSharedValue = (value) => {
        this.setState({ sharedValue: value });
    };

    render() {
        return (
            <div>
                <ChildComponent1 value={this.state.sharedValue} onChange={this.updateSharedValue} />
                <ChildComponent2 value={this.state.sharedValue} />
            </div>
        );
    }
}

function ChildComponent1(props) {
    return (
        <div>
            <input type="text" value={props.value} onChange={(e) => props.onChange(e.target.value)} />
        </div>
    );
}

function ChildComponent2(props) {
    return <p>Shared Value: {props.value}</p>;
}

ReactDOM.render(<ParentComponent />, document.getElementById('root'));
// Expected Output: An input field in ChildComponent1 that updates the shared value displayed in ChildComponent2.
```

```jsx
// Synchronizing State Between Components
import React from 'react';
import ReactDOM from 'react-dom';

class TemperatureConverter extends React.Component {
    constructor(props) {
        super(props);
        this.state

 = { temperature: '' };
    }

    handleTemperatureChange = (temperature) => {
        this.setState({ temperature });
    };

    render() {
        const temperature = this.state.temperature;
        const celsius = parseFloat(temperature) || 0;
        const fahrenheit = (celsius * 9 / 5) + 32;

        return (
            <div>
                <TemperatureInput
                    scale="C"
                    temperature={temperature}
                    onTemperatureChange={this.handleTemperatureChange}
                />
                <TemperatureInput
                    scale="F"
                    temperature={fahrenheit.toFixed(2)}
                    onTemperatureChange={(temp) => this.handleTemperatureChange((temp - 32) * 5 / 9)}
                />
            </div>
        );
    }
}

function TemperatureInput(props) {
    const scaleNames = {
        C: 'Celsius',
        F: 'Fahrenheit'
    };

    return (
        <fieldset>
            <legend>Enter temperature in {scaleNames[props.scale]}:</legend>
            <input
                type="text"
                value={props.temperature}
                onChange={(e) => props.onTemperatureChange(parseFloat(e.target.value))}
            />
        </fieldset>
    );
}

ReactDOM.render(<TemperatureConverter />, document.getElementById('root'));
// Expected Output: Two input fields for Celsius and Fahrenheit temperatures that stay synchronized.
```

#### Task 10: Composition vs. Inheritance in React
**Explanation:**
React emphasizes composition over inheritance for building components. Composition involves creating components that contain other components as children or props. This approach allows for flexible and reusable component structures, enabling you to build complex UIs from simple, modular components.

Inheritance, on the other hand, involves extending a base class to create specialized components. While inheritance can be useful in some scenarios, React's composition model is generally preferred as it promotes better code organization and reusability. Understanding when to use composition and how to apply it effectively is crucial for building maintainable React applications.

**Online Resources:**
1. [Composition vs. Inheritance - React](https://reactjs.org/docs/composition-vs-inheritance.html)
2. [React Composition and Inheritance](https://www.tutorialspoint.com/reactjs/reactjs_composition.htm)

**Example 1: Component Composition**
1. **Composing Components:** Create components that contain other components as children or props.
2. **Flexible Composition:** Use composition to build flexible and reusable component structures.

**Explanation for Example 1:**
Composing components allows you to build complex UIs by combining simple, reusable components. This approach promotes code reuse and flexibility, enabling you to create dynamic and maintainable component structures.

**Example 2: Specialization through Composition**
1. **Specializing Components:** Create specialized components by composing existing components with additional props or children.
2. **Enhancing Reusability:** Enhance component reusability by using composition to create variations of a component.

**Explanation for Example 2:**
Specializing components through composition allows you to create variations of a component with different behavior or appearance. This approach enhances reusability and maintainability by keeping the core component logic separate from the variations.

**Online Resources:**
1. [React Component Composition](https://reactjs.org/docs/composition-vs-inheritance.html#containment)
2. [Using Composition in React](https://www.digitalocean.com/community/tutorials/react-composition-vs-inheritance)

**Code and Expected Output:**
```jsx
// Component Composition
import React from 'react';
import ReactDOM from 'react-dom';

function Welcome(props) {
    return <h1>Hello, {props.name}!</h1>;
}

function App() {
    return (
        <div>
            <Welcome name="Alice" />
            <Welcome name="Bob" />
            <Welcome name="Charlie" />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A webpage displaying "Hello, Alice!", "Hello, Bob!", and "Hello, Charlie!".
```

```jsx
// Specialization through Composition
import React from 'react';
import ReactDOM from 'react-dom';

function Button(props) {
    return <button className={props.className}>{props.children}</button>;
}

function PrimaryButton(props) {
    return <Button className="primary">{props.children}</Button>;
}

function SecondaryButton(props) {
    return <Button className="secondary">{props.children}</Button>;
}

function App() {
    return (
        <div>
            <PrimaryButton>Primary Action</PrimaryButton>
            <SecondaryButton>Secondary Action</SecondaryButton>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A webpage displaying a primary button and a secondary button with different styles.
```

#### Task 11: React Context API
**Explanation:**
The React Context API is a way to pass data through the component tree without having to pass props down manually at every level. Context is designed to share data that can be considered global for a tree of React components, such as the current authenticated user, theme, or preferred language.

Context consists of a `Provider` and a `Consumer`. The `Provider` component is used to wrap the part of the application that needs access to the context and provides the context value. The `Consumer` component is used to access the context value from within the component tree.

**Online Resources:**
1. [Context - React](https://reactjs.org/docs/context.html)
2. [React Context API Tutorial](https://www.w3schools.com/react/react_context.asp)

**Example 1: Creating and Providing Context**
1. **Creating Context:** Create a context using `React.createContext`.
2. **Providing Context:** Use the `Provider` component to provide the context value to the component tree.

**Explanation for Example 1:**
Creating a context using `React.createContext` initializes a new context object. The `Provider` component is used to wrap the component tree and provide the context value, making it accessible to all components within the tree.

**Example 2: Consuming Context**
1. **Using Context Consumer:** Use the `Consumer` component to access the context value within a component.
2. **Using useContext Hook:** Use the `useContext` hook to access the context value in a functional component.

**Explanation for Example 2:**
The `Consumer` component allows you to access the context value within a component by using a render prop function. The `useContext` hook provides a simpler way to access the context value in functional components, enhancing readability and ease of use.

**Online Resources:**
1. [React Context API](https://reactjs.org/docs/context.html#contextprovider)
2. [Using the Context API](https://www.tutorialspoint.com/reactjs/reactjs_context_api.htm)

**Code and Expected Output:**
```jsx
// Creating and Providing Context
import React from 'react';
import ReactDOM from 'react-dom';

const ThemeContext = React.createContext('light');

class App extends React.Component {
    render() {
        return (
            <ThemeContext.Provider value="dark">
                <Toolbar />
            </ThemeContext.Provider>
        );
    }
}

function Toolbar() {
    return (
        <div>
            <ThemedButton />
        </div>
    );
}

function ThemedButton() {
    return (
        <ThemeContext.Consumer>
            {value => <button className={value}>Themed Button</button>}
        </ThemeContext.Consumer>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button with a class of "dark".
```

```jsx
// Using useContext Hook
import React, { useContext } from 'react';
import ReactDOM from 'react-dom';

const ThemeContext = React.createContext('light');

function App() {
    return (
        <ThemeContext.Provider value="dark">
            <Toolbar />
        </ThemeContext.Provider>
    );
}

function Toolbar() {
    return (
        <div>
            <ThemedButton />
        </div>
    );
}

function ThemedButton() {
    const theme = useContext(ThemeContext);
    return <button className={theme}>Themed Button</button>;
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button with a class of "dark".
```

#### Task 12: React Hooks
**Explanation:**
React Hooks are functions that let you use state and other React features in functional components. Hooks were introduced in React 16.8 and provide a way to manage state, side effects, and context in functional components without using class components. Common hooks include `useState`, `useEffect`, and `useContext`.

Hooks simplify the process of managing component state and lifecycle methods, making functional components more powerful and easier to use. They promote code reuse and separation of concerns by allowing you to extract logic into reusable hooks.

**Online Resources:**
1. [Introducing Hooks - React](https://reactjs.org/docs/hooks-intro.html)
2. [React Hooks Tutorial](https://www.w3schools.com/react/react_hooks.asp)

**Example 1: Using useState Hook**
1. **Managing State:** Use the `useState` hook to manage state in a functional component.
2. **Updating State:** Update the state using the state updater function returned by `useState`.

**Explanation for Example 1:**
The `useState` hook initializes a state variable and returns a pair of values: the current state and a function to update it. Using the state updater function, you can modify the state and trigger a re-render of the component.

**Example 2: Using useEffect Hook**
1. **Side Effects:** Use the `useEffect` hook to handle side effects such as data fetching or subscriptions.


2. **Cleanup:** Return a cleanup function from `useEffect` to clean up side effects when the component unmounts.

**Explanation for Example 2:**
The `useEffect` hook allows you to perform side effects in functional components, such as fetching data or setting up event listeners. Returning a cleanup function ensures that side effects are properly cleaned up when the component unmounts, preventing memory leaks and other issues.

**Online Resources:**
1. [Using the State Hook](https://reactjs.org/docs/hooks-state.html)
2. [Using the Effect Hook](https://reactjs.org/docs/hooks-effect.html)

**Code and Expected Output:**
```jsx
// Using useState Hook
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function Counter() {
    const [count, setCount] = useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

ReactDOM.render(<Counter />, document.getElementById('root'));
// Expected Output: A counter that increments the count when the button is clicked.
```

```jsx
// Using useEffect Hook
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

function Timer() {
    const [seconds, setSeconds] = useState(0);

    useEffect(() => {
        const interval = setInterval(() => {
            setSeconds(seconds => seconds + 1);
        }, 1000);
        return () => clearInterval(interval);
    }, []);

    return (
        <div>
            <p>Seconds: {seconds}</p>
        </div>
    );
}

ReactDOM.render(<Timer />, document.getElementById('root'));
// Expected Output: A timer that increments the seconds every second.
```

#### Task 13: React Router
**Explanation:**
React Router is a library for routing in React applications. It allows you to define routes and navigate between different components or pages within your application. React Router provides components such as `BrowserRouter`, `Route`, `Link`, and `Switch` to manage routing.

React Router enables you to create single-page applications with multiple views and dynamic navigation. It allows you to handle client-side routing and update the UI based on the current URL without reloading the page.

**Online Resources:**
1. [React Router - React Training](https://reactrouter.com/web/guides/quick-start)
2. [React Router Tutorial](https://www.w3schools.com/react/react_router.asp)

**Example 1: Setting Up React Router**
1. **Installing React Router:** Install React Router using npm or yarn.
2. **Defining Routes:** Define routes using `Route` and wrap the application with `BrowserRouter`.

**Explanation for Example 1:**
Installing React Router allows you to use its components to manage routing in your React application. Defining routes using `Route` and wrapping the application with `BrowserRouter` sets up the routing configuration and enables client-side navigation.

**Example 2: Navigating with Links**
1. **Using Link Component:** Use the `Link` component to create navigational links.
2. **Dynamic Navigation:** Navigate between different routes dynamically based on user interactions.

**Explanation for Example 2:**
The `Link` component provides a way to create navigational links that update the URL and navigate to different routes without reloading the page. This enables dynamic navigation and a seamless user experience in single-page applications.

**Online Resources:**
1. [React Router Basics](https://reactrouter.com/web/guides/quick-start)
2. [Using React Router](https://reactjs.org/docs/react-router.html)

**Code and Expected Output:**
```sh
// Installing React Router
npm install react-router-dom
```

```jsx
// Setting Up React Router
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router, Route, Switch } from 'react-router-dom';

function Home() {
    return <h1>Home Page</h1>;
}

function About() {
    return <h1>About Page</h1>;
}

function App() {
    return (
        <Router>
            <Switch>
                <Route exact path="/" component={Home} />
                <Route path="/about" component={About} />
            </Switch>
        </Router>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A router setup with two pages: Home and About.
```

```jsx
// Navigating with Links
import React from 'react';
import ReactDOM from 'react-dom';
import { BrowserRouter as Router, Route, Link, Switch } from 'react-router-dom';

function Home() {
    return <h1>Home Page</h1>;
}

function About() {
    return <h1>About Page</h1>;
}

function App() {
    return (
        <Router>
            <nav>
                <ul>
                    <li><Link to="/">Home</Link></li>
                    <li><Link to="/about">About</Link></li>
                </ul>
            </nav>
            <Switch>
                <Route exact path="/" component={Home} />
                <Route path="/about" component={About} />
            </Switch>
        </Router>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: Navigational links that switch between Home and About pages.
```

#### Task 14: Higher-Order Components in React
**Explanation:**
Higher-Order Components (HOCs) are a pattern in React for reusing component logic. An HOC is a function that takes a component and returns a new component with additional props or behavior. HOCs are often used for cross-cutting concerns such as authentication, data fetching, and theming.

HOCs help you avoid code duplication by abstracting common logic into a reusable function. They enhance components with additional functionality while keeping the original component logic separate and clean.

**Online Resources:**
1. [Higher-Order Components - React](https://reactjs.org/docs/higher-order-components.html)
2. [React Higher-Order Components Tutorial](https://www.w3schools.com/react/react_hoc.asp)

**Example 1: Creating a Higher-Order Component**
1. **Defining an HOC:** Define a higher-order component that adds additional props or behavior to a wrapped component.
2. **Using the HOC:** Wrap a component with the HOC to enhance its functionality.

**Explanation for Example 1:**
Defining a higher-order component involves creating a function that takes a component and returns a new component with additional props or behavior. Using the HOC to wrap a component enhances its functionality while keeping the original component logic separate.

**Example 2: HOC for Data Fetching**
1. **Creating a Data Fetching HOC:** Define an HOC that fetches data and passes it as props to the wrapped component.
2. **Using the Data Fetching HOC:** Wrap a component with the data fetching HOC to provide it with fetched data.

**Explanation for Example 2:**
Creating a data fetching HOC involves defining a function that fetches data and passes it as props to the wrapped component. Using the data fetching HOC allows you to abstract data fetching logic and provide components with fetched data without duplicating code.

**Online Resources:**
1. [Understanding HOCs](https://reactjs.org/docs/higher-order-components.html#use-hocs-for-cross-cutting-concerns)
2. [Creating Higher-Order Components](https://www.digitalocean.com/community/tutorials/react-higher-order-components)

**Code and Expected Output:**
```jsx
// Creating a Higher-Order Component
import React from 'react';
import ReactDOM from 'react-dom';

function withGreeting(WrappedComponent) {
    return function EnhancedComponent(props) {
        return (
            <div>
                <h1>Hello, {props.name}!</h1>
                <WrappedComponent {...props} />
            </div>
        );
    };
}

function OriginalComponent(props) {
    return <p>This is the original component.</p>;
}

const EnhancedComponent = withGreeting(OriginalComponent);

ReactDOM.render(<EnhancedComponent name="Alice" />, document.getElementById('root'));
// Expected Output: A component with a greeting and the original component's content.
```

```jsx
// HOC for Data Fetching
import React, { useState, useEffect } from 'react';
import ReactDOM from 'react-dom';

function withDataFetching(WrappedComponent, url) {
    return function EnhancedComponent(props) {
        const [data, setData] = useState(null);
        const [loading, setLoading] = useState(true);

        useEffect(() => {
            fetch(url)
                .then(response => response.json())
                .then(data => {
                    setData(data);
                    setLoading(false);
                });
        }, [url]);

        return (
            <div>
                {loading ? <p>Loading...</p> : <WrappedComponent data={data} {...props} />}
            </div>
        );
    };
}

function DataDisplay({ data }) {
    return (
        <div>
            <h1>Data:</h1>
            <pre>{JSON.stringify(data, null, 2)}</pre>
        </div>
    );
}

const DataDisplayWithFetching = withDataFetching(DataDisplay, 'https://jsonplaceholder.typicode.com/posts/1');

ReactDOM.render(<DataDisplayWithFetching />, document.getElementById('root'));
// Expected Output: A component that displays data fetched from the provided URL.
```

#### Task 15: React Fragments
**Explanation:**
React Fragments allow you to

 group multiple elements without adding extra nodes to the DOM. This is useful when you need to return multiple elements from a component without wrapping them in a parent element, such as a `div`. Fragments can be created using the `React.Fragment` component or the shorthand syntax `<>...</>`.

Using fragments helps keep the DOM structure clean and avoids unnecessary nesting. This is particularly useful when you need to apply styling or layout to a specific structure without introducing additional wrapper elements.

**Online Resources:**
1. [Fragments - React](https://reactjs.org/docs/fragments.html)
2. [React Fragments Tutorial](https://www.w3schools.com/react/react_fragments.asp)

**Example 1: Using React.Fragment**
1. **Creating a Fragment:** Use `React.Fragment` to group multiple elements without adding extra nodes to the DOM.
2. **Rendering Multiple Elements:** Render multiple elements as children of a fragment.

**Explanation for Example 1:**
Using `React.Fragment` allows you to group multiple elements without adding extra nodes to the DOM. This keeps the DOM structure clean and avoids unnecessary nesting of elements.

**Example 2: Using Fragment Shorthand Syntax**
1. **Using Shorthand Syntax:** Use the shorthand syntax `<>...</>` to create a fragment.
2. **Rendering Multiple Elements:** Render multiple elements as children of a fragment using the shorthand syntax.

**Explanation for Example 2:**
The shorthand syntax `<>...</>` provides a more concise way to create fragments, making the code easier to read and write. This is useful for simple cases where you need to group multiple elements without adding extra nodes.

**Online Resources:**
1. [React Fragments Documentation](https://reactjs.org/docs/fragments.html#short-syntax)
2. [Using Fragments in React](https://www.digitalocean.com/community/tutorials/react-fragments)

**Code and Expected Output:**
```jsx
// Using React.Fragment
import React from 'react';
import ReactDOM from 'react-dom';

function App() {
    return (
        <React.Fragment>
            <h1>Title</h1>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
        </React.Fragment>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A title and two paragraphs rendered without extra DOM nodes.
```

```jsx
// Using Fragment Shorthand Syntax
import React from 'react';
import ReactDOM from 'react-dom';

function App() {
    return (
        <>
            <h1>Title</h1>
            <p>Paragraph 1</p>
            <p>Paragraph 2</p>
        </>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A title and two paragraphs rendered without extra DOM nodes.
```

#### Task 16: React Portals
**Explanation:**
React Portals provide a way to render children into a DOM node that exists outside the DOM hierarchy of the parent component. This is useful for cases where you need to render elements outside the regular DOM structure, such as modals, tooltips, or dropdowns. Portals allow you to manage component state and behavior within the React component tree while rendering the elements in a different part of the DOM.

Using portals helps you create UI elements that need to break out of the regular DOM hierarchy, ensuring that they are rendered correctly and positioned as needed. This technique enhances the flexibility and usability of your React components.

**Online Resources:**
1. [Portals - React](https://reactjs.org/docs/portals.html)
2. [React Portals Tutorial](https://www.w3schools.com/react/react_portals.asp)

**Example 1: Creating a Portal**
1. **Defining a Portal:** Create a portal using the `ReactDOM.createPortal` method.
2. **Rendering in a Different DOM Node:** Render a child component into a different DOM node using a portal.

**Explanation for Example 1:**
Creating a portal using `ReactDOM.createPortal` allows you to render a child component into a different DOM node. This is useful for elements that need to break out of the regular DOM hierarchy, such as modals or tooltips.

**Example 2: Using Portals for Modals**
1. **Creating a Modal Component:** Define a modal component that uses a portal to render its content.
2. **Managing Modal State:** Manage the state of the modal component within the React component tree.

**Explanation for Example 2:**
Using portals for modals allows you to render the modal content outside the regular DOM hierarchy, ensuring correct positioning and behavior. Managing the modal state within the React component tree allows you to control the modal's visibility and content dynamically.

**Online Resources:**
1. [React Portals Documentation](https://reactjs.org/docs/portals.html)
2. [Using React Portals](https://www.digitalocean.com/community/tutorials/react-portals)

**Code and Expected Output:**
```jsx
// Creating a Portal
import React from 'react';
import ReactDOM from 'react-dom';

function PortalExample() {
    return ReactDOM.createPortal(
        <div>
            <h1>This is a portal</h1>
        </div>,
        document.getElementById('portal-root')
    );
}

function App() {
    return (
        <div>
            <h1>Regular Component</h1>
            <PortalExample />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A regular component and a portal-rendered component.
```

```jsx
// Using Portals for Modals
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function Modal({ isOpen, onClose }) {
    if (!isOpen) return null;

    return ReactDOM.createPortal(
        <div className="modal">
            <div className="modal-content">
                <h2>Modal Title</h2>
                <p>This is a modal.</p>
                <button onClick={onClose}>Close</button>
            </div>
        </div>,
        document.getElementById('modal-root')
    );
}

function App() {
    const [isModalOpen, setModalOpen] = useState(false);

    const openModal = () => setModalOpen(true);
    const closeModal = () => setModalOpen(false);

    return (
        <div>
            <h1>React Portals Example</h1>
            <button onClick={openModal}>Open Modal</button>
            <Modal isOpen={isModalOpen} onClose={closeModal} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button that opens a modal rendered using a portal.
```

#### Task 17: Error Boundaries in React
**Explanation:**
Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log the errors, and display a fallback UI instead of crashing the whole component tree. Error boundaries are created using class components that implement `componentDidCatch` and `getDerivedStateFromError` lifecycle methods.

Error boundaries help you handle errors gracefully and improve the user experience by providing a fallback UI. They ensure that your application remains functional even when some components encounter errors.

**Online Resources:**
1. [Error Boundaries - React](https://reactjs.org/docs/error-boundaries.html)
2. [React Error Boundaries Tutorial](https://www.w3schools.com/react/react_error_boundaries.asp)

**Example 1: Creating an Error Boundary**
1. **Defining an Error Boundary:** Create a class component that implements `componentDidCatch` and `getDerivedStateFromError`.
2. **Using the Error Boundary:** Wrap child components with the error boundary to catch errors.

**Explanation for Example 1:**
Defining an error boundary involves creating a class component that implements `componentDidCatch` and `getDerivedStateFromError` to catch and handle errors. Wrapping child components with the error boundary ensures that errors are caught and handled gracefully.

**Example 2: Displaying Fallback UI**
1. **Fallback UI:** Define a fallback UI to display when an error is caught.
2. **Recovering from Errors:** Provide a way to recover from errors and reset the error boundary.

**Explanation for Example 2:**
Defining a fallback UI allows you to display a user-friendly message or component when an error is caught. Providing a way to recover from errors, such as a reset button, ensures that users can continue using the application after an error is handled.

**Online Resources:**
1. [React Error Boundaries Documentation](https://reactjs.org/docs/error-boundaries.html)
2. [Using Error Boundaries in React](https://www.digitalocean.com/community/tutorials/react-error-boundaries)

**Code and Expected Output:**
```jsx
// Creating an Error Boundary
import React from 'react';
import ReactDOM from 'react-dom';

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        console.error('Error caught by Error Boundary:', error, info);
    }

    render() {
        if (this.state.hasError) {
            return <h1>Something went wrong.</h1>;
        }

        return this.props.children;
    }
}

function BuggyComponent() {
    throw new Error('I crashed!');
}

function App() {
    return (
        <ErrorBoundary>
            <BuggyComponent />
        </ErrorBoundary>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output

: A fallback UI with the message "Something went wrong." when the BuggyComponent crashes.
```

```jsx
// Displaying Fallback UI
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

class ErrorBoundary extends React.Component {
    constructor(props) {
        super(props);
        this.state = { hasError: false };
    }

    static getDerivedStateFromError(error) {
        return { hasError: true };
    }

    componentDidCatch(error, info) {
        console.error('Error caught by Error Boundary:', error, info);
    }

    handleReset = () => {
        this.setState({ hasError: false });
    };

    render() {
        if (this.state.hasError) {
            return (
                <div>
                    <h1>Something went wrong.</h1>
                    <button onClick={this.handleReset}>Try Again</button>
                </div>
            );
        }

        return this.props.children;
    }
}

function BuggyComponent() {
    throw new Error('I crashed!');
}

function App() {
    const [key, setKey] = useState(0);

    const resetApp = () => {
        setKey(key + 1);
    };

    return (
        <ErrorBoundary key={key}>
            <button onClick={resetApp}>Reset</button>
            <BuggyComponent />
        </ErrorBoundary>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A fallback UI with the message "Something went wrong." and a button to reset the error boundary.
```

#### Task 18: Code Splitting in React
**Explanation:**
Code splitting in React allows you to split your code into smaller chunks, which can be loaded on demand. This improves the initial load time and performance of your application. React supports code splitting through dynamic `import()` and React.lazy, which can be used with `React.Suspense` to handle loading states.

Code splitting helps you optimize the performance of your application by loading only the necessary code for each route or component. This reduces the initial bundle size and allows users to load the application faster.

**Online Resources:**
1. [Code-Splitting - React](https://reactjs.org/docs/code-splitting.html)
2. [React Code Splitting Tutorial](https://www.w3schools.com/react/react_code_splitting.asp)

**Example 1: Using React.lazy**
1. **Lazy Loading Components:** Use `React.lazy` to lazy load components.
2. **Handling Loading States:** Use `React.Suspense` to handle loading states while the component is being loaded.

**Explanation for Example 1:**
Using `React.lazy` allows you to lazy load components, which means they are only loaded when needed. `React.Suspense` provides a fallback UI to display while the component is being loaded, ensuring a smooth user experience.

**Example 2: Dynamic Import with Webpack**
1. **Dynamic Import:** Use dynamic `import()` to load modules on demand.
2. **Configuring Webpack:** Configure Webpack to handle code splitting and create separate bundles for each module.

**Explanation for Example 2:**
Dynamic `import()` allows you to load modules on demand, creating separate bundles for each module. Configuring Webpack to handle code splitting ensures that the application loads only the necessary code for each route or component, improving performance.

**Online Resources:**
1. [React.lazy Documentation](https://reactjs.org/docs/code-splitting.html#reactlazy)
2. [Webpack Code Splitting](https://webpack.js.org/guides/code-splitting/)

**Code and Expected Output:**
```jsx
// Using React.lazy
import React, { Suspense, lazy } from 'react';
import ReactDOM from 'react-dom';

const LazyComponent = lazy(() => import('./LazyComponent'));

function App() {
    return (
        <div>
            <h1>React Code Splitting Example</h1>
            <Suspense fallback={<div>Loading...</div>}>
                <LazyComponent />
            </Suspense>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A loading state is displayed while the LazyComponent is being loaded.
```

```jsx
// Dynamic Import with Webpack
import React, { useState } from 'react';
import ReactDOM from 'react-dom';

function App() {
    const [Component, setComponent] = useState(null);

    const loadComponent = () => {
        import('./DynamicComponent')
            .then((module) => setComponent(() => module.default))
            .catch((error) => console.error('Error loading component:', error));
    };

    return (
        <div>
            <h1>React Dynamic Import Example</h1>
            <button onClick={loadComponent}>Load Component</button>
            {Component && <Component />}
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: A button that dynamically loads and renders the DynamicComponent.
```

#### Task 19: Testing in React
**Explanation:**
Testing in React involves using tools such as Jest and React Testing Library to write and run tests for your components. Jest is a JavaScript testing framework, while React Testing Library provides utilities for testing React components. Writing tests ensures that your components behave as expected and helps catch bugs early in the development process.

Unit tests focus on testing individual components, while integration tests test the interaction between components. Writing tests for your React components improves the reliability and maintainability of your application.

**Online Resources:**
1. [Testing - React](https://reactjs.org/docs/testing.html)
2. [React Testing Library](https://testing-library.com/docs/react-testing-library/intro/)

**Example 1: Unit Testing with Jest**
1. **Setting Up Jest:** Set up Jest for running tests in your React application.
2. **Writing Unit Tests:** Write unit tests for a React component using Jest.

**Explanation for Example 1:**
Setting up Jest allows you to run tests for your React components. Writing unit tests ensures that individual components behave as expected, helping you catch bugs and maintain code quality.

**Example 2: Testing Components with React Testing Library**
1. **Rendering Components:** Use React Testing Library to render components for testing.
2. **Testing Interactions:** Write tests to simulate user interactions and verify component behavior.

**Explanation for Example 2:**
React Testing Library provides utilities for rendering components and simulating user interactions. Writing tests to verify component behavior ensures that your components work correctly in response to user actions.

**Online Resources:**
1. [Jest Documentation](https://jestjs.io/docs/en/getting-started)
2. [React Testing Library Documentation](https://testing-library.com/docs/react-testing-library/intro/)

**Code and Expected Output:**
```sh
// Setting Up Jest
npm install --save-dev jest @testing-library/react @testing-library/jest-dom
```

```jsx
// Unit Testing with Jest
import React from 'react';
import { render, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';
import App from './App';

test('renders learn react link', () => {
    render(<App />);
    const linkElement = screen.getByText(/learn react/i);
    expect(linkElement).toBeInTheDocument();
});
// Expected Output: A test that verifies the presence of a "learn react" link in the App component.
```

```jsx
// Testing Components with React Testing Library
import React from 'react';
import { render, fireEvent, screen } from '@testing-library/react';
import '@testing-library/jest-dom/extend-expect';

function Counter() {
    const [count, setCount] = React.useState(0);

    return (
        <div>
            <p>Count: {count}</p>
            <button onClick={() => setCount(count + 1)}>Increment</button>
        </div>
    );
}

test('increments count', () => {
    render(<Counter />);
    const button = screen.getByText('Increment');
    fireEvent.click(button);
    expect(screen.getByText('Count: 1')).toBeInTheDocument();
});
// Expected Output: A test that verifies the count is incremented when the button is clicked.
```

#### Task 20: Optimizing Performance in React
**Explanation:**
Optimizing performance in React involves using techniques and tools to improve the efficiency and speed of your application. Common techniques include memoization, code splitting, and optimizing rendering. React provides tools such as `React.memo` and the React Developer Tools to help identify and address performance issues.

Optimizing performance ensures that your application runs smoothly and efficiently, providing a better user experience. Identifying and addressing performance bottlenecks helps you create high-performing React applications.

**Online Resources:**
1. [Optimizing Performance - React](https://reactjs.org/docs/optimizing-performance.html)
2. [React Performance Optimization](https://www.w3schools.com/react/react_performance.asp)

**Example 1: Memoization with React.memo**
1. **Using React.memo:** Use `React.memo` to memoize functional components and prevent unnecessary re-renders.
2. **Optimizing Performance:** Optimize performance by preventing components from re-rendering when their props have not changed.

**Explanation for Example 1:**
Using `React.memo` allows you to memoize functional components, which means they only re-render when their props change. This optimization helps improve performance by reducing unnecessary re-renders.

**Example 2: Using useCallback Hook**
1. **Optimizing Callbacks:** Use the `useCallback` hook to memoize callback functions and prevent them from being recreated on every render.
2. **Improving Performance:** Improve performance

 by ensuring that callback functions are only recreated when their dependencies change.

**Explanation for Example 2:**
The `useCallback` hook allows you to memoize callback functions, which means they are only recreated when their dependencies change. This optimization helps improve performance by preventing unnecessary function recreations and re-renders.

**Online Resources:**
1. [React.memo Documentation](https://reactjs.org/docs/react-api.html#reactmemo)
2. [Using the useCallback Hook](https://reactjs.org/docs/hooks-reference.html#usecallback)

**Code and Expected Output:**
```jsx
// Memoization with React.memo
import React from 'react';
import ReactDOM from 'react-dom';

const ExpensiveComponent = React.memo(({ count }) => {
    console.log('ExpensiveComponent rendered');
    return <p>Count: {count}</p>;
});

function App() {
    const [count, setCount] = React.useState(0);

    return (
        <div>
            <button onClick={() => setCount(count + 1)}>Increment</button>
            <ExpensiveComponent count={count} />
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: The ExpensiveComponent only re-renders when the count changes.
```

```jsx
// Using useCallback Hook
import React, { useState, useCallback } from 'react';
import ReactDOM from 'react-dom';

function Button({ onClick }) {
    console.log('Button rendered');
    return <button onClick={onClick}>Click Me</button>;
}

const MemoizedButton = React.memo(Button);

function App() {
    const [count, setCount] = useState(0);

    const handleClick = useCallback(() => {
        setCount(count + 1);
    }, [count]);

    return (
        <div>
            <MemoizedButton onClick={handleClick} />
            <p>Count: {count}</p>
        </div>
    );
}

ReactDOM.render(<App />, document.getElementById('root'));
// Expected Output: The Button component only re-renders when the handleClick function changes.
```

By completing these 20 tasks, you will gain a deep understanding of React.js fundamentals, including components, state, lifecycle, hooks, routing, context, error boundaries, code splitting, testing, and performance optimization. Each task builds on the previous ones, gradually enhancing your skills and knowledge in React.js development.
